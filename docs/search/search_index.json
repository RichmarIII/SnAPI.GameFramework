{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SnAPI.GameFramework","text":"<p>Gameplay framework for C++23</p> SnAPI.GameFramework <p>       A data-driven game framework centered around Node graphs, reflection metadata,       serialization pipelines, and network-aware gameplay systems.       It integrates directly with SnAPI.AssetPipeline, SnAPI.Networking, SnAPI.Audio, SnAPI.Physics, and SnAPI.Renderer.     </p> Get Started API Reference Architecture Node Graphs Reflection Serialization Replication + RPC Physics Simulation Audio Components Renderer Integration What you get <ul> <li>World/Level/NodeGraph runtime architecture with clean hierarchy and tick orchestration.</li> <li>Standalone graph support for prefab-style authored content that can be serialized and reused.</li> <li>UUID-first identity model with stable handles and safe end-of-frame destruction semantics.</li> <li>Data-driven node/component composition with minimal boilerplate and strong runtime ergonomics.</li> <li>Lazy, register-on-first-use reflection that avoids giant startup registration lists.</li> <li>Type-safe reflection metadata for fields, methods, constructors, and inheritance chains.</li> <li>Field and method flags for replication and network RPC intent directly in reflected metadata.</li> <li>Ergonomic gameplay RPC dispatch with `INode::CallRPC(...)` / `IComponent::CallRPC(...)` role-aware helpers.</li> <li>Reflection-powered graph, level, and world serialization with schema-versioned payloads.</li> <li>Custom value codec extension points (`TValueCodec`) for packed/high-performance data formats. <li>World-owned `PhysicsSystem` adapter over SnAPI.Physics with backend routing and coupling support.</li> <li>World-owned `RendererSystem` adapter over SnAPI.Renderer with optional default pass graph/window bootstrap.</li> <li>Built-in renderer components: `CameraComponent`, `StaticMeshComponent`, and `SkeletalMeshComponent`.</li> <li>Post-refactor render architecture where mesh assets are shared data and per-instance render state uses `IRenderObject`/`MeshRenderObject`.</li> <li>Component-level pass visibility/shadow toggles and per-instance material overrides for renderer-backed gameplay objects.</li> <li>Built-in `ColliderComponent`, `RigidBodyComponent`, and `CharacterMovementController` for fast gameplay iteration.</li> <li>Configurable physics stepping policy (fixed tick, variable tick, or fully manual step) per world runtime settings.</li> <li>Direct access to query/event APIs (`Raycast`, `Sweep`, `Overlap`, collision/trigger events) through world physics scene.</li> <li>First-class SnAPI.AssetPipeline integration for cooking, packing, mounting, and runtime loading.</li> <li>SnAPI.Networking bridges for auto-spawned replicated nodes/components and reflection-driven RPC.</li> <li>World-owned subsystem pattern (`Owner()-&gt;World()-&gt;...`) for scalable engine module integration.</li> <li>Integrated SnAPI.Audio listener/source components with transform-driven 3D spatial updates.</li> <li>Catch2 test coverage across handles, reflection, serialization, relevance, and replication behavior.</li>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>cmake -S . -B build/debug -DSNAPI_GF_BUILD_TESTS=ON -DSNAPI_GF_BUILD_DOCS=ON\ncmake --build build/debug\nctest --test-dir build/debug --output-on-failure\n</code></pre>"},{"location":"#learn-the-system","title":"Learn The System","text":"Worlds and Graphs <p>How World, Level, NodeGraph, and BaseNode fit together.</p> Nodes and Components <p>Create gameplay objects, add components, and drive lifecycle events.</p> Renderer Integration <p>Bootstrap world renderer, cameras, and mesh components with the new render-object flow.</p> Reflection and Serialization <p>Use TTypeBuilder metadata and reflection-driven serializers.</p> AssetPipeline Integration <p>Save/load NodeGraph, Level, and World payloads as assets.</p> Networking <p>Replicate nodes/components and invoke reflection RPC methods.</p> Physics Components <p>Configure world physics, rigid bodies, colliders, and character movement.</p> Physics Queries and Events <p>Run raycasts/overlaps, drain events, and tune backend routing/couplings.</p> Audio Components <p>Attach listeners and sources powered by SnAPI.Audio.</p>"},{"location":"#renderer-refactor-context-2026-02-15","title":"Renderer Refactor Context (2026-02-15)","text":"<p>These docs and examples include the renderer-side <code>IRenderObject</code> / <code>MeshRenderObject</code> model and are aligned with the post-refactor integration in <code>SnAPI.GameFramework</code>.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>SnAPI.GameFramework is built around four main axes:</p> <ol> <li>Runtime hierarchy: <code>World -&gt; Level -&gt; NodeGraph -&gt; BaseNode</code></li> <li>Type metadata: <code>TypeRegistry</code>, <code>TTypeBuilder</code>, and cached <code>TypeId</code></li> <li>Data transport: reflection serialization, asset payloads, and network replication</li> <li>World-owned simulation systems: networking, audio, physics, and renderer adapters</li> </ol>"},{"location":"architecture/#runtime-model","title":"Runtime Model","text":"<ul> <li><code>World</code> is the runtime root and owns subsystems (jobs, audio, networking bridges, physics system, renderer system).</li> <li><code>World</code> is also responsible for subsystem frame work (networking pump + audio update + optional physics step).</li> <li><code>Level</code> and <code>NodeGraph</code> are nodes, so graphs can be nested.</li> <li><code>BaseNode</code> owns hierarchy relationships and component type bookkeeping.</li> <li><code>IComponent</code> adds behavior and state to nodes without changing node types.</li> </ul>"},{"location":"architecture/#reflection-model","title":"Reflection Model","text":"<ul> <li><code>TypeId</code> is deterministic and generated from stable type names.</li> <li><code>SNAPI_REFLECT_TYPE(Type, ...)</code> installs lazy registration hooks.</li> <li>Metadata includes fields, methods, constructors, and inheritance chain.</li> <li><code>TypeRegistry::Find</code> auto-ensures missing reflected types on-demand.</li> </ul>"},{"location":"architecture/#serialization-model","title":"Serialization Model","text":"<ul> <li><code>ValueCodecRegistry</code> handles primitive/custom value codecs.</li> <li><code>ComponentSerializationRegistry</code> creates/serializes components by <code>TypeId</code>.</li> <li><code>NodeGraphSerializer</code>, <code>LevelSerializer</code>, and <code>WorldSerializer</code> convert runtime graphs to payloads.</li> <li>AssetPipeline serializers wrap these payloads into <code>snpak</code> assets.</li> </ul>"},{"location":"architecture/#networking-model","title":"Networking Model","text":"<ul> <li>Field replication is driven by reflection flags.</li> <li>RPC routing is driven by reflection method metadata.</li> <li><code>INode::CallRPC(...)</code> and <code>IComponent::CallRPC(...)</code> provide gameplay-facing routing helpers over reflected RPC endpoints.</li> <li><code>NetworkSystem</code> owns session/transport lifecycle (owner-only), then wires replication and RPC services.</li> <li><code>NetReplicationBridge</code> and <code>NetRpcBridge</code> coordinate with SnAPI.Networking services.</li> </ul>"},{"location":"architecture/#physics-model","title":"Physics Model","text":"<ul> <li><code>World</code> owns <code>PhysicsSystem</code>, which wraps <code>SnAPI::Physics::PhysicsRuntime</code> + one world scene.</li> <li>Physics bootstrap is configured through <code>GameRuntimeSettings::Physics</code> (<code>PhysicsBootstrapSettings</code>).</li> <li>Tick policy is configurable:<ul> <li>fixed stepping in <code>World::FixedTick(...)</code></li> <li>variable stepping in <code>World::Tick(...)</code></li> <li>or manual stepping by disabling both and calling <code>World::Physics().Step(...)</code>.</li> </ul> </li> <li>Component adapters:<ul> <li><code>ColliderComponent</code> stores shape/material/filter settings.</li> <li><code>RigidBodyComponent</code> creates/synchronizes backend bodies for owner nodes.</li> <li><code>CharacterMovementController</code> provides movement + grounded probe behavior using physics queries.</li> </ul> </li> <li>Direct scene access is available (<code>World::Physics().Scene()</code>) for domain APIs:<ul> <li>rigid body domain (<code>Rigid()</code>)</li> <li>query domain (<code>Query()</code>)</li> <li>event draining (<code>DrainEvents(...)</code>).</li> </ul> </li> </ul>"},{"location":"architecture/#rendering-model","title":"Rendering Model","text":"<ul> <li><code>World</code> owns one <code>RendererSystem</code> when renderer integration is compiled in.</li> <li><code>World::EndFrame()</code> delegates to <code>RendererSystem::EndFrame()</code> after graph <code>EndFrame()</code>.</li> <li><code>RendererSystem</code> owns renderer bootstrap/lifecycle and optional default pass graph creation.</li> <li><code>CameraComponent</code> manages world active camera selection and transform sync.</li> <li><code>StaticMeshComponent</code> and <code>SkeletalMeshComponent</code> are renderer bridge components for scene nodes.</li> <li>Mesh asset data and per-instance runtime render state are intentionally separated:</li> <li><code>Mesh</code> is shared asset data.</li> <li><code>MeshRenderObject</code> (via <code>IRenderObject</code>) stores per-instance materials, pass flags, transforms, and animation state.</li> <li>This split prevents per-instance mesh duplication and allows many nodes to share one mesh/vertex stream set while keeping independent render behavior.</li> </ul>"},{"location":"architecture/#audio-model","title":"Audio Model","text":"<ul> <li>World-level <code>AudioSystem</code> owns runtime backend state.</li> <li><code>World::Tick(...)</code> performs audio system frame update.</li> <li><code>AudioSourceComponent</code> and <code>AudioListenerComponent</code> bridge node state to audio playback/listening.</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This guide is written for a complete beginner who wants to understand how SnAPI.GameFramework actually works in code, not just copy snippets.</p> <p>You will build a mental model in this order:</p> <ol> <li>Runtime structure (<code>World -&gt; Level -&gt; NodeGraph -&gt; Node -&gt; Component</code>)</li> <li>Renderer ownership and render-object flow</li> <li>Physics ownership and simulation flow</li> <li>Reflection registration (how types become visible to the engine)</li> <li>Serialization and asset packaging</li> <li>Networking replication + RPC</li> <li>Audio components</li> <li>Testing and validation</li> </ol> <p>If you work through the pages in sequence, you will be able to read the examples in <code>examples/</code> and understand why each system is there.</p>"},{"location":"tutorials/#before-you-start","title":"Before You Start","text":"<p>You should be comfortable with:</p> <ul> <li>C++ classes, inheritance, and templates</li> <li>CMake build basics</li> <li>Running binaries from the terminal</li> </ul> <p>Build once before reading the tutorials so you can run examples as you go:</p> <pre><code>cmake -S . -B build/debug \\\n  -DSNAPI_GF_BUILD_TESTS=ON \\\n  -DSNAPI_GF_BUILD_EXAMPLES=ON\ncmake --build build/debug\n</code></pre> <p>Run tests:</p> <pre><code>ctest --test-dir build/debug --output-on-failure\n</code></pre> <p>Run examples:</p> <pre><code>./build/debug/examples/FeatureShowcase/FeatureShowcase\n./build/debug/examples/WorldPerfBenchmark/WorldPerfBenchmark\n./build/debug/examples/MultiplayerExample/MultiplayerExample --server\n./build/debug/examples/MultiplayerExample/MultiplayerExample --client\n</code></pre>"},{"location":"tutorials/#recommended-learning-path","title":"Recommended Learning Path","text":"<ol> <li>Worlds and Graphs</li> <li>Nodes and Components</li> <li>Renderer Integration and Mesh Components</li> <li>Physics System and Components</li> <li>Physics Queries and Events</li> <li>Reflection and Serialization</li> <li>AssetPipeline Integration</li> <li>Networking Replication and RPC</li> <li>Audio Components</li> <li>Testing and Validation</li> </ol>"},{"location":"tutorials/#core-ideas-you-should-keep-in-mind","title":"Core Ideas You Should Keep In Mind","text":"<ul> <li>Handles are identity; pointers are borrowed views.</li> <li>Reflection metadata is lazy-registered on first use.</li> <li>Serialization and networking both read reflection metadata.</li> <li>Gameplay RPC call sites can stay small with <code>INode::CallRPC(...)</code> / <code>IComponent::CallRPC(...)</code>.</li> <li>Replication has two gates:<ul> <li>The field must have <code>EFieldFlagBits::Replication</code>.</li> <li>The owning node/component must have <code>Replicated(true)</code>.</li> </ul> </li> <li>Nested field replication depends on codec availability:<ul> <li>with <code>TValueCodec&lt;T&gt;</code>, the full field value is codec-serialized.</li> <li>without a codec, only nested reflected fields marked for replication are serialized.</li> </ul> </li> <li><code>World</code> owns subsystem runtime (networking/audio/physics/renderer), and <code>GameRuntime</code> orchestrates world update phases.</li> <li>Renderer follows the same world-owned subsystem pattern (<code>World::Renderer()</code>), and render submit/present is driven by <code>World::EndFrame()</code>.</li> <li>Mesh assets are data-only; per-instance render behavior lives on render objects (<code>MeshRenderObject</code> via <code>IRenderObject</code>).</li> <li>Physics stepping can be configured:<ul> <li>fixed tick (<code>World::FixedTick</code>) for deterministic gameplay behavior.</li> <li>variable tick (<code>World::Tick</code>) for simple real-time simulation paths.</li> </ul> </li> <li><code>RigidBodyComponent</code> sync direction depends on body type:<ul> <li>dynamic bodies usually pull transforms from physics.</li> <li>static/kinematic bodies usually push transforms to physics.</li> </ul> </li> <li>Transport <code>pkt_lost</code> counters can be non-zero while gameplay remains correct; reliable backlog health is tracked with <code>pending_rel</code>.</li> <li>Destruction is deferred to <code>EndFrame()</code> to keep handles stable during a frame.</li> <li><code>CameraComponent</code>, <code>StaticMeshComponent</code>, and <code>SkeletalMeshComponent</code> are only available when renderer integration is compiled in.</li> </ul> <p>With that baseline, start with <code>Worlds and Graphs</code>.</p>"},{"location":"tutorials/#renderer-refactor-context-2026-02-15","title":"Renderer Refactor Context (2026-02-15)","text":"<p>Renderer docs/tutorials here track the post-refactor model where <code>Mesh</code> is asset data and runtime instance state is represented by <code>IRenderObject</code>/<code>MeshRenderObject</code>.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section is generated from Doxygen XML output and rendered inside MkDocs.</p> <ul> <li>Namespaces: 14</li> <li>Types: 84</li> <li>Files: 92</li> </ul>"},{"location":"api/#quick-index","title":"Quick Index","text":"<ul> <li>Namespaces</li> <li>Types</li> <li>Files</li> </ul>"},{"location":"api/Assert_8h/","title":"File <code>Assert.h</code>","text":""},{"location":"api/Assert_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::detail</li> </ul>"},{"location":"api/Assert_8h/#macros","title":"Macros","text":""},{"location":"api/Assert_8h/#debug_assert","title":"<code>DEBUG_ASSERT</code>","text":"<p>Debug-only assertion with formatted diagnostic message.</p> <p>Parameters</p> <ul> <li><code>condition</code>: Expression that must evaluate to true.</li> <li><code>fmt</code>: std::format-style format string.</li> <li><code>...</code>: </li> </ul> <p>Notes</p> <ul> <li>Compiled out when NDEBUG is defined.</li> </ul>"},{"location":"api/AssetPipelineFactories_8cpp/","title":"File <code>AssetPipelineFactories.cpp</code>","text":""},{"location":"api/AssetPipelineFactories_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TNodeGraphFactory</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TLevelFactory</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TWorldFactory</li> </ul>"},{"location":"api/AssetPipelineFactories_8h/","title":"File <code>AssetPipelineFactories.h</code>","text":""},{"location":"api/AssetPipelineFactories_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/AssetPipelineIds_8h/","title":"File <code>AssetPipelineIds.h</code>","text":""},{"location":"api/AssetPipelineIds_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/AssetPipelinePlugin_8cpp/","title":"File <code>AssetPipelinePlugin.cpp</code>","text":""},{"location":"api/AssetPipelinePlugin_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/AssetPipelineSerializers_8cpp/","title":"File <code>AssetPipelineSerializers.cpp</code>","text":""},{"location":"api/AssetPipelineSerializers_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer</li> </ul>"},{"location":"api/AssetPipelineSerializers_8h/","title":"File <code>AssetPipelineSerializers.h</code>","text":""},{"location":"api/AssetPipelineSerializers_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/AudioListenerComponent_8cpp/","title":"File <code>AudioListenerComponent.cpp</code>","text":""},{"location":"api/AudioListenerComponent_8h/","title":"File <code>AudioListenerComponent.h</code>","text":""},{"location":"api/AudioListenerComponent_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/AudioSourceComponent_8cpp/","title":"File <code>AudioSourceComponent.cpp</code>","text":""},{"location":"api/AudioSourceComponent_8h/","title":"File <code>AudioSourceComponent.h</code>","text":""},{"location":"api/AudioSourceComponent_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/AudioSystem_8cpp/","title":"File <code>AudioSystem.cpp</code>","text":""},{"location":"api/AudioSystem_8h/","title":"File <code>AudioSystem.h</code>","text":""},{"location":"api/BaseNode_8cpp/","title":"File <code>BaseNode.cpp</code>","text":""},{"location":"api/BaseNode_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/BaseNode_8h/","title":"File <code>BaseNode.h</code>","text":""},{"location":"api/BaseNode_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::BaseNode</li> </ul>"},{"location":"api/BuiltinTypes_8h/","title":"File <code>BuiltinTypes.h</code>","text":""},{"location":"api/BuiltinTypes_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/CameraComponent_8cpp/","title":"File <code>CameraComponent.cpp</code>","text":""},{"location":"api/CameraComponent_8h/","title":"File <code>CameraComponent.h</code>","text":""},{"location":"api/CharacterMovementController_8cpp/","title":"File <code>CharacterMovementController.cpp</code>","text":""},{"location":"api/CharacterMovementController_8h/","title":"File <code>CharacterMovementController.h</code>","text":""},{"location":"api/ColliderComponent_8cpp/","title":"File <code>ColliderComponent.cpp</code>","text":""},{"location":"api/ColliderComponent_8h/","title":"File <code>ColliderComponent.h</code>","text":""},{"location":"api/CollisionFilters_8h/","title":"File <code>CollisionFilters.h</code>","text":""},{"location":"api/ComponentStorage_8h/","title":"File <code>ComponentStorage.h</code>","text":""},{"location":"api/ComponentStorage_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::ComponentTypeRegistry</li> <li>Type: SnAPI::GameFramework::IComponentStorage</li> <li>Type: SnAPI::GameFramework::TComponentStorage</li> </ul>"},{"location":"api/Expected_8h/","title":"File <code>Expected.h</code>","text":""},{"location":"api/Expected_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::Error</li> <li>Type: SnAPI::GameFramework::TExpectedRef</li> </ul>"},{"location":"api/Export_8h/","title":"File <code>Export.h</code>","text":""},{"location":"api/Export_8h/#macros","title":"Macros","text":""},{"location":"api/Export_8h/#snapi_gameframework_api","title":"<code>SNAPI_GAMEFRAMEWORK_API</code>","text":"<p>Export/import macro for shared library builds.</p> <p>Notes</p> <ul> <li>Behavior varies by platform and build defines.</li> </ul>"},{"location":"api/FeatureShowcase_2main_8cpp/","title":"File <code>main.cpp</code>","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: anonymous_namespace{main.cpp}</li> <li>Type: AlwaysActivePolicy</li> <li>Type: DemoNode</li> <li>Type: DemoComponent</li> </ul>"},{"location":"api/FeatureShowcase_2main_8cpp/#functions","title":"Functions","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#base-basenode-fieldhealth","title":"<code>Base&lt; BaseNode &gt;() .Field(\"Health\"</code>","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#demonodem_health-fieldspeed-demonodem_speed-fieldtag","title":"<code>&amp;DemoNode::m_health Field(\"Speed\", &amp;DemoNode::m_speed) .Field(\"Tag\"</code>","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#demonodem_health-demonodem_tag-fieldspawn-demonodem_spawn-fieldtarget","title":"<code>&amp;DemoNode::m_health &amp;DemoNode::m_tag Field(\"Spawn\", &amp;DemoNode::m_spawn) .Field(\"Target\"</code>","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#demonodem_health-demonodem_tag-demonodem_target-constructor-register","title":"<code>&amp;DemoNode::m_health &amp;DemoNode::m_tag &amp;DemoNode::m_target Constructor() .Register()))</code>","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#fieldscore-democomponentm_score-fieldlabel","title":"<code>Field(\"Score\", &amp;DemoComponent::m_score) .Field(\"Label\"</code>","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#democomponentm_label-fieldtint-democomponentm_tint-constructor-register","title":"<code>&amp;DemoComponent::m_label Field(\"Tint\", &amp;DemoComponent::m_tint) .Constructor&lt;&gt;() .Register()))</code>","text":""},{"location":"api/FeatureShowcase_2main_8cpp/#int-main","title":"<code>int main()</code>","text":""},{"location":"api/Flags_8h/","title":"File <code>Flags.h</code>","text":""},{"location":"api/Flags_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TFlags</li> <li>Type: SnAPI::GameFramework::EnableFlags</li> </ul>"},{"location":"api/GameFramework_8cpp/","title":"File <code>GameFramework.cpp</code>","text":""},{"location":"api/GameFramework_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/GameFramework_8hpp/","title":"File <code>GameFramework.hpp</code>","text":""},{"location":"api/GameRuntime_8cpp/","title":"File <code>GameRuntime.cpp</code>","text":""},{"location":"api/GameRuntime_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/GameRuntime_8h/","title":"File <code>GameRuntime.h</code>","text":""},{"location":"api/GameRuntime_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::GameRuntimeTickSettings</li> <li>Type: SnAPI::GameFramework::GameRuntimeSettings</li> <li>Type: SnAPI::GameFramework::GameRuntime</li> </ul>"},{"location":"api/HandleFwd_8h/","title":"File <code>HandleFwd.h</code>","text":""},{"location":"api/HandleFwd_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/Handle_8h/","title":"File <code>Handle.h</code>","text":""},{"location":"api/Handle_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::THandle</li> <li>Type: SnAPI::GameFramework::HandleHash</li> </ul>"},{"location":"api/Handles_8h/","title":"File <code>Handles.h</code>","text":""},{"location":"api/Handles_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/IComponent_8cpp/","title":"File <code>IComponent.cpp</code>","text":""},{"location":"api/IComponent_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}</li> </ul>"},{"location":"api/IComponent_8h/","title":"File <code>IComponent.h</code>","text":""},{"location":"api/IComponent_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::IComponent</li> </ul>"},{"location":"api/ILevel_8h/","title":"File <code>ILevel.h</code>","text":""},{"location":"api/ILevel_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::ILevel</li> </ul>"},{"location":"api/INode_8cpp/","title":"File <code>INode.cpp</code>","text":""},{"location":"api/INode_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{INode.cpp}</li> </ul>"},{"location":"api/INode_8h/","title":"File <code>INode.h</code>","text":""},{"location":"api/INode_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::INode</li> </ul>"},{"location":"api/IWorld_8h/","title":"File <code>IWorld.h</code>","text":""},{"location":"api/IWorld_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::IWorld</li> </ul>"},{"location":"api/Invoker_8h/","title":"File <code>Invoker.h</code>","text":""},{"location":"api/Invoker_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::detail</li> <li>Type: SnAPI::GameFramework::detail::TArgStorage</li> </ul>"},{"location":"api/JobSystem_8h/","title":"File <code>JobSystem.h</code>","text":""},{"location":"api/JobSystem_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::JobSystem</li> </ul>"},{"location":"api/Level_8cpp/","title":"File <code>Level.cpp</code>","text":""},{"location":"api/Level_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/Level_8h/","title":"File <code>Level.h</code>","text":""},{"location":"api/Level_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::Level</li> </ul>"},{"location":"api/Math_8h/","title":"File <code>Math.h</code>","text":""},{"location":"api/Math_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/MultiplayerExample_2main_8cpp/","title":"File <code>main.cpp</code>","text":""},{"location":"api/MultiplayerExample_2main_8cpp/#functions","title":"Functions","text":""},{"location":"api/MultiplayerExample_2main_8cpp/#int-mainint-char","title":"<code>int main(int, char **)</code>","text":""},{"location":"api/NetReplication_8cpp/","title":"File <code>NetReplication.cpp</code>","text":""},{"location":"api/NetReplication_8h/","title":"File <code>NetReplication.h</code>","text":""},{"location":"api/NetReplication_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/NetRpc_8cpp/","title":"File <code>NetRpc.cpp</code>","text":""},{"location":"api/NetRpc_8h/","title":"File <code>NetRpc.h</code>","text":""},{"location":"api/NetRpc_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/NetworkSystem_8cpp/","title":"File <code>NetworkSystem.cpp</code>","text":""},{"location":"api/NetworkSystem_8h/","title":"File <code>NetworkSystem.h</code>","text":""},{"location":"api/NodeGraph_8cpp/","title":"File <code>NodeGraph.cpp</code>","text":""},{"location":"api/NodeGraph_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/NodeGraph_8h/","title":"File <code>NodeGraph.h</code>","text":""},{"location":"api/NodeGraph_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::NodeGraph</li> </ul>"},{"location":"api/ObjectPool_8h/","title":"File <code>ObjectPool.h</code>","text":""},{"location":"api/ObjectPool_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TObjectPool</li> <li>Type: SnAPI::GameFramework::TObjectPool::Entry</li> </ul>"},{"location":"api/ObjectRegistry_8h/","title":"File <code>ObjectRegistry.h</code>","text":""},{"location":"api/ObjectRegistry_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::ObjectRegistry</li> <li>Type: SnAPI::GameFramework::ObjectRegistry::Entry</li> </ul>"},{"location":"api/PhysicsSystem_8cpp/","title":"File <code>PhysicsSystem.cpp</code>","text":""},{"location":"api/PhysicsSystem_8h/","title":"File <code>PhysicsSystem.h</code>","text":""},{"location":"api/Profiling_8h/","title":"File <code>Profiling.h</code>","text":""},{"location":"api/Profiling_8h/#macros","title":"Macros","text":""},{"location":"api/Profiling_8h/#snapi_gf_profile_scope","title":"<code>SNAPI_GF_PROFILE_SCOPE</code>","text":"<p>Parameters</p> <ul> <li><code>Name</code>: </li> <li><code>Category</code>:</li> </ul>"},{"location":"api/Profiling_8h/#snapi_gf_profile_function","title":"<code>SNAPI_GF_PROFILE_FUNCTION</code>","text":"<p>Parameters</p> <ul> <li><code>Category</code>:</li> </ul>"},{"location":"api/Profiling_8h/#snapi_gf_profile_set_thread_name","title":"<code>SNAPI_GF_PROFILE_SET_THREAD_NAME</code>","text":"<p>Parameters</p> <ul> <li><code>Name</code>:</li> </ul>"},{"location":"api/Profiling_8h/#snapi_gf_profile_begin_frame_auto","title":"<code>SNAPI_GF_PROFILE_BEGIN_FRAME_AUTO</code>","text":""},{"location":"api/Profiling_8h/#snapi_gf_profile_begin_frame","title":"<code>SNAPI_GF_PROFILE_BEGIN_FRAME</code>","text":"<p>Parameters</p> <ul> <li><code>FrameIndex</code>:</li> </ul>"},{"location":"api/Profiling_8h/#snapi_gf_profile_end_frame","title":"<code>SNAPI_GF_PROFILE_END_FRAME</code>","text":""},{"location":"api/Reflection_8h/","title":"File <code>Reflection.h</code>","text":""},{"location":"api/Relevance_8h/","title":"File <code>Relevance.h</code>","text":""},{"location":"api/Relevance_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::RelevanceContext</li> <li>Type: SnAPI::GameFramework::RelevancePolicyRegistry</li> <li>Type: SnAPI::GameFramework::RelevancePolicyRegistry::PolicyInfo</li> <li>Type: SnAPI::GameFramework::RelevanceComponent</li> </ul>"},{"location":"api/RendererSystem_8cpp/","title":"File <code>RendererSystem.cpp</code>","text":""},{"location":"api/RendererSystem_8h/","title":"File <code>RendererSystem.h</code>","text":""},{"location":"api/RigidBodyComponent_8cpp/","title":"File <code>RigidBodyComponent.cpp</code>","text":""},{"location":"api/RigidBodyComponent_8h/","title":"File <code>RigidBodyComponent.h</code>","text":""},{"location":"api/ScriptABI_8cpp/","title":"File <code>ScriptABI.cpp</code>","text":""},{"location":"api/ScriptABI_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}</li> </ul>"},{"location":"api/ScriptABI_8cpp/#functions","title":"Functions","text":""},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfuuid-sn_gf_type_id_from_nameconst-char-name","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_type_id_from_name(const char *name)</code>","text":"<p>Get a TypeId from a fully qualified name.</p> <p>Parameters</p> <ul> <li><code>name</code>: Type name string.</li> </ul> <p>Returns: UUID for the type.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-int-sn_gf_type_is_registeredsngfuuid-id","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_type_is_registered(SnGfUuid id)</code>","text":"<p>Check if a type is registered.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to check.</li> </ul> <p>Returns: Non-zero if the type exists.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-size_t-sn_gf_type_field_countsngfuuid-id","title":"<code>SNAPI_GAMEFRAMEWORK_API size_t sn_gf_type_field_count(SnGfUuid id)</code>","text":"<p>Get the number of fields on a type.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> </ul> <p>Returns: Field count.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngffieldhandle-sn_gf_type_field_by_namesngfuuid-id-const-char-name","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfFieldHandle sn_gf_type_field_by_name(SnGfUuid id, const char *name)</code>","text":"<p>Find a field by name.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>name</code>: Field name.</li> </ul> <p>Returns: Field handle or 0 if not found.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfuuid-sn_gf_field_typesngfuuid-id-sngffieldhandle-field","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_field_type(SnGfUuid id, SnGfFieldHandle field)</code>","text":"<p>Get the type of a field.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>field</code>: Field handle.</li> </ul> <p>Returns: Field type id.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-const-char-sn_gf_field_namesngfuuid-id-sngffieldhandle-field","title":"<code>SNAPI_GAMEFRAMEWORK_API const char * sn_gf_field_name(SnGfUuid id, SnGfFieldHandle field)</code>","text":"<p>Get the name of a field.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>field</code>: Field handle.</li> </ul> <p>Returns: Null-terminated field name string.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfmethodhandle-sn_gf_type_method_by_namesngfuuid-id-const-char-name","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfMethodHandle sn_gf_type_method_by_name(SnGfUuid id, const char *name)</code>","text":"<p>Find a method by name.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>name</code>: Method name.</li> </ul> <p>Returns: Method handle or 0 if not found.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfuuid-sn_gf_method_return_typesngfuuid-id-sngfmethodhandle-method","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_method_return_type(SnGfUuid id, SnGfMethodHandle method)</code>","text":"<p>Get the return type of a method.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>method</code>: Method handle.</li> </ul> <p>Returns: Return type id.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-size_t-sn_gf_method_param_countsngfuuid-id-sngfmethodhandle-method","title":"<code>SNAPI_GAMEFRAMEWORK_API size_t sn_gf_method_param_count(SnGfUuid id, SnGfMethodHandle method)</code>","text":"<p>Get the number of method parameters.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>method</code>: Method handle.</li> </ul> <p>Returns: Parameter count.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfuuid-sn_gf_method_param_typesngfuuid-id-sngfmethodhandle-method-size_t-index","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_method_param_type(SnGfUuid id, SnGfMethodHandle method, size_t index)</code>","text":"<p>Get the type of a method parameter.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>method</code>: Method handle.</li> <li><code>index</code>: Parameter index.</li> </ul> <p>Returns: Parameter type id.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_intint-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_int(int value)</code>","text":"<p>Create a Variant from an int.</p> <p>Parameters</p> <ul> <li><code>value</code>: Value to store.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_floatfloat-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_float(float value)</code>","text":"<p>Create a Variant from a float.</p> <p>Parameters</p> <ul> <li><code>value</code>: Value to store.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_boolint-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_bool(int value)</code>","text":"<p>Create a Variant from a bool.</p> <p>Parameters</p> <ul> <li><code>value</code>: Non-zero for true, zero for false.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_stringconst-char-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_string(const char *value)</code>","text":"<p>Create a Variant from a string.</p> <p>Parameters</p> <ul> <li><code>value</code>: Null-terminated string.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-void-sn_gf_variant_destroysngfvarianthandle-handle","title":"<code>SNAPI_GAMEFRAMEWORK_API void sn_gf_variant_destroy(SnGfVariantHandle handle)</code>","text":"<p>Destroy a Variant handle.</p> <p>Parameters</p> <ul> <li><code>handle</code>: Variant handle to destroy.</li> </ul>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-int-sn_gf_object_get_fieldvoid-instance-sngfuuid-type-sngffieldhandle-field-sngfvarianthandle-outvalue","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_object_get_field(void *instance, SnGfUuid type, SnGfFieldHandle field, SnGfVariantHandle *outValue)</code>","text":"<p>Read a field value from an object.</p> <p>Parameters</p> <ul> <li><code>instance</code>: Pointer to the object instance.</li> <li><code>type</code>: TypeId of the instance.</li> <li><code>field</code>: Field handle.</li> <li><code>outValue</code>: Output Variant handle.</li> </ul> <p>Returns: Non-zero on success.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-int-sn_gf_object_set_fieldvoid-instance-sngfuuid-type-sngffieldhandle-field-sngfvarianthandle-value","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_object_set_field(void *instance, SnGfUuid type, SnGfFieldHandle field, SnGfVariantHandle value)</code>","text":"<p>Write a field value on an object.</p> <p>Parameters</p> <ul> <li><code>instance</code>: Pointer to the object instance.</li> <li><code>type</code>: TypeId of the instance.</li> <li><code>field</code>: Field handle.</li> <li><code>value</code>: Variant handle containing the new value.</li> </ul> <p>Returns: Non-zero on success.</p>"},{"location":"api/ScriptABI_8cpp/#snapi_gameframework_api-int-sn_gf_object_invokevoid-instance-sngfuuid-type-sngfmethodhandle-method-const-sngfvarianthandle-args-size_t-argcount-sngfvarianthandle-outresult","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_object_invoke(void *instance, SnGfUuid type, SnGfMethodHandle method, const SnGfVariantHandle *args, size_t argCount, SnGfVariantHandle *outResult)</code>","text":"<p>Invoke a reflected method on an object.</p> <p>Parameters</p> <ul> <li><code>instance</code>: Pointer to the object instance.</li> <li><code>type</code>: TypeId of the instance.</li> <li><code>method</code>: Method handle.</li> <li><code>args</code>: Array of Variant handles for arguments.</li> <li><code>argCount</code>: Argument count.</li> <li><code>outResult</code>: Output Variant handle for the return value.</li> </ul> <p>Returns: Non-zero on success.</p>"},{"location":"api/ScriptABI_8h/","title":"File <code>ScriptABI.h</code>","text":""},{"location":"api/ScriptABI_8h/#contents","title":"Contents","text":"<ul> <li>Type: SnGfUuid</li> <li>Type: SnGfVariantHandle</li> </ul>"},{"location":"api/ScriptABI_8h/#type-aliases","title":"Type Aliases","text":""},{"location":"api/ScriptABI_8h/#typedef-struct-sngfuuid-sngfuuid","title":"<code>typedef struct SnGfUuid SnGfUuid</code>","text":"<p>C ABI representation of a UUID.</p>"},{"location":"api/ScriptABI_8h/#typedef-struct-sngfvarianthandle-sngfvarianthandle","title":"<code>typedef struct SnGfVariantHandle SnGfVariantHandle</code>","text":"<p>Opaque handle to a Variant owned by the runtime.</p>"},{"location":"api/ScriptABI_8h/#typedef-uint64_t-sngffieldhandle","title":"<code>typedef uint64_t SnGfFieldHandle</code>","text":"<p>Opaque handle to a reflected field.</p>"},{"location":"api/ScriptABI_8h/#typedef-uint64_t-sngfmethodhandle","title":"<code>typedef uint64_t SnGfMethodHandle</code>","text":"<p>Opaque handle to a reflected method.</p>"},{"location":"api/ScriptABI_8h/#functions","title":"Functions","text":""},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfuuid-sn_gf_type_id_from_nameconst-char-name","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_type_id_from_name(const char *name)</code>","text":"<p>Get a TypeId from a fully qualified name.</p> <p>Parameters</p> <ul> <li><code>name</code>: Type name string.</li> </ul> <p>Returns: UUID for the type.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-int-sn_gf_type_is_registeredsngfuuid-id","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_type_is_registered(SnGfUuid id)</code>","text":"<p>Check if a type is registered.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to check.</li> </ul> <p>Returns: Non-zero if the type exists.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-size_t-sn_gf_type_field_countsngfuuid-id","title":"<code>SNAPI_GAMEFRAMEWORK_API size_t sn_gf_type_field_count(SnGfUuid id)</code>","text":"<p>Get the number of fields on a type.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> </ul> <p>Returns: Field count.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngffieldhandle-sn_gf_type_field_by_namesngfuuid-id-const-char-name","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfFieldHandle sn_gf_type_field_by_name(SnGfUuid id, const char *name)</code>","text":"<p>Find a field by name.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>name</code>: Field name.</li> </ul> <p>Returns: Field handle or 0 if not found.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfuuid-sn_gf_field_typesngfuuid-id-sngffieldhandle-field","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_field_type(SnGfUuid id, SnGfFieldHandle field)</code>","text":"<p>Get the type of a field.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>field</code>: Field handle.</li> </ul> <p>Returns: Field type id.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-const-char-sn_gf_field_namesngfuuid-id-sngffieldhandle-field","title":"<code>SNAPI_GAMEFRAMEWORK_API const char * sn_gf_field_name(SnGfUuid id, SnGfFieldHandle field)</code>","text":"<p>Get the name of a field.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>field</code>: Field handle.</li> </ul> <p>Returns: Null-terminated field name string.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfmethodhandle-sn_gf_type_method_by_namesngfuuid-id-const-char-name","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfMethodHandle sn_gf_type_method_by_name(SnGfUuid id, const char *name)</code>","text":"<p>Find a method by name.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>name</code>: Method name.</li> </ul> <p>Returns: Method handle or 0 if not found.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfuuid-sn_gf_method_return_typesngfuuid-id-sngfmethodhandle-method","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_method_return_type(SnGfUuid id, SnGfMethodHandle method)</code>","text":"<p>Get the return type of a method.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>method</code>: Method handle.</li> </ul> <p>Returns: Return type id.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-size_t-sn_gf_method_param_countsngfuuid-id-sngfmethodhandle-method","title":"<code>SNAPI_GAMEFRAMEWORK_API size_t sn_gf_method_param_count(SnGfUuid id, SnGfMethodHandle method)</code>","text":"<p>Get the number of method parameters.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>method</code>: Method handle.</li> </ul> <p>Returns: Parameter count.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfuuid-sn_gf_method_param_typesngfuuid-id-sngfmethodhandle-method-size_t-index","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfUuid sn_gf_method_param_type(SnGfUuid id, SnGfMethodHandle method, size_t index)</code>","text":"<p>Get the type of a method parameter.</p> <p>Parameters</p> <ul> <li><code>id</code>: TypeId to query.</li> <li><code>method</code>: Method handle.</li> <li><code>index</code>: Parameter index.</li> </ul> <p>Returns: Parameter type id.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_intint-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_int(int value)</code>","text":"<p>Create a Variant from an int.</p> <p>Parameters</p> <ul> <li><code>value</code>: Value to store.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_floatfloat-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_float(float value)</code>","text":"<p>Create a Variant from a float.</p> <p>Parameters</p> <ul> <li><code>value</code>: Value to store.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_boolint-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_bool(int value)</code>","text":"<p>Create a Variant from a bool.</p> <p>Parameters</p> <ul> <li><code>value</code>: Non-zero for true, zero for false.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-sngfvarianthandle-sn_gf_variant_from_stringconst-char-value","title":"<code>SNAPI_GAMEFRAMEWORK_API SnGfVariantHandle sn_gf_variant_from_string(const char *value)</code>","text":"<p>Create a Variant from a string.</p> <p>Parameters</p> <ul> <li><code>value</code>: Null-terminated string.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-void-sn_gf_variant_destroysngfvarianthandle-handle","title":"<code>SNAPI_GAMEFRAMEWORK_API void sn_gf_variant_destroy(SnGfVariantHandle handle)</code>","text":"<p>Destroy a Variant handle.</p> <p>Parameters</p> <ul> <li><code>handle</code>: Variant handle to destroy.</li> </ul>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-int-sn_gf_object_get_fieldvoid-instance-sngfuuid-type-sngffieldhandle-field-sngfvarianthandle-outvalue","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_object_get_field(void *instance, SnGfUuid type, SnGfFieldHandle field, SnGfVariantHandle *outValue)</code>","text":"<p>Read a field value from an object.</p> <p>Parameters</p> <ul> <li><code>instance</code>: Pointer to the object instance.</li> <li><code>type</code>: TypeId of the instance.</li> <li><code>field</code>: Field handle.</li> <li><code>outValue</code>: Output Variant handle.</li> </ul> <p>Returns: Non-zero on success.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-int-sn_gf_object_set_fieldvoid-instance-sngfuuid-type-sngffieldhandle-field-sngfvarianthandle-value","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_object_set_field(void *instance, SnGfUuid type, SnGfFieldHandle field, SnGfVariantHandle value)</code>","text":"<p>Write a field value on an object.</p> <p>Parameters</p> <ul> <li><code>instance</code>: Pointer to the object instance.</li> <li><code>type</code>: TypeId of the instance.</li> <li><code>field</code>: Field handle.</li> <li><code>value</code>: Variant handle containing the new value.</li> </ul> <p>Returns: Non-zero on success.</p>"},{"location":"api/ScriptABI_8h/#snapi_gameframework_api-int-sn_gf_object_invokevoid-instance-sngfuuid-type-sngfmethodhandle-method-const-sngfvarianthandle-args-size_t-argcount-sngfvarianthandle-outresult","title":"<code>SNAPI_GAMEFRAMEWORK_API int sn_gf_object_invoke(void *instance, SnGfUuid type, SnGfMethodHandle method, const SnGfVariantHandle *args, size_t argCount, SnGfVariantHandle *outResult)</code>","text":"<p>Invoke a reflected method on an object.</p> <p>Parameters</p> <ul> <li><code>instance</code>: Pointer to the object instance.</li> <li><code>type</code>: TypeId of the instance.</li> <li><code>method</code>: Method handle.</li> <li><code>args</code>: Array of Variant handles for arguments.</li> <li><code>argCount</code>: Argument count.</li> <li><code>outResult</code>: Output Variant handle for the return value.</li> </ul> <p>Returns: Non-zero on success.</p>"},{"location":"api/ScriptBindings_8h/","title":"File <code>ScriptBindings.h</code>","text":""},{"location":"api/ScriptBindings_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::ScriptBindings</li> </ul>"},{"location":"api/ScriptComponent_8h/","title":"File <code>ScriptComponent.h</code>","text":""},{"location":"api/ScriptComponent_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::ScriptComponent</li> </ul>"},{"location":"api/ScriptEngine_8h/","title":"File <code>ScriptEngine.h</code>","text":""},{"location":"api/ScriptEngine_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::IScriptEngine</li> <li>Type: SnAPI::GameFramework::ScriptRuntime</li> </ul>"},{"location":"api/Serialization_8cpp/","title":"File <code>Serialization.cpp</code>","text":""},{"location":"api/Serialization_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: cereal</li> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::MemoryReadStreambuf</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableFieldCacheEntry</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard</li> </ul>"},{"location":"api/Serialization_8h/","title":"File <code>Serialization.h</code>","text":""},{"location":"api/Serialization_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TSerializationContext</li> <li>Type: SnAPI::GameFramework::TValueCodec</li> <li>Type: SnAPI::GameFramework::ValueCodecRegistry</li> <li>Type: SnAPI::GameFramework::ValueCodecRegistry::CodecEntry</li> <li>Type: SnAPI::GameFramework::ComponentSerializationRegistry</li> <li>Type: SnAPI::GameFramework::ComponentSerializationRegistry::Entry</li> <li>Type: SnAPI::GameFramework::NodeComponentPayload</li> <li>Type: SnAPI::GameFramework::NodePayload</li> <li>Type: SnAPI::GameFramework::NodeGraphPayload</li> <li>Type: SnAPI::GameFramework::LevelPayload</li> <li>Type: SnAPI::GameFramework::WorldPayload</li> <li>Type: SnAPI::GameFramework::NodeGraphSerializer</li> <li>Type: SnAPI::GameFramework::LevelSerializer</li> <li>Type: SnAPI::GameFramework::WorldSerializer</li> </ul>"},{"location":"api/SkeletalMeshComponent_8cpp/","title":"File <code>SkeletalMeshComponent.cpp</code>","text":""},{"location":"api/SkeletalMeshComponent_8h/","title":"File <code>SkeletalMeshComponent.h</code>","text":""},{"location":"api/StaticMeshComponent_8cpp/","title":"File <code>StaticMeshComponent.cpp</code>","text":""},{"location":"api/StaticMeshComponent_8h/","title":"File <code>StaticMeshComponent.h</code>","text":""},{"location":"api/StaticTypeId_8h/","title":"File <code>StaticTypeId.h</code>","text":""},{"location":"api/StaticTypeId_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/TransformComponent_8h/","title":"File <code>TransformComponent.h</code>","text":""},{"location":"api/TransformComponent_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TransformComponent</li> </ul>"},{"location":"api/TypeAutoRegistration_8h/","title":"File <code>TypeAutoRegistration.h</code>","text":""},{"location":"api/TypeAutoRegistration_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TTypeRegistrar</li> </ul>"},{"location":"api/TypeAutoRegistration_8h/#macros","title":"Macros","text":""},{"location":"api/TypeAutoRegistration_8h/#snapi_detail_concat_inner","title":"<code>SNAPI_DETAIL_CONCAT_INNER</code>","text":"<p>Internal macro helper for concatenation.</p> <p>Parameters</p> <ul> <li><code>a</code>: </li> <li><code>b</code>:</li> </ul>"},{"location":"api/TypeAutoRegistration_8h/#snapi_detail_concat","title":"<code>SNAPI_DETAIL_CONCAT</code>","text":"<p>Internal macro helper for concatenation.</p> <p>Parameters</p> <ul> <li><code>a</code>: </li> <li><code>b</code>:</li> </ul>"},{"location":"api/TypeAutoRegistration_8h/#snapi_detail_used","title":"<code>SNAPI_DETAIL_USED</code>","text":"<p>Internal macro helper for \"used\" attribute to survive LTO/GC-sections.</p>"},{"location":"api/TypeAutoRegistration_8h/#snapi_reflect_type_impl","title":"<code>SNAPI_REFLECT_TYPE_IMPL</code>","text":"<p>Register a reflected type using a builder expression (lazy).</p> <p>Parameters</p> <ul> <li><code>Type</code>: </li> <li><code>BuilderExpr</code>: Expression that builds and registers the type.</li> <li><code>Id</code>: Unique counter to avoid symbol collisions.</li> </ul>"},{"location":"api/TypeAutoRegistration_8h/#snapi_reflect_type","title":"<code>SNAPI_REFLECT_TYPE</code>","text":"<p>Register a reflected type using a builder expression (lazy).</p> <p>Parameters</p> <ul> <li><code>Type</code>: C++ type being registered.</li> <li><code>BuilderExpr</code>: Expression that builds and registers the type's TypeInfo.</li> </ul>"},{"location":"api/TypeAutoRegistration_8h/#snapi_reflect_component","title":"<code>SNAPI_REFLECT_COMPONENT</code>","text":"<p>Register a reflected component type and its serializer.</p> <p>Parameters</p> <ul> <li><code>ComponentType</code>: Component C++ type.</li> <li><code>BuilderExpr</code>: Expression that builds and registers the type's TypeInfo.</li> </ul>"},{"location":"api/TypeAutoRegistry_8cpp/","title":"File <code>TypeAutoRegistry.cpp</code>","text":""},{"location":"api/TypeAutoRegistry_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/TypeAutoRegistry_8h/","title":"File <code>TypeAutoRegistry.h</code>","text":""},{"location":"api/TypeAutoRegistry_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TypeAutoRegistry</li> </ul>"},{"location":"api/TypeBuilder_8h/","title":"File <code>TypeBuilder.h</code>","text":""},{"location":"api/TypeBuilder_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TTypeBuilder</li> </ul>"},{"location":"api/TypeName_8h/","title":"File <code>TypeName.h</code>","text":""},{"location":"api/TypeName_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TTypeName</li> </ul>"},{"location":"api/TypeName_8h/#macros","title":"Macros","text":""},{"location":"api/TypeName_8h/#snapi_define_type_name","title":"<code>SNAPI_DEFINE_TYPE_NAME</code>","text":"<p>Macro to specialize TTypeName for a type without kTypeName.</p> <p>Parameters</p> <ul> <li><code>Type</code>: C++ type to specialize.</li> <li><code>Name</code>: Fully qualified name string.</li> </ul>"},{"location":"api/TypeRegistration_8h/","title":"File <code>TypeRegistration.h</code>","text":""},{"location":"api/TypeRegistration_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/TypeRegistry_8cpp/","title":"File <code>TypeRegistry.cpp</code>","text":""},{"location":"api/TypeRegistry_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{TypeRegistry.cpp}</li> </ul>"},{"location":"api/TypeRegistry_8h/","title":"File <code>TypeRegistry.h</code>","text":""},{"location":"api/TypeRegistry_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::TransparentStringHash</li> <li>Type: SnAPI::GameFramework::TransparentStringEqual</li> <li>Type: SnAPI::GameFramework::EnableFlags&lt; EFieldFlagBits &gt;</li> <li>Type: SnAPI::GameFramework::EnableFlags&lt; EMethodFlagBits &gt;</li> <li>Type: SnAPI::GameFramework::FieldInfo</li> <li>Type: SnAPI::GameFramework::MethodInfo</li> <li>Type: SnAPI::GameFramework::ConstructorInfo</li> <li>Type: SnAPI::GameFramework::TypeInfo</li> <li>Type: SnAPI::GameFramework::TypeRegistry</li> </ul>"},{"location":"api/Uuid_8h/","title":"File <code>Uuid.h</code>","text":""},{"location":"api/Uuid_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::UuidParts</li> <li>Type: SnAPI::GameFramework::UuidHash</li> </ul>"},{"location":"api/Variant_8h/","title":"File <code>Variant.h</code>","text":""},{"location":"api/Variant_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::Variant</li> <li>Type: SnAPI::GameFramework::VariantView</li> </ul>"},{"location":"api/WorldPerfBenchmark_2main_8cpp/","title":"File <code>main.cpp</code>","text":""},{"location":"api/WorldPerfBenchmark_2main_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: anonymous_namespace{main.cpp}</li> <li>Type: PerfComponentA</li> <li>Type: PerfComponentB</li> </ul>"},{"location":"api/WorldPerfBenchmark_2main_8cpp/#functions","title":"Functions","text":""},{"location":"api/WorldPerfBenchmark_2main_8cpp/#fieldindex-perfcomponentam_index-fieldweight","title":"<code>Field(\"Index\", &amp;PerfComponentA::m_index) .Field(\"Weight\"</code>","text":""},{"location":"api/WorldPerfBenchmark_2main_8cpp/#perfcomponentam_weight-fieldoffset-perfcomponentam_offset-fieldblob","title":"<code>&amp;PerfComponentA::m_weight Field(\"Offset\", &amp;PerfComponentA::m_offset) .Field(\"Blob\"</code>","text":""},{"location":"api/WorldPerfBenchmark_2main_8cpp/#perfcomponentam_weight-perfcomponentam_blob-constructor-register","title":"<code>&amp;PerfComponentA::m_weight &amp;PerfComponentA::m_blob Constructor() .Register()))</code>","text":""},{"location":"api/WorldPerfBenchmark_2main_8cpp/#fieldgroup-perfcomponentbm_group-fieldvalue","title":"<code>Field(\"Group\", &amp;PerfComponentB::m_group) .Field(\"Value\"</code>","text":""},{"location":"api/WorldPerfBenchmark_2main_8cpp/#int-main","title":"<code>int main()</code>","text":""},{"location":"api/World_8cpp/","title":"File <code>World.cpp</code>","text":""},{"location":"api/World_8cpp/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> </ul>"},{"location":"api/World_8h/","title":"File <code>World.h</code>","text":""},{"location":"api/World_8h/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI</li> <li>Namespace: SnAPI::GameFramework</li> <li>Type: SnAPI::GameFramework::World</li> </ul>"},{"location":"api/classDemoComponent/","title":"DemoComponent","text":""},{"location":"api/classDemoComponent/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classDemoComponent/#const-char-democomponentktypename","title":"<code>const char* DemoComponent::kTypeName</code>","text":""},{"location":"api/classDemoComponent/#public-members","title":"Public Members","text":""},{"location":"api/classDemoComponent/#int-democomponentm_score","title":"<code>int DemoComponent::m_score</code>","text":""},{"location":"api/classDemoComponent/#stdstring-democomponentm_label","title":"<code>std::string DemoComponent::m_label</code>","text":""},{"location":"api/classDemoComponent/#vec3-democomponentm_tint","title":"<code>Vec3 DemoComponent::m_tint</code>","text":""},{"location":"api/classDemoNode/","title":"DemoNode","text":""},{"location":"api/classDemoNode/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classDemoNode/#const-char-demonodektypename","title":"<code>const char* DemoNode::kTypeName</code>","text":""},{"location":"api/classDemoNode/#public-members","title":"Public Members","text":""},{"location":"api/classDemoNode/#int-demonodem_health","title":"<code>int DemoNode::m_health</code>","text":""},{"location":"api/classDemoNode/#float-demonodem_speed","title":"<code>float DemoNode::m_speed</code>","text":""},{"location":"api/classDemoNode/#stdstring-demonodem_tag","title":"<code>std::string DemoNode::m_tag</code>","text":""},{"location":"api/classDemoNode/#vec3-demonodem_spawn","title":"<code>Vec3 DemoNode::m_spawn</code>","text":""},{"location":"api/classDemoNode/#nodehandle-demonodem_target","title":"<code>NodeHandle DemoNode::m_target</code>","text":""},{"location":"api/classPerfComponentA/","title":"PerfComponentA","text":""},{"location":"api/classPerfComponentA/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classPerfComponentA/#auto-perfcomponentaktypename","title":"<code>auto PerfComponentA::kTypeName</code>","text":""},{"location":"api/classPerfComponentA/#public-members","title":"Public Members","text":""},{"location":"api/classPerfComponentA/#int-perfcomponentam_index","title":"<code>int PerfComponentA::m_index</code>","text":""},{"location":"api/classPerfComponentA/#float-perfcomponentam_weight","title":"<code>float PerfComponentA::m_weight</code>","text":""},{"location":"api/classPerfComponentA/#vec3-perfcomponentam_offset","title":"<code>Vec3 PerfComponentA::m_offset</code>","text":""},{"location":"api/classPerfComponentA/#stdvectoruint8_t-perfcomponentam_blob","title":"<code>std::vector&lt;uint8_t&gt; PerfComponentA::m_blob</code>","text":""},{"location":"api/classPerfComponentB/","title":"PerfComponentB","text":""},{"location":"api/classPerfComponentB/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classPerfComponentB/#auto-perfcomponentbktypename","title":"<code>auto PerfComponentB::kTypeName</code>","text":""},{"location":"api/classPerfComponentB/#public-members","title":"Public Members","text":""},{"location":"api/classPerfComponentB/#int-perfcomponentbm_group","title":"<code>int PerfComponentB::m_group</code>","text":""},{"location":"api/classPerfComponentB/#float-perfcomponentbm_value","title":"<code>float PerfComponentB::m_value</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/","title":"SnAPI::GameFramework::BaseNode","text":"<p>Canonical concrete node implementation used by NodeGraph.</p> <p>Ownership model: - Node storage and lifetime are owned externally by <code>NodeGraph</code>/<code>TObjectPool</code>. - <code>m_ownerGraph</code> and <code>m_world</code> are non-owning pointers updated by graph/world code. - Pointer stability is tied to pool lifetime; handles remain the public identity boundary.</p> <p>Tick model: - Tree traversal is implemented in <code>TickTree</code>/<code>FixedTickTree</code>/<code>LateTickTree</code>. - Actual gameplay behavior lives in overridden hook methods (<code>Tick</code>, <code>FixedTick</code>, <code>LateTick</code>) and attached components.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#const-char-snapigameframeworkbasenodektypename","title":"<code>const char* SnAPI::GameFramework::BaseNode::kTypeName</code>","text":"<p>Stable type name used for reflection.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#nodehandle-snapigameframeworkbasenodem_self","title":"<code>NodeHandle SnAPI::GameFramework::BaseNode::m_self</code>","text":"<p>Stable runtime identity handle for this node.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#nodehandle-snapigameframeworkbasenodem_parent","title":"<code>NodeHandle SnAPI::GameFramework::BaseNode::m_parent</code>","text":"<p>Parent identity; null indicates this node is a root in its graph.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#stdvectornodehandle-snapigameframeworkbasenodem_children","title":"<code>std::vector&lt;NodeHandle&gt; SnAPI::GameFramework::BaseNode::m_children</code>","text":"<p>Ordered child identity list used for deterministic traversal.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#stdstring-snapigameframeworkbasenodem_name","title":"<code>std::string SnAPI::GameFramework::BaseNode::m_name</code>","text":"<p>Human-readable/debug name (not required to be unique).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodem_active","title":"<code>bool SnAPI::GameFramework::BaseNode::m_active</code>","text":"<p>Local execution gate used by tree traversal.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodem_replicated","title":"<code>bool SnAPI::GameFramework::BaseNode::m_replicated</code>","text":"<p>Runtime replication gate for networking bridges.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#stdvectortypeid-snapigameframeworkbasenodem_componenttypes","title":"<code>std::vector&lt;TypeId&gt; SnAPI::GameFramework::BaseNode::m_componentTypes</code>","text":"<p>Attached component type ids for introspection and fast feature checks.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#stdvectoruint64_t-snapigameframeworkbasenodem_componentmask","title":"<code>std::vector&lt;uint64_t&gt; SnAPI::GameFramework::BaseNode::m_componentMask</code>","text":"<p>Dense bitmask mirror of <code>m_componentTypes</code> for fast <code>Has&lt;T&gt;</code> checks.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#uint32_t-snapigameframeworkbasenodem_maskversion","title":"<code>uint32_t SnAPI::GameFramework::BaseNode::m_maskVersion</code>","text":"<p>Last component-type-registry version this mask was synchronized against.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#nodegraph-snapigameframeworkbasenodem_ownergraph","title":"<code>NodeGraph* SnAPI::GameFramework::BaseNode::m_ownerGraph</code>","text":"<p>Non-owning pointer to the graph that stores and ticks this node.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#iworld-snapigameframeworkbasenodem_world","title":"<code>IWorld* SnAPI::GameFramework::BaseNode::m_world</code>","text":"<p>Non-owning pointer to world context for subsystem access and role queries.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#typeid-snapigameframeworkbasenodem_typeid","title":"<code>TypeId SnAPI::GameFramework::BaseNode::m_typeId</code>","text":"<p>Reflected type identity used by serialization/rpc/replication metadata lookups.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#snapigameframeworkbasenodebasenode","title":"<code>SnAPI::GameFramework::BaseNode::BaseNode()</code>","text":"<p>Construct a node with default name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#snapigameframeworkbasenodebasenodestdstring-inname","title":"<code>SnAPI::GameFramework::BaseNode::BaseNode(std::string InName)</code>","text":"<p>Construct a node with a custom name.</p> <p>Parameters</p> <ul> <li><code>InName</code>: Node name.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#const-stdstring-snapigameframeworkbasenodename-const-override","title":"<code>const std::string &amp; SnAPI::GameFramework::BaseNode::Name() const override</code>","text":"<p>Get the node name.</p> <p>Returns: Name string.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodenamestdstring-name-override","title":"<code>void SnAPI::GameFramework::BaseNode::Name(std::string Name) override</code>","text":"<p>Set the node name.</p> <p>Parameters</p> <ul> <li><code>Name</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#nodehandle-snapigameframeworkbasenodehandle-const-override","title":"<code>NodeHandle SnAPI::GameFramework::BaseNode::Handle() const override</code>","text":"<p>Get the node handle.</p> <p>Returns: NodeHandle for this node.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodehandlenodehandle-handle-override","title":"<code>void SnAPI::GameFramework::BaseNode::Handle(NodeHandle Handle) override</code>","text":"<p>Set the node handle.</p> <p>Parameters</p> <ul> <li><code>Handle</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#const-uuid-snapigameframeworkbasenodeid-const-override","title":"<code>const Uuid &amp; SnAPI::GameFramework::BaseNode::Id() const override</code>","text":"<p>Get the node UUID.</p> <p>Returns: UUID value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodeiduuid-id-override","title":"<code>void SnAPI::GameFramework::BaseNode::Id(Uuid Id) override</code>","text":"<p>Set the node UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#const-typeid-snapigameframeworkbasenodetypekey-const-override","title":"<code>const TypeId &amp; SnAPI::GameFramework::BaseNode::TypeKey() const override</code>","text":"<p>Get the reflected type id for this node.</p> <p>Returns: TypeId value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodetypekeyconst-typeid-id-override","title":"<code>void SnAPI::GameFramework::BaseNode::TypeKey(const TypeId &amp;Id) override</code>","text":"<p>Set the reflected type id for this node.</p> <p>Parameters</p> <ul> <li><code>Id</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#nodehandle-snapigameframeworkbasenodeparent-const-override","title":"<code>NodeHandle SnAPI::GameFramework::BaseNode::Parent() const override</code>","text":"<p>Get the parent node handle.</p> <p>Returns: Parent handle or null handle if root.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodeparentnodehandle-parent-override","title":"<code>void SnAPI::GameFramework::BaseNode::Parent(NodeHandle Parent) override</code>","text":"<p>Set the parent node handle.</p> <p>Parameters</p> <ul> <li><code>Parent</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#const-stdvector-nodehandle-snapigameframeworkbasenodechildren-const-override","title":"<code>const std::vector&lt; NodeHandle &gt; &amp; SnAPI::GameFramework::BaseNode::Children() const override</code>","text":"<p>Get the list of child handles.</p> <p>Returns: Vector of child handles.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodeaddchildnodehandle-child-override","title":"<code>void SnAPI::GameFramework::BaseNode::AddChild(NodeHandle Child) override</code>","text":"<p>Add a child handle to the node.</p> <p>Parameters</p> <ul> <li><code>Child</code>: Child handle.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenoderemovechildnodehandle-child-override","title":"<code>void SnAPI::GameFramework::BaseNode::RemoveChild(NodeHandle Child) override</code>","text":"<p>Remove a child handle from the node.</p> <p>Parameters</p> <ul> <li><code>Child</code>: Child handle to remove.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodeactive-const-override","title":"<code>bool SnAPI::GameFramework::BaseNode::Active() const override</code>","text":"<p>Check if the node is active.</p> <p>Returns: True if active.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodeactivebool-active-override","title":"<code>void SnAPI::GameFramework::BaseNode::Active(bool Active) override</code>","text":"<p>Set the active state for the node.</p> <p>Parameters</p> <ul> <li><code>Active</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodereplicated-const-override","title":"<code>bool SnAPI::GameFramework::BaseNode::Replicated() const override</code>","text":"<p>Check if the node is replicated over the network.</p> <p>Returns: True if replicated.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodereplicatedbool-replicated-override","title":"<code>void SnAPI::GameFramework::BaseNode::Replicated(bool Replicated) override</code>","text":"<p>Set whether the node is replicated over the network.</p> <p>Parameters</p> <ul> <li><code>Replicated</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodeisserver-const-override","title":"<code>bool SnAPI::GameFramework::BaseNode::IsServer() const override</code>","text":"<p>True when this node executes with server authority.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodeisclient-const-override","title":"<code>bool SnAPI::GameFramework::BaseNode::IsClient() const override</code>","text":"<p>True when this node executes in client context.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodeislistenserver-const-override","title":"<code>bool SnAPI::GameFramework::BaseNode::IsListenServer() const override</code>","text":"<p>True when this node executes as listen-server.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#stdvector-typeid-snapigameframeworkbasenodecomponenttypes-override","title":"<code>std::vector&lt; TypeId &gt; &amp; SnAPI::GameFramework::BaseNode::ComponentTypes() override</code>","text":"<p>Access the list of component type ids.</p> <p>Returns: Mutable reference to the type id list.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#const-stdvector-typeid-snapigameframeworkbasenodecomponenttypes-const-override","title":"<code>const std::vector&lt; TypeId &gt; &amp; SnAPI::GameFramework::BaseNode::ComponentTypes() const override</code>","text":"<p>Access the list of component type ids (const).</p> <p>Returns: Const reference to the type id list.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#stdvector-uint64_t-snapigameframeworkbasenodecomponentmask-override","title":"<code>std::vector&lt; uint64_t &gt; &amp; SnAPI::GameFramework::BaseNode::ComponentMask() override</code>","text":"<p>Access the component bitmask storage.</p> <p>Returns: Mutable reference to the component mask.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#const-stdvector-uint64_t-snapigameframeworkbasenodecomponentmask-const-override","title":"<code>const std::vector&lt; uint64_t &gt; &amp; SnAPI::GameFramework::BaseNode::ComponentMask() const override</code>","text":"<p>Access the component bitmask storage (const).</p> <p>Returns: Const reference to the component mask.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#uint32_t-snapigameframeworkbasenodemaskversion-const-override","title":"<code>uint32_t SnAPI::GameFramework::BaseNode::MaskVersion() const override</code>","text":"<p>Get the component mask version.</p> <p>Returns: Version id.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodemaskversionuint32_t-version-override","title":"<code>void SnAPI::GameFramework::BaseNode::MaskVersion(uint32_t Version) override</code>","text":"<p>Set the component mask version.</p> <p>Parameters</p> <ul> <li><code>Version</code>: New version id.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#nodegraph-snapigameframeworkbasenodeownergraph-const-override","title":"<code>NodeGraph * SnAPI::GameFramework::BaseNode::OwnerGraph() const override</code>","text":"<p>Get the owning graph.</p> <p>Returns: Pointer to owner graph or nullptr if unowned.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodeownergraphnodegraph-graph-override","title":"<code>void SnAPI::GameFramework::BaseNode::OwnerGraph(NodeGraph *Graph) override</code>","text":"<p>Set the owning graph.</p> <p>Parameters</p> <ul> <li><code>Graph</code>: Owner graph pointer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#iworld-snapigameframeworkbasenodeworld-const-override","title":"<code>IWorld * SnAPI::GameFramework::BaseNode::World() const override</code>","text":"<p>Get the owning world for this node.</p> <p>Returns: Pointer to the world interface or nullptr if unowned.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodeworldiworld-inworld-override","title":"<code>void SnAPI::GameFramework::BaseNode::World(IWorld *InWorld) override</code>","text":"<p>Set the owning world for this node.</p> <p>Parameters</p> <ul> <li><code>InWorld</code>: World interface pointer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#texpectedref-t-snapigameframeworkbasenodeaddargs-args","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::BaseNode::Add(Args &amp;&amp;... args)</code>","text":"<p>Add a component of type T to this node.</p> <p>Parameters</p> <ul> <li><code>args</code>: Constructor arguments.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#texpectedref-t-snapigameframeworkbasenodecomponent","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::BaseNode::Component()</code>","text":"<p>Get a component of type T from this node.</p> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#bool-snapigameframeworkbasenodehas-const","title":"<code>bool SnAPI::GameFramework::BaseNode::Has() const</code>","text":"<p>Check if a component of type T exists on this node.</p> <p>Returns: True if present.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenoderemove","title":"<code>void SnAPI::GameFramework::BaseNode::Remove()</code>","text":"<p>Remove a component of type T from this node.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodeticktreefloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::BaseNode::TickTree(float DeltaSeconds) override</code>","text":"<p>Tick this node and its subtree.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodefixedticktreefloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::BaseNode::FixedTickTree(float DeltaSeconds) override</code>","text":"<p>Fixed-step tick for this node and its subtree.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1BaseNode/#void-snapigameframeworkbasenodelateticktreefloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::BaseNode::LateTickTree(float DeltaSeconds) override</code>","text":"<p>Late tick for this node and its subtree.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/","title":"SnAPI::GameFramework::ComponentSerializationRegistry","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::ComponentSerializationRegistry::Entry</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#public-types","title":"Public Types","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#using-snapigameframeworkcomponentserializationregistrycreatefn-stdfunctiontexpectedvoidnodegraph-graph-nodehandle-owner","title":"<code>using SnAPI::GameFramework::ComponentSerializationRegistry::CreateFn = std::function&lt;TExpected&lt;void*&gt;(NodeGraph&amp; Graph, NodeHandle Owner)&gt;</code>","text":"<p>Callback to create a component on a graph.</p> <p>Returns: Pointer to created component (type-erased).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#using-snapigameframeworkcomponentserializationregistrycreatewithidfn-stdfunctiontexpectedvoidnodegraph-graph-nodehandle-owner-const-uuid-id","title":"<code>using SnAPI::GameFramework::ComponentSerializationRegistry::CreateWithIdFn = std::function&lt;TExpected&lt;void*&gt;(NodeGraph&amp; Graph, NodeHandle Owner, const Uuid&amp; Id)&gt;</code>","text":"<p>Callback to create a component with explicit UUID.</p> <p>Returns: Pointer to created component (type-erased).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#using-snapigameframeworkcomponentserializationregistryserializefn-stdfunctiontexpectedvoidconst-void-instance-cerealbinaryoutputarchive-archive-const-tserializationcontext-context","title":"<code>using SnAPI::GameFramework::ComponentSerializationRegistry::SerializeFn = std::function&lt;TExpected&lt;void&gt;(const void* Instance, cereal::BinaryOutputArchive&amp; Archive, const TSerializationContext&amp; Context)&gt;</code>","text":"<p>Callback to serialize a component instance.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#using-snapigameframeworkcomponentserializationregistrydeserializefn-stdfunctiontexpectedvoidvoid-instance-cerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>using SnAPI::GameFramework::ComponentSerializationRegistry::DeserializeFn = std::function&lt;TExpected&lt;void&gt;(void* Instance, cereal::BinaryInputArchive&amp; Archive, const TSerializationContext&amp; Context)&gt;</code>","text":"<p>Callback to deserialize a component instance.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#friends","title":"Friends","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#friend-class-nodegraphserializer","title":"<code>friend class NodeGraphSerializer</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#stdmutex-snapigameframeworkcomponentserializationregistrym_mutex","title":"<code>std::mutex SnAPI::GameFramework::ComponentSerializationRegistry::m_mutex</code>","text":"<p>Guards component serializer registry map updates/lookups.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#stdunordered_maptypeid-entry-uuidhash-snapigameframeworkcomponentserializationregistrym_entries","title":"<code>std::unordered_map&lt;TypeId, Entry, UuidHash&gt; SnAPI::GameFramework::ComponentSerializationRegistry::m_entries</code>","text":"<p>Registry map by TypeId.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#componentserializationregistry-snapigameframeworkcomponentserializationregistryinstance","title":"<code>ComponentSerializationRegistry &amp; SnAPI::GameFramework::ComponentSerializationRegistry::Instance()</code>","text":"<p>Access the singleton registry.</p> <p>Returns: Registry instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#void-snapigameframeworkcomponentserializationregistryregister","title":"<code>void SnAPI::GameFramework::ComponentSerializationRegistry::Register()</code>","text":"<p>Register a component type using reflection serialization.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#void-snapigameframeworkcomponentserializationregistryregistercustomserializefn-serialize-deserializefn-deserialize","title":"<code>void SnAPI::GameFramework::ComponentSerializationRegistry::RegisterCustom(SerializeFn Serialize, DeserializeFn Deserialize)</code>","text":"<p>Register a component type with custom serialization.</p> <p>Parameters</p> <ul> <li><code>Serialize</code>: </li> <li><code>Deserialize</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#bool-snapigameframeworkcomponentserializationregistryhasconst-typeid-type-const","title":"<code>bool SnAPI::GameFramework::ComponentSerializationRegistry::Has(const TypeId &amp;Type) const</code>","text":"<p>Check if a component type is registered.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Component TypeId.</li> </ul> <p>Returns: True if registered.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#texpected-void-snapigameframeworkcomponentserializationregistrycreatenodegraph-graph-nodehandle-owner-const-typeid-type-const","title":"<code>TExpected&lt; void * &gt; SnAPI::GameFramework::ComponentSerializationRegistry::Create(NodeGraph &amp;Graph, NodeHandle Owner, const TypeId &amp;Type) const</code>","text":"<p>Create a component by type id.</p> <p>Parameters</p> <ul> <li><code>Graph</code>: Owning graph.</li> <li><code>Owner</code>: Owner node handle.</li> <li><code>Type</code>: Component TypeId.</li> </ul> <p>Returns: Pointer to created component or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#texpected-void-snapigameframeworkcomponentserializationregistrycreatewithidnodegraph-graph-nodehandle-owner-const-typeid-type-const-uuid-id-const","title":"<code>TExpected&lt; void * &gt; SnAPI::GameFramework::ComponentSerializationRegistry::CreateWithId(NodeGraph &amp;Graph, NodeHandle Owner, const TypeId &amp;Type, const Uuid &amp;Id) const</code>","text":"<p>Create a component by type id with explicit UUID.</p> <p>Parameters</p> <ul> <li><code>Graph</code>: Owning graph.</li> <li><code>Owner</code>: Owner node handle.</li> <li><code>Type</code>: Component TypeId.</li> <li><code>Id</code>: Component UUID.</li> </ul> <p>Returns: Pointer to created component or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#texpected-void-snapigameframeworkcomponentserializationregistryserializeconst-typeid-type-const-void-instance-stdvector-uint8_t-outbytes-const-tserializationcontext-context-const","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ComponentSerializationRegistry::Serialize(const TypeId &amp;Type, const void *Instance, std::vector&lt; uint8_t &gt; &amp;OutBytes, const TSerializationContext &amp;Context) const</code>","text":"<p>Serialize a component instance to bytes.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Component TypeId.</li> <li><code>Instance</code>: </li> <li><code>OutBytes</code>: Output byte vector.</li> <li><code>Context</code>: Serialization context.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#texpected-void-snapigameframeworkcomponentserializationregistrydeserializeconst-typeid-type-void-instance-const-uint8_t-bytes-size_t-size-const-tserializationcontext-context-const","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ComponentSerializationRegistry::Deserialize(const TypeId &amp;Type, void *Instance, const uint8_t *Bytes, size_t Size, const TSerializationContext &amp;Context) const</code>","text":"<p>Deserialize a component instance from bytes.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Component TypeId.</li> <li><code>Instance</code>: </li> <li><code>Bytes</code>: Serialized bytes.</li> <li><code>Size</code>: Byte count.</li> <li><code>Context</code>: Serialization context.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#private-static-func","title":"Private Static Func","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#texpected-void-snapigameframeworkcomponentserializationregistryserializebyreflectionconst-typeid-type-const-void-instance-cerealbinaryoutputarchive-archive-const-tserializationcontext-context","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ComponentSerializationRegistry::SerializeByReflection(const TypeId &amp;Type, const void *Instance, cereal::BinaryOutputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Reflection-based serialization for a component instance.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Component TypeId.</li> <li><code>Instance</code>: </li> <li><code>Archive</code>: Output archive.</li> <li><code>Context</code>: Serialization context.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry/#texpected-void-snapigameframeworkcomponentserializationregistrydeserializebyreflectionconst-typeid-type-void-instance-cerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ComponentSerializationRegistry::DeserializeByReflection(const TypeId &amp;Type, void *Instance, cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Reflection-based deserialization for a component instance.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Component TypeId.</li> <li><code>Instance</code>: </li> <li><code>Archive</code>: Input archive.</li> <li><code>Context</code>: Serialization context.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/","title":"SnAPI::GameFramework::ComponentTypeRegistry","text":"<p>Global registry for component type indices and masks.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#private-static-attrib","title":"Private Static Attrib","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#stdmutex-snapigameframeworkcomponenttyperegistrym_mutex","title":"<code>std::mutex SnAPI::GameFramework::ComponentTypeRegistry::m_mutex</code>","text":"<p>Protects registry state.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#stdunordered_maptypeid-uint32_t-uuidhash-snapigameframeworkcomponenttyperegistrym_typetoindex","title":"<code>std::unordered_map&lt;TypeId, uint32_t, UuidHash&gt; SnAPI::GameFramework::ComponentTypeRegistry::m_typeToIndex</code>","text":"<p>TypeId -&gt; bit index.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#uint32_t-snapigameframeworkcomponenttyperegistrym_version","title":"<code>uint32_t SnAPI::GameFramework::ComponentTypeRegistry::m_version</code>","text":"<p>Version counter.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#static-uint32_t-snapigameframeworkcomponenttyperegistrytypeindexconst-typeid-id","title":"<code>static uint32_t SnAPI::GameFramework::ComponentTypeRegistry::TypeIndex(const TypeId &amp;Id)</code>","text":"<p>Get or assign a bit index for a component type.</p> <p>Parameters</p> <ul> <li><code>Id</code>: Component type id.</li> </ul> <p>Returns: Bit index for the type.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#static-uint32_t-snapigameframeworkcomponenttyperegistryversion","title":"<code>static uint32_t SnAPI::GameFramework::ComponentTypeRegistry::Version()</code>","text":"<p>Get the current registry version.</p> <p>Returns: Version counter.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ComponentTypeRegistry/#static-size_t-snapigameframeworkcomponenttyperegistrywordcount","title":"<code>static size_t SnAPI::GameFramework::ComponentTypeRegistry::WordCount()</code>","text":"<p>Get the number of 64-bit words required for the mask.</p> <p>Returns: Word count for the current type set.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/","title":"SnAPI::GameFramework::GameRuntime","text":"<p>World runtime host that centralizes bootstrap and per-frame orchestration.</p> <p>Ownership: - owns <code>World</code> - world-owned <code>NetworkSystem</code> owns networking resources when enabled</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#gameruntimesettings-snapigameframeworkgameruntimem_settings","title":"<code>GameRuntimeSettings SnAPI::GameFramework::GameRuntime::m_settings</code>","text":"<p>Last initialization settings snapshot.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#stdunique_ptrclass-world-snapigameframeworkgameruntimem_world","title":"<code>std::unique_ptr&lt;class World&gt; SnAPI::GameFramework::GameRuntime::m_world</code>","text":"<p>Owned runtime world instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#float-snapigameframeworkgameruntimem_fixedaccumulator","title":"<code>float SnAPI::GameFramework::GameRuntime::m_fixedAccumulator</code>","text":"<p>Accumulated fixed-step time.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#result-snapigameframeworkgameruntimeinitconst-gameruntimesettings-settings","title":"<code>Result SnAPI::GameFramework::GameRuntime::Init(const GameRuntimeSettings &amp;Settings)</code>","text":"<p>Initialize runtime from settings.</p> <p>Parameters</p> <ul> <li><code>Settings</code>: </li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#void-snapigameframeworkgameruntimeshutdown","title":"<code>void SnAPI::GameFramework::GameRuntime::Shutdown()</code>","text":"<p>Shutdown runtime and release world/network resources.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#bool-snapigameframeworkgameruntimeisinitialized-const","title":"<code>bool SnAPI::GameFramework::GameRuntime::IsInitialized() const</code>","text":"<p>Check if runtime currently owns a valid world.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#void-snapigameframeworkgameruntimeupdatefloat-deltaseconds","title":"<code>void SnAPI::GameFramework::GameRuntime::Update(float DeltaSeconds)</code>","text":"<p>Run one application frame.</p> <p>Network session pumping is handled by <code>World</code> lifecycle (<code>Tick</code> / <code>EndFrame</code>), not by <code>GameRuntime</code>.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Frame delta time.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#world-snapigameframeworkgameruntimeworldptr","title":"<code>World * SnAPI::GameFramework::GameRuntime::WorldPtr()</code>","text":"<p>Get mutable world pointer.</p> <p>Returns: World pointer or nullptr when not initialized.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#const-world-snapigameframeworkgameruntimeworldptr-const","title":"<code>const World * SnAPI::GameFramework::GameRuntime::WorldPtr() const</code>","text":"<p>Get const world pointer.</p> <p>Returns: World pointer or nullptr when not initialized.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#world-snapigameframeworkgameruntimeworld","title":"<code>World &amp; SnAPI::GameFramework::GameRuntime::World()</code>","text":"<p>Get mutable world reference.</p> <p>Returns: World reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#const-world-snapigameframeworkgameruntimeworld-const","title":"<code>const World &amp; SnAPI::GameFramework::GameRuntime::World() const</code>","text":"<p>Get const world reference.</p> <p>Returns: World reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#const-gameruntimesettings-snapigameframeworkgameruntimesettings-const","title":"<code>const GameRuntimeSettings &amp; SnAPI::GameFramework::GameRuntime::Settings() const</code>","text":"<p>Access current runtime settings snapshot.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#private-static-func","title":"Private Static Func","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1GameRuntime/#void-snapigameframeworkgameruntimeensurebuiltintypesregistered","title":"<code>void SnAPI::GameFramework::GameRuntime::EnsureBuiltinTypesRegistered()</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/","title":"SnAPI::GameFramework::IComponent","text":"<p>Runtime contract for attachable node behavior/data units.</p> <p>Ownership and lifetime: - Stored/owned by typed component storages (<code>TComponentStorage&lt;T&gt;</code>). - Addressable by UUID (<code>ComponentHandle</code>) through <code>ObjectRegistry</code>. - Destruction is deferred to end-of-frame to keep handles stable within a frame.</p> <p>Execution context: - <code>OwnerNode()</code> and <code>World()</code> are resolved dynamically through handle/graph links. - Role helpers (<code>IsServer</code>/<code>IsClient</code>/<code>IsListenServer</code>) proxy world networking state.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#nodehandle-snapigameframeworkicomponentm_owner","title":"<code>NodeHandle SnAPI::GameFramework::IComponent::m_owner</code>","text":"<p>Owning node identity; resolved via ObjectRegistry when needed.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#uuid-snapigameframeworkicomponentm_id","title":"<code>Uuid SnAPI::GameFramework::IComponent::m_id</code>","text":"<p>Stable component identity used for handles/replication/serialization.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#typeid-snapigameframeworkicomponentm_typeid","title":"<code>TypeId SnAPI::GameFramework::IComponent::m_typeId</code>","text":"<p>Reflected concrete component type id used by RPC/serialization paths.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentm_active","title":"<code>bool SnAPI::GameFramework::IComponent::m_active</code>","text":"<p>Runtime tick gate for this component instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentm_replicated","title":"<code>bool SnAPI::GameFramework::IComponent::m_replicated</code>","text":"<p>Runtime replication gate for this component instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#virtual-snapigameframeworkicomponenticomponentdefault","title":"<code>virtual SnAPI::GameFramework::IComponent::~IComponent()=default</code>","text":"<p>Virtual destructor for interface.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#virtual-void-snapigameframeworkicomponentoncreate","title":"<code>virtual void SnAPI::GameFramework::IComponent::OnCreate()</code>","text":"<p>Called immediately after component creation.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#virtual-void-snapigameframeworkicomponentondestroy","title":"<code>virtual void SnAPI::GameFramework::IComponent::OnDestroy()</code>","text":"<p>Called just before component destruction.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#virtual-void-snapigameframeworkicomponenttickfloat-deltaseconds","title":"<code>virtual void SnAPI::GameFramework::IComponent::Tick(float DeltaSeconds)</code>","text":"<p>Per-frame update hook.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#virtual-void-snapigameframeworkicomponentfixedtickfloat-deltaseconds","title":"<code>virtual void SnAPI::GameFramework::IComponent::FixedTick(float DeltaSeconds)</code>","text":"<p>Fixed-step update hook.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#virtual-void-snapigameframeworkicomponentlatetickfloat-deltaseconds","title":"<code>virtual void SnAPI::GameFramework::IComponent::LateTick(float DeltaSeconds)</code>","text":"<p>Late update hook.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#void-snapigameframeworkicomponentownernodehandle-inowner","title":"<code>void SnAPI::GameFramework::IComponent::Owner(NodeHandle InOwner)</code>","text":"<p>Set the owning node handle.</p> <p>Parameters</p> <ul> <li><code>InOwner</code>: Owner node handle.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#nodehandle-snapigameframeworkicomponentowner-const","title":"<code>NodeHandle SnAPI::GameFramework::IComponent::Owner() const</code>","text":"<p>Get the owning node handle.</p> <p>Returns: Owner node handle.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentactive-const","title":"<code>bool SnAPI::GameFramework::IComponent::Active() const</code>","text":"<p>Check if this component is active for tick execution.</p> <p>Returns: True when tick hooks are enabled.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#void-snapigameframeworkicomponentactivebool-activevalue","title":"<code>void SnAPI::GameFramework::IComponent::Active(bool ActiveValue)</code>","text":"<p>Set component active state for tick execution.</p> <p>Parameters</p> <ul> <li><code>ActiveValue</code>: New active state.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentreplicated-const","title":"<code>bool SnAPI::GameFramework::IComponent::Replicated() const</code>","text":"<p>Check if the component is replicated over the network.</p> <p>Returns: True if replicated.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#void-snapigameframeworkicomponentreplicatedbool-replicated","title":"<code>void SnAPI::GameFramework::IComponent::Replicated(bool Replicated)</code>","text":"<p>Set whether the component is replicated over the network.</p> <p>Parameters</p> <ul> <li><code>Replicated</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#const-uuid-snapigameframeworkicomponentid-const","title":"<code>const Uuid &amp; SnAPI::GameFramework::IComponent::Id() const</code>","text":"<p>Get the component UUID.</p> <p>Returns: UUID of this component.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#void-snapigameframeworkicomponentiduuid-id","title":"<code>void SnAPI::GameFramework::IComponent::Id(Uuid Id)</code>","text":"<p>Set the component UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#const-typeid-snapigameframeworkicomponenttypekey-const","title":"<code>const TypeId &amp; SnAPI::GameFramework::IComponent::TypeKey() const</code>","text":"<p>Get the reflected type id for this component.</p> <p>Returns: TypeId value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#void-snapigameframeworkicomponenttypekeyconst-typeid-id","title":"<code>void SnAPI::GameFramework::IComponent::TypeKey(const TypeId &amp;Id)</code>","text":"<p>Set the reflected type id for this component.</p> <p>Parameters</p> <ul> <li><code>Id</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#componenthandle-snapigameframeworkicomponenthandle-const","title":"<code>ComponentHandle SnAPI::GameFramework::IComponent::Handle() const</code>","text":"<p>Get a handle for this component.</p> <p>Returns: ComponentHandle wrapping the UUID.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#basenode-snapigameframeworkicomponentownernode-const","title":"<code>BaseNode * SnAPI::GameFramework::IComponent::OwnerNode() const</code>","text":"<p>Resolve the owning node pointer.</p> <p>Returns: Owning BaseNode pointer or nullptr.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#iworld-snapigameframeworkicomponentworld-const","title":"<code>IWorld * SnAPI::GameFramework::IComponent::World() const</code>","text":"<p>Resolve the owning world pointer.</p> <p>Returns: Owning world or nullptr.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentisserver-const","title":"<code>bool SnAPI::GameFramework::IComponent::IsServer() const</code>","text":"<p>Check whether this component executes with server authority.</p> <p>Returns: True when server-authoritative.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentisclient-const","title":"<code>bool SnAPI::GameFramework::IComponent::IsClient() const</code>","text":"<p>Check whether this component executes in a client context.</p> <p>Returns: True when client-side.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentislistenserver-const","title":"<code>bool SnAPI::GameFramework::IComponent::IsListenServer() const</code>","text":"<p>Check whether this component executes as listen-server.</p> <p>Returns: True when both server and client role are active.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentcallrpcstdstring_view-methodname-stdspan-const-variant-args","title":"<code>bool SnAPI::GameFramework::IComponent::CallRPC(std::string_view MethodName, std::span&lt; const Variant &gt; Args={})</code>","text":"<p>Dispatch a reflected RPC method for this component.</p> <p>Parameters</p> <ul> <li><code>MethodName</code>: Reflected method name.</li> <li><code>Args</code>: Variant-packed arguments.</li> </ul> <p>Returns: True when dispatch succeeded (local invoke or queued network call).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponent/#bool-snapigameframeworkicomponentcallrpcstdstring_view-methodname-stdinitializer_list-variant-args","title":"<code>bool SnAPI::GameFramework::IComponent::CallRPC(std::string_view MethodName, std::initializer_list&lt; Variant &gt; Args)</code>","text":"<p>Initializer-list convenience overload for <code>CallRPC</code>.</p> <p>Parameters</p> <ul> <li><code>MethodName</code>: </li> <li><code>Args</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/","title":"SnAPI::GameFramework::IComponentStorage","text":"<p>Type-erased interface for component storage.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-snapigameframeworkicomponentstorageicomponentstoragedefault","title":"<code>virtual SnAPI::GameFramework::IComponentStorage::~IComponentStorage()=default</code>","text":"<p>Virtual destructor.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-typeid-snapigameframeworkicomponentstoragetypekey-const-0","title":"<code>virtual TypeId SnAPI::GameFramework::IComponentStorage::TypeKey() const =0</code>","text":"<p>Get the component type id stored by this storage.</p> <p>Returns: TypeId value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-bool-snapigameframeworkicomponentstoragehasnodehandle-owner-const-0","title":"<code>virtual bool SnAPI::GameFramework::IComponentStorage::Has(NodeHandle Owner) const =0</code>","text":"<p>Check if a node has this component.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul> <p>Returns: True if the component exists.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-void-snapigameframeworkicomponentstorageremovenodehandle-owner0","title":"<code>virtual void SnAPI::GameFramework::IComponentStorage::Remove(NodeHandle Owner)=0</code>","text":"<p>Remove a component from a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-void-snapigameframeworkicomponentstoragetickcomponentnodehandle-owner-float-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::IComponentStorage::TickComponent(NodeHandle Owner, float DeltaSeconds)=0</code>","text":"<p>Tick a component for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-void-snapigameframeworkicomponentstoragefixedtickcomponentnodehandle-owner-float-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::IComponentStorage::FixedTickComponent(NodeHandle Owner, float DeltaSeconds)=0</code>","text":"<p>Fixed-step tick a component for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-void-snapigameframeworkicomponentstoragelatetickcomponentnodehandle-owner-float-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::IComponentStorage::LateTickComponent(NodeHandle Owner, float DeltaSeconds)=0</code>","text":"<p>Late tick a component for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-void-snapigameframeworkicomponentstorageborrowednodehandle-owner0","title":"<code>virtual void * SnAPI::GameFramework::IComponentStorage::Borrowed(NodeHandle Owner)=0</code>","text":"<p>Borrow a component instance (mutable).</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul> <p>Returns: Pointer to component or nullptr.</p> <p>Notes</p> <ul> <li>Borrowed pointers must not be cached.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-const-void-snapigameframeworkicomponentstorageborrowednodehandle-owner-const-0","title":"<code>virtual const void * SnAPI::GameFramework::IComponentStorage::Borrowed(NodeHandle Owner) const =0</code>","text":"<p>Borrow a component instance (const).</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul> <p>Returns: Pointer to component or nullptr.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-void-snapigameframeworkicomponentstorageendframe0","title":"<code>virtual void SnAPI::GameFramework::IComponentStorage::EndFrame()=0</code>","text":"<p>Process pending destruction at end-of-frame.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IComponentStorage/#virtual-void-snapigameframeworkicomponentstorageclear0","title":"<code>virtual void SnAPI::GameFramework::IComponentStorage::Clear()=0</code>","text":"<p>Clear all components immediately.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/","title":"SnAPI::GameFramework::ILevel","text":"<p>Contract for world-owned level containers.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#virtual-snapigameframeworkilevelileveldefault","title":"<code>virtual SnAPI::GameFramework::ILevel::~ILevel()=default</code>","text":"<p>Virtual destructor.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#virtual-void-snapigameframeworkileveltickfloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::ILevel::Tick(float DeltaSeconds)=0</code>","text":"<p>Per-frame tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#virtual-void-snapigameframeworkilevelfixedtickfloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::ILevel::FixedTick(float DeltaSeconds)=0</code>","text":"<p>Fixed-step tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#virtual-void-snapigameframeworkilevellatetickfloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::ILevel::LateTick(float DeltaSeconds)=0</code>","text":"<p>Late tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#virtual-void-snapigameframeworkilevelendframe0","title":"<code>virtual void SnAPI::GameFramework::ILevel::EndFrame()=0</code>","text":"<p>End-of-frame processing.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#virtual-texpected-nodehandle-snapigameframeworkilevelcreategraphstdstring-name0","title":"<code>virtual TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::ILevel::CreateGraph(std::string Name)=0</code>","text":"<p>Create a child node graph.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Graph name.</li> </ul> <p>Returns: Handle to the created graph or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ILevel/#virtual-texpectedref-nodegraph-snapigameframeworkilevelgraphnodehandle-handle0","title":"<code>virtual TExpectedRef&lt; NodeGraph &gt; SnAPI::GameFramework::ILevel::Graph(NodeHandle Handle)=0</code>","text":"<p>Access a child graph by handle.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: Graph handle.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/","title":"SnAPI::GameFramework::INode","text":"<p>Abstract runtime contract for graph nodes.</p> <p>Semantics: - A node is identity-first (<code>Handle</code> / <code>Id</code>) and hierarchy-aware (<code>Parent</code> / <code>Children</code>). - Runtime ownership is external: <code>NodeGraph</code> controls insertion/removal and lifecycle. - <code>World</code> association is optional for detached/prefab graphs, but world-backed behavior (networking/audio subsystems, authoritative role queries, tick-tree participation) depends on a valid <code>World()</code> pointer.</p> <p>Implementers: - <code>BaseNode</code> is the canonical implementation and should be preferred. - Implementing <code>INode</code> directly is valid but requires preserving all invariants described on each accessor/mutator below.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-snapigameframeworkinodeinodedefault","title":"<code>virtual SnAPI::GameFramework::INode::~INode()=default</code>","text":"<p>Virtual destructor for interface.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodetickfloat-deltaseconds","title":"<code>virtual void SnAPI::GameFramework::INode::Tick(float DeltaSeconds)</code>","text":"<p>Per-frame update hook.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodefixedtickfloat-deltaseconds","title":"<code>virtual void SnAPI::GameFramework::INode::FixedTick(float DeltaSeconds)</code>","text":"<p>Fixed-step update hook.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodelatetickfloat-deltaseconds","title":"<code>virtual void SnAPI::GameFramework::INode::LateTick(float DeltaSeconds)</code>","text":"<p>Late update hook.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-const-stdstring-snapigameframeworkinodename-const-0","title":"<code>virtual const std::string &amp; SnAPI::GameFramework::INode::Name() const =0</code>","text":"<p>Get the display name of the node.</p> <p>Returns: Node name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodenamestdstring-name0","title":"<code>virtual void SnAPI::GameFramework::INode::Name(std::string Name)=0</code>","text":"<p>Set the display name of the node.</p> <p>Parameters</p> <ul> <li><code>Name</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-nodehandle-snapigameframeworkinodehandle-const-0","title":"<code>virtual NodeHandle SnAPI::GameFramework::INode::Handle() const =0</code>","text":"<p>Get the handle for this node.</p> <p>Returns: Node handle.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodehandlenodehandle-handle0","title":"<code>virtual void SnAPI::GameFramework::INode::Handle(NodeHandle Handle)=0</code>","text":"<p>Set the node handle.</p> <p>Parameters</p> <ul> <li><code>Handle</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-const-uuid-snapigameframeworkinodeid-const-0","title":"<code>virtual const Uuid &amp; SnAPI::GameFramework::INode::Id() const =0</code>","text":"<p>Get the node UUID.</p> <p>Returns: UUID value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodeiduuid-id0","title":"<code>virtual void SnAPI::GameFramework::INode::Id(Uuid Id)=0</code>","text":"<p>Set the node UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-const-typeid-snapigameframeworkinodetypekey-const-0","title":"<code>virtual const TypeId &amp; SnAPI::GameFramework::INode::TypeKey() const =0</code>","text":"<p>Get the reflected type id for this node.</p> <p>Returns: TypeId value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodetypekeyconst-typeid-id0","title":"<code>virtual void SnAPI::GameFramework::INode::TypeKey(const TypeId &amp;Id)=0</code>","text":"<p>Set the reflected type id for this node.</p> <p>Parameters</p> <ul> <li><code>Id</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-nodehandle-snapigameframeworkinodeparent-const-0","title":"<code>virtual NodeHandle SnAPI::GameFramework::INode::Parent() const =0</code>","text":"<p>Get the parent node handle.</p> <p>Returns: Parent handle or null handle if root.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodeparentnodehandle-parent0","title":"<code>virtual void SnAPI::GameFramework::INode::Parent(NodeHandle Parent)=0</code>","text":"<p>Set the parent node handle.</p> <p>Parameters</p> <ul> <li><code>Parent</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-const-stdvector-nodehandle-snapigameframeworkinodechildren-const-0","title":"<code>virtual const std::vector&lt; NodeHandle &gt; &amp; SnAPI::GameFramework::INode::Children() const =0</code>","text":"<p>Get the list of child handles.</p> <p>Returns: Vector of child handles.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodeaddchildnodehandle-child0","title":"<code>virtual void SnAPI::GameFramework::INode::AddChild(NodeHandle Child)=0</code>","text":"<p>Add a child handle to the node.</p> <p>Parameters</p> <ul> <li><code>Child</code>: Child handle.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinoderemovechildnodehandle-child0","title":"<code>virtual void SnAPI::GameFramework::INode::RemoveChild(NodeHandle Child)=0</code>","text":"<p>Remove a child handle from the node.</p> <p>Parameters</p> <ul> <li><code>Child</code>: Child handle to remove.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-bool-snapigameframeworkinodeactive-const-0","title":"<code>virtual bool SnAPI::GameFramework::INode::Active() const =0</code>","text":"<p>Check if the node is active.</p> <p>Returns: True if active.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodeactivebool-active0","title":"<code>virtual void SnAPI::GameFramework::INode::Active(bool Active)=0</code>","text":"<p>Set the active state for the node.</p> <p>Parameters</p> <ul> <li><code>Active</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-bool-snapigameframeworkinodereplicated-const-0","title":"<code>virtual bool SnAPI::GameFramework::INode::Replicated() const =0</code>","text":"<p>Check if the node is replicated over the network.</p> <p>Returns: True if replicated.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodereplicatedbool-replicated0","title":"<code>virtual void SnAPI::GameFramework::INode::Replicated(bool Replicated)=0</code>","text":"<p>Set whether the node is replicated over the network.</p> <p>Parameters</p> <ul> <li><code>Replicated</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-bool-snapigameframeworkinodeisserver-const-0","title":"<code>virtual bool SnAPI::GameFramework::INode::IsServer() const =0</code>","text":"<p>Check whether this node is executing with server authority.</p> <p>Returns: True when server-authoritative.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-bool-snapigameframeworkinodeisclient-const-0","title":"<code>virtual bool SnAPI::GameFramework::INode::IsClient() const =0</code>","text":"<p>Check whether this node is executing in a client context.</p> <p>Returns: True when client-side.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-bool-snapigameframeworkinodeislistenserver-const-0","title":"<code>virtual bool SnAPI::GameFramework::INode::IsListenServer() const =0</code>","text":"<p>Check whether this node is executing as a listen-server.</p> <p>Returns: True when both server and client role are active.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#bool-snapigameframeworkinodecallrpcstdstring_view-methodname-stdspan-const-variant-args","title":"<code>bool SnAPI::GameFramework::INode::CallRPC(std::string_view MethodName, std::span&lt; const Variant &gt; Args={})</code>","text":"<p>Dispatch a reflected RPC method for this node.</p> <p>Parameters</p> <ul> <li><code>MethodName</code>: Reflected method name.</li> <li><code>Args</code>: Variant-packed arguments.</li> </ul> <p>Returns: True when dispatch succeeded (local invoke or queued network call).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#bool-snapigameframeworkinodecallrpcstdstring_view-methodname-stdinitializer_list-variant-args","title":"<code>bool SnAPI::GameFramework::INode::CallRPC(std::string_view MethodName, std::initializer_list&lt; Variant &gt; Args)</code>","text":"<p>Initializer-list convenience overload for <code>CallRPC</code>.</p> <p>Parameters</p> <ul> <li><code>MethodName</code>: </li> <li><code>Args</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-stdvector-typeid-snapigameframeworkinodecomponenttypes0","title":"<code>virtual std::vector&lt; TypeId &gt; &amp; SnAPI::GameFramework::INode::ComponentTypes()=0</code>","text":"<p>Access the list of component type ids.</p> <p>Returns: Mutable reference to the type id list.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-const-stdvector-typeid-snapigameframeworkinodecomponenttypes-const-0","title":"<code>virtual const std::vector&lt; TypeId &gt; &amp; SnAPI::GameFramework::INode::ComponentTypes() const =0</code>","text":"<p>Access the list of component type ids (const).</p> <p>Returns: Const reference to the type id list.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-stdvector-uint64_t-snapigameframeworkinodecomponentmask0","title":"<code>virtual std::vector&lt; uint64_t &gt; &amp; SnAPI::GameFramework::INode::ComponentMask()=0</code>","text":"<p>Access the component bitmask storage.</p> <p>Returns: Mutable reference to the component mask.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-const-stdvector-uint64_t-snapigameframeworkinodecomponentmask-const-0","title":"<code>virtual const std::vector&lt; uint64_t &gt; &amp; SnAPI::GameFramework::INode::ComponentMask() const =0</code>","text":"<p>Access the component bitmask storage (const).</p> <p>Returns: Const reference to the component mask.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-uint32_t-snapigameframeworkinodemaskversion-const-0","title":"<code>virtual uint32_t SnAPI::GameFramework::INode::MaskVersion() const =0</code>","text":"<p>Get the component mask version.</p> <p>Returns: Version id.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodemaskversionuint32_t-version0","title":"<code>virtual void SnAPI::GameFramework::INode::MaskVersion(uint32_t Version)=0</code>","text":"<p>Set the component mask version.</p> <p>Parameters</p> <ul> <li><code>Version</code>: New version id.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-nodegraph-snapigameframeworkinodeownergraph-const-0","title":"<code>virtual NodeGraph * SnAPI::GameFramework::INode::OwnerGraph() const =0</code>","text":"<p>Get the owning graph.</p> <p>Returns: Pointer to owner graph or nullptr if unowned.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodeownergraphnodegraph-graph0","title":"<code>virtual void SnAPI::GameFramework::INode::OwnerGraph(NodeGraph *Graph)=0</code>","text":"<p>Set the owning graph.</p> <p>Parameters</p> <ul> <li><code>Graph</code>: Owner graph pointer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-iworld-snapigameframeworkinodeworld-const-0","title":"<code>virtual IWorld * SnAPI::GameFramework::INode::World() const =0</code>","text":"<p>Get the owning world for this node.</p> <p>Returns: Pointer to the world interface or nullptr if unowned.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodeworldiworld-inworld0","title":"<code>virtual void SnAPI::GameFramework::INode::World(IWorld *InWorld)=0</code>","text":"<p>Set the owning world for this node.</p> <p>Parameters</p> <ul> <li><code>InWorld</code>: World interface pointer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodeticktreefloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::INode::TickTree(float DeltaSeconds)=0</code>","text":"<p>Tick this node and its subtree.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodefixedticktreefloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::INode::FixedTickTree(float DeltaSeconds)=0</code>","text":"<p>Fixed-step tick for this node and its subtree.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1INode/#virtual-void-snapigameframeworkinodelateticktreefloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::INode::LateTickTree(float DeltaSeconds)=0</code>","text":"<p>Late tick for this node and its subtree.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/","title":"SnAPI::GameFramework::IScriptEngine","text":"<p>Interface for a scripting backend (Lua, C#, etc).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-snapigameframeworkiscriptengineiscriptenginedefault","title":"<code>virtual SnAPI::GameFramework::IScriptEngine::~IScriptEngine()=default</code>","text":"<p>Virtual destructor.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-texpected-void-snapigameframeworkiscriptengineinitialize0","title":"<code>virtual TExpected&lt; void &gt; SnAPI::GameFramework::IScriptEngine::Initialize()=0</code>","text":"<p>Initialize the scripting runtime.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-texpected-void-snapigameframeworkiscriptengineshutdown0","title":"<code>virtual TExpected&lt; void &gt; SnAPI::GameFramework::IScriptEngine::Shutdown()=0</code>","text":"<p>Shutdown the scripting runtime.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-texpected-void-snapigameframeworkiscriptengineloadmoduleconst-stdstring-path0","title":"<code>virtual TExpected&lt; void &gt; SnAPI::GameFramework::IScriptEngine::LoadModule(const std::string &amp;Path)=0</code>","text":"<p>Load a script module from disk.</p> <p>Parameters</p> <ul> <li><code>Path</code>: Module path.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-texpected-void-snapigameframeworkiscriptenginereloadmoduleconst-stdstring-path0","title":"<code>virtual TExpected&lt; void &gt; SnAPI::GameFramework::IScriptEngine::ReloadModule(const std::string &amp;Path)=0</code>","text":"<p>Reload a script module from disk.</p> <p>Parameters</p> <ul> <li><code>Path</code>: Module path.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-texpected-scriptinstanceid-snapigameframeworkiscriptenginecreateinstanceconst-stdstring-typename0","title":"<code>virtual TExpected&lt; ScriptInstanceId &gt; SnAPI::GameFramework::IScriptEngine::CreateInstance(const std::string &amp;TypeName)=0</code>","text":"<p>Create a script instance of a type.</p> <p>Parameters</p> <ul> <li><code>TypeName</code>: Fully qualified script type name.</li> </ul> <p>Returns: Script instance id or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-texpected-void-snapigameframeworkiscriptenginedestroyinstancescriptinstanceid-instance0","title":"<code>virtual TExpected&lt; void &gt; SnAPI::GameFramework::IScriptEngine::DestroyInstance(ScriptInstanceId Instance)=0</code>","text":"<p>Destroy a script instance.</p> <p>Parameters</p> <ul> <li><code>Instance</code>: Instance id to destroy.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IScriptEngine/#virtual-texpected-variant-snapigameframeworkiscriptengineinvokescriptinstanceid-instance-stdstring_view-method-stdspan-const-variant-args0","title":"<code>virtual TExpected&lt; Variant &gt; SnAPI::GameFramework::IScriptEngine::Invoke(ScriptInstanceId Instance, std::string_view Method, std::span&lt; const Variant &gt; Args)=0</code>","text":"<p>Invoke a method on a script instance.</p> <p>Parameters</p> <ul> <li><code>Instance</code>: Instance id.</li> <li><code>Method</code>: Method name.</li> <li><code>Args</code>: Argument list.</li> </ul> <p>Returns: Variant result or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/","title":"SnAPI::GameFramework::IWorld","text":"<p>Root runtime container contract for gameplay sessions.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#virtual-snapigameframeworkiworldiworlddefault","title":"<code>virtual SnAPI::GameFramework::IWorld::~IWorld()=default</code>","text":"<p>Virtual destructor.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#virtual-void-snapigameframeworkiworldtickfloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::IWorld::Tick(float DeltaSeconds)=0</code>","text":"<p>Per-frame tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#virtual-void-snapigameframeworkiworldfixedtickfloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::IWorld::FixedTick(float DeltaSeconds)=0</code>","text":"<p>Fixed-step tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#virtual-void-snapigameframeworkiworldlatetickfloat-deltaseconds0","title":"<code>virtual void SnAPI::GameFramework::IWorld::LateTick(float DeltaSeconds)=0</code>","text":"<p>Late tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#virtual-void-snapigameframeworkiworldendframe0","title":"<code>virtual void SnAPI::GameFramework::IWorld::EndFrame()=0</code>","text":"<p>End-of-frame processing.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#virtual-texpected-nodehandle-snapigameframeworkiworldcreatelevelstdstring-name0","title":"<code>virtual TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::IWorld::CreateLevel(std::string Name)=0</code>","text":"<p>Create a level as a child node.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Level name.</li> </ul> <p>Returns: Handle to the created level or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1IWorld/#virtual-texpectedref-level-snapigameframeworkiworldlevelrefnodehandle-handle0","title":"<code>virtual TExpectedRef&lt; Level &gt; SnAPI::GameFramework::IWorld::LevelRef(NodeHandle Handle)=0</code>","text":"<p>Access a level by handle.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: Level handle.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1JobSystem/","title":"SnAPI::GameFramework::JobSystem","text":"<p>Minimal job system facade for internal parallelism.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1JobSystem/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1JobSystem/#uint32_t-snapigameframeworkjobsystemm_workercount","title":"<code>uint32_t SnAPI::GameFramework::JobSystem::m_workerCount</code>","text":"<p>Desired worker count (not yet used).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1JobSystem/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1JobSystem/#void-snapigameframeworkjobsystemworkercountuint32_t-count","title":"<code>void SnAPI::GameFramework::JobSystem::WorkerCount(uint32_t Count)</code>","text":"<p>Set the desired worker count.</p> <p>Parameters</p> <ul> <li><code>Count</code>: Number of worker threads.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1JobSystem/#uint32_t-snapigameframeworkjobsystemworkercount-const","title":"<code>uint32_t SnAPI::GameFramework::JobSystem::WorkerCount() const</code>","text":"<p>Get the configured worker count.</p> <p>Returns: Worker count value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1JobSystem/#void-snapigameframeworkjobsystemparallelforsize_t-count-const-stdfunction-voidsize_t-fn-const","title":"<code>void SnAPI::GameFramework::JobSystem::ParallelFor(size_t Count, const std::function&lt; void(size_t)&gt; &amp;Fn) const</code>","text":"<p>Execute a parallel-for workload.</p> <p>Parameters</p> <ul> <li><code>Count</code>: Number of iterations.</li> <li><code>Fn</code>: Function invoked per index.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/","title":"SnAPI::GameFramework::Level","text":"<p>Concrete level implementation backed by NodeGraph.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#const-char-snapigameframeworklevelktypename","title":"<code>const char* SnAPI::GameFramework::Level::kTypeName</code>","text":"<p>Stable type name for reflection.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#snapigameframeworklevellevel","title":"<code>SnAPI::GameFramework::Level::Level()</code>","text":"<p>Construct a level with default name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#snapigameframeworklevellevelstdstring-name","title":"<code>SnAPI::GameFramework::Level::Level(std::string Name)</code>","text":"<p>Construct a level with a name.</p> <p>Parameters</p> <ul> <li><code>Name</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#void-snapigameframeworkleveltickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::Level::Tick(float DeltaSeconds) override</code>","text":"<p>Per-frame tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#void-snapigameframeworklevelfixedtickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::Level::FixedTick(float DeltaSeconds) override</code>","text":"<p>Fixed-step tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#void-snapigameframeworklevellatetickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::Level::LateTick(float DeltaSeconds) override</code>","text":"<p>Late tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#void-snapigameframeworklevelendframe-override","title":"<code>void SnAPI::GameFramework::Level::EndFrame() override</code>","text":"<p>End-of-frame processing.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#texpected-nodehandle-snapigameframeworklevelcreategraphstdstring-name-override","title":"<code>TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::Level::CreateGraph(std::string Name) override</code>","text":"<p>Create a child node graph in this level.</p> <p>Parameters</p> <ul> <li><code>Name</code>: </li> </ul> <p>Returns: Handle to the created graph or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#texpectedref-nodegraph-snapigameframeworklevelgraphnodehandle-handle-override","title":"<code>TExpectedRef&lt; NodeGraph &gt; SnAPI::GameFramework::Level::Graph(NodeHandle Handle) override</code>","text":"<p>Access a child graph by handle.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: </li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#nodegraph-snapigameframeworklevelrootgraph","title":"<code>NodeGraph &amp; SnAPI::GameFramework::Level::RootGraph()</code>","text":"<p>Access the root graph.</p> <p>Returns: Reference to the root graph.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Level/#const-nodegraph-snapigameframeworklevelrootgraph-const","title":"<code>const NodeGraph &amp; SnAPI::GameFramework::Level::RootGraph() const</code>","text":"<p>Access the root graph (const).</p> <p>Returns: Const reference to the root graph.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1LevelSerializer/","title":"SnAPI::GameFramework::LevelSerializer","text":"<p>Serializer for Level to/from LevelPayload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1LevelSerializer/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1LevelSerializer/#uint32_t-snapigameframeworklevelserializerkschemaversion","title":"<code>uint32_t SnAPI::GameFramework::LevelSerializer::kSchemaVersion</code>","text":"<p>Current schema version for Level payloads.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1LevelSerializer/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1LevelSerializer/#texpected-levelpayload-snapigameframeworklevelserializerserializeconst-level-levelref","title":"<code>TExpected&lt; LevelPayload &gt; SnAPI::GameFramework::LevelSerializer::Serialize(const Level &amp;LevelRef)</code>","text":"<p>Serialize a level to a payload.</p> <p>Parameters</p> <ul> <li><code>LevelRef</code>: Source level.</li> </ul> <p>Returns: Payload or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1LevelSerializer/#texpected-void-snapigameframeworklevelserializerdeserializeconst-levelpayload-payload-level-levelref","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::LevelSerializer::Deserialize(const LevelPayload &amp;Payload, Level &amp;LevelRef)</code>","text":"<p>Deserialize a level from a payload.</p> <p>Parameters</p> <ul> <li><code>Payload</code>: Payload to read.</li> <li><code>LevelRef</code>: Destination level.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/","title":"SnAPI::GameFramework::NodeGraph","text":"<p>Hierarchical runtime container for nodes/components.</p> <p>Core semantics: - Node/component identity is UUID-handle based. - Object lifetime is deferred-destruction by default (<code>DestroyNode</code> + <code>EndFrame</code>). - Component storage is type-partitioned (<code>TypeId -&gt; IComponentStorage</code>) and created lazily. - Graph tick methods evaluate relevance and then drive deterministic tree traversal.</p> <p>This class is the primary runtime backbone for world/level/prefab style object trees.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#const-char-snapigameframeworknodegraphktypename","title":"<code>const char* SnAPI::GameFramework::NodeGraph::kTypeName</code>","text":"<p>Stable type name for reflection.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#friends","title":"Friends","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#friend-class-basenode","title":"<code>friend class BaseNode</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#friend-class-componentserializationregistry","title":"<code>friend class ComponentSerializationRegistry</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#friend-class-nodegraphserializer","title":"<code>friend class NodeGraphSerializer</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#friend-class-netreplicationbridge","title":"<code>friend class NetReplicationBridge</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#stdshared_ptrtobjectpoolbasenode-snapigameframeworknodegraphm_nodepool","title":"<code>std::shared_ptr&lt;TObjectPool&lt;BaseNode&gt; &gt; SnAPI::GameFramework::NodeGraph::m_nodePool</code>","text":"<p>Owning node pool providing stable addresses and deferred destroy semantics.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#stdunordered_maptypeid-stdunique_ptricomponentstorage-uuidhash-snapigameframeworknodegraphm_storages","title":"<code>std::unordered_map&lt;TypeId, std::unique_ptr&lt;IComponentStorage&gt;, UuidHash&gt; SnAPI::GameFramework::NodeGraph::m_storages</code>","text":"<p>Type-partitioned component storages created lazily on demand.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#stdvectornodehandle-snapigameframeworknodegraphm_rootnodes","title":"<code>std::vector&lt;NodeHandle&gt; SnAPI::GameFramework::NodeGraph::m_rootNodes</code>","text":"<p>Root traversal entry points (nodes without parent in this graph).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#stdvectornodehandle-snapigameframeworknodegraphm_pendingdestroy","title":"<code>std::vector&lt;NodeHandle&gt; SnAPI::GameFramework::NodeGraph::m_pendingDestroy</code>","text":"<p>Node handles queued for end-of-frame destruction.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#stdunordered_setuuid-uuidhash-snapigameframeworknodegraphm_pendingdestroyids","title":"<code>std::unordered_set&lt;Uuid, UuidHash&gt; SnAPI::GameFramework::NodeGraph::m_pendingDestroyIds</code>","text":"<p>Fast lookup for nodes already queued for deferred destruction.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#size_t-snapigameframeworknodegraphm_relevancecursor","title":"<code>size_t SnAPI::GameFramework::NodeGraph::m_relevanceCursor</code>","text":"<p>Cursor for incremental relevance sweeps when budgeted evaluation is enabled.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#size_t-snapigameframeworknodegraphm_relevancebudget","title":"<code>size_t SnAPI::GameFramework::NodeGraph::m_relevanceBudget</code>","text":"<p>Per-tick relevance evaluation cap; 0 means evaluate all nodes.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#snapigameframeworknodegraphnodegraphconst-nodegraph-delete","title":"<code>SnAPI::GameFramework::NodeGraph::NodeGraph(const NodeGraph &amp;)=delete</code>","text":"<p>Non-copyable.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#nodegraph-snapigameframeworknodegraphoperatorconst-nodegraph-delete","title":"<code>NodeGraph &amp; SnAPI::GameFramework::NodeGraph::operator=(const NodeGraph &amp;)=delete</code>","text":"<p>Non-copyable.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#snapigameframeworknodegraphnodegraphnodegraph-other-noexcept","title":"<code>SnAPI::GameFramework::NodeGraph::NodeGraph(NodeGraph &amp;&amp;Other) noexcept</code>","text":"<p>Move construct a graph.</p> <p>Parameters</p> <ul> <li><code>Other</code>: Graph to move from.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#nodegraph-snapigameframeworknodegraphoperatornodegraph-other-noexcept","title":"<code>NodeGraph &amp; SnAPI::GameFramework::NodeGraph::operator=(NodeGraph &amp;&amp;Other) noexcept</code>","text":"<p>Move assign a graph.</p> <p>Parameters</p> <ul> <li><code>Other</code>: Graph to move from.</li> </ul> <p>Returns: Reference to this graph.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#snapigameframeworknodegraphnodegraph","title":"<code>SnAPI::GameFramework::NodeGraph::NodeGraph()</code>","text":"<p>Construct an empty graph with default name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#snapigameframeworknodegraphnodegraphstdstring-name","title":"<code>SnAPI::GameFramework::NodeGraph::NodeGraph(std::string Name)</code>","text":"<p>Construct an empty graph with a name.</p> <p>Parameters</p> <ul> <li><code>Name</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#snapigameframeworknodegraphnodegraph-override","title":"<code>SnAPI::GameFramework::NodeGraph::~NodeGraph() override</code>","text":"<p>Destructor.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpected-nodehandle-snapigameframeworknodegraphcreatenodestdstring-name-args-args","title":"<code>TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::NodeGraph::CreateNode(std::string Name, Args &amp;&amp;... args)</code>","text":"<p>Create a node of type T with a generated UUID.</p> <p>Parameters</p> <ul> <li><code>Name</code>: </li> <li><code>args</code>: Constructor arguments for T.</li> </ul> <p>Returns: Handle to the created node or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpected-nodehandle-snapigameframeworknodegraphcreatenodewithidconst-uuid-id-stdstring-name-args-args","title":"<code>TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::NodeGraph::CreateNodeWithId(const Uuid &amp;Id, std::string Name, Args &amp;&amp;... args)</code>","text":"<p>Create a node of type T with an explicit UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>: </li> <li><code>Name</code>: </li> <li><code>args</code>: Constructor arguments for T.</li> </ul> <p>Returns: Handle to the created node or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpected-nodehandle-snapigameframeworknodegraphcreatenodeconst-typeid-type-stdstring-name","title":"<code>TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::NodeGraph::CreateNode(const TypeId &amp;Type, std::string Name)</code>","text":"<p>Create a node by reflected TypeId with a generated UUID.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Reflected type id.</li> <li><code>Name</code>: </li> </ul> <p>Returns: Handle to the created node or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpected-nodehandle-snapigameframeworknodegraphcreatenodeconst-typeid-type-stdstring-name-const-uuid-id","title":"<code>TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::NodeGraph::CreateNode(const TypeId &amp;Type, std::string Name, const Uuid &amp;Id)</code>","text":"<p>Create a node by reflected TypeId with an explicit UUID.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Reflected type id.</li> <li><code>Name</code>: </li> <li><code>Id</code>: </li> </ul> <p>Returns: Handle to the created node or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpected-void-snapigameframeworknodegraphdestroynodenodehandle-handle","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::NodeGraph::DestroyNode(NodeHandle Handle)</code>","text":"<p>Destroy a node at end-of-frame.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: </li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpected-void-snapigameframeworknodegraphattachchildnodehandle-parent-nodehandle-child","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::NodeGraph::AttachChild(NodeHandle Parent, NodeHandle Child)</code>","text":"<p>Attach a child node to a parent.</p> <p>Parameters</p> <ul> <li><code>Parent</code>: </li> <li><code>Child</code>: Child handle.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpected-void-snapigameframeworknodegraphdetachchildnodehandle-child","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::NodeGraph::DetachChild(NodeHandle Child)</code>","text":"<p>Detach a child node from its parent.</p> <p>Parameters</p> <ul> <li><code>Child</code>: Child handle.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphtickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::NodeGraph::Tick(float DeltaSeconds) override</code>","text":"<p>Tick the graph (relevance + node tree).</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphfixedtickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::NodeGraph::FixedTick(float DeltaSeconds) override</code>","text":"<p>Fixed-step tick for the graph.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphlatetickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::NodeGraph::LateTick(float DeltaSeconds) override</code>","text":"<p>Late tick for the graph.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphendframe","title":"<code>void SnAPI::GameFramework::NodeGraph::EndFrame()</code>","text":"<p>Process end-of-frame destruction for nodes/components.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphclear","title":"<code>void SnAPI::GameFramework::NodeGraph::Clear()</code>","text":"<p>Remove all nodes/components immediately.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#tobjectpool-basenode-snapigameframeworknodegraphnodepool","title":"<code>TObjectPool&lt; BaseNode &gt; &amp; SnAPI::GameFramework::NodeGraph::NodePool()</code>","text":"<p>Access the node pool (mutable).</p> <p>Returns: Reference to the pool.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#const-tobjectpool-basenode-snapigameframeworknodegraphnodepool-const","title":"<code>const TObjectPool&lt; BaseNode &gt; &amp; SnAPI::GameFramework::NodeGraph::NodePool() const</code>","text":"<p>Access the node pool (const).</p> <p>Returns: Const reference to the pool.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#size_t-snapigameframeworknodegraphrelevancebudget-const","title":"<code>size_t SnAPI::GameFramework::NodeGraph::RelevanceBudget() const</code>","text":"<p>Get the relevance evaluation budget.</p> <p>Returns: Max number of nodes evaluated per tick.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphrelevancebudgetsize_t-budget","title":"<code>void SnAPI::GameFramework::NodeGraph::RelevanceBudget(size_t Budget)</code>","text":"<p>Set the relevance evaluation budget.</p> <p>Parameters</p> <ul> <li><code>Budget</code>: Max number of nodes evaluated per tick (0 = unlimited).</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#private-functions","title":"Private Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpectedref-t-snapigameframeworknodegraphaddcomponentnodehandle-owner-args-args","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::NodeGraph::AddComponent(NodeHandle Owner, Args &amp;&amp;... args)</code>","text":"<p>Add a component of type T to a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>args</code>: Constructor arguments.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpectedref-t-snapigameframeworknodegraphaddcomponentwithidnodehandle-owner-const-uuid-id-args-args","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::NodeGraph::AddComponentWithId(NodeHandle Owner, const Uuid &amp;Id, Args &amp;&amp;... args)</code>","text":"<p>Add a component of type T to a node with explicit UUID.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>Id</code>: </li> <li><code>args</code>: Constructor arguments.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#texpectedref-t-snapigameframeworknodegraphcomponentnodehandle-owner","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::NodeGraph::Component(NodeHandle Owner)</code>","text":"<p>Get a component of type T from a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#bool-snapigameframeworknodegraphhascomponentnodehandle-owner-const","title":"<code>bool SnAPI::GameFramework::NodeGraph::HasComponent(NodeHandle Owner) const</code>","text":"<p>Check if a node has a component of type T.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> </ul> <p>Returns: True if the component exists.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphremovecomponentnodehandle-owner","title":"<code>void SnAPI::GameFramework::NodeGraph::RemoveComponent(NodeHandle Owner)</code>","text":"<p>Remove a component of type T from a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphtickcomponentsnodehandle-owner-float-deltaseconds","title":"<code>void SnAPI::GameFramework::NodeGraph::TickComponents(NodeHandle Owner, float DeltaSeconds)</code>","text":"<p>Tick all components for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphfixedtickcomponentsnodehandle-owner-float-deltaseconds","title":"<code>void SnAPI::GameFramework::NodeGraph::FixedTickComponents(NodeHandle Owner, float DeltaSeconds)</code>","text":"<p>Fixed-step tick all components for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphlatetickcomponentsnodehandle-owner-float-deltaseconds","title":"<code>void SnAPI::GameFramework::NodeGraph::LateTickComponents(NodeHandle Owner, float DeltaSeconds)</code>","text":"<p>Late tick all components for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphevaluaterelevance","title":"<code>void SnAPI::GameFramework::NodeGraph::EvaluateRelevance()</code>","text":"<p>Evaluate relevance policies to enable/disable nodes.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#bool-snapigameframeworknodegraphisnodeactivenodehandle-handle","title":"<code>bool SnAPI::GameFramework::NodeGraph::IsNodeActive(NodeHandle Handle)</code>","text":"<p>Check whether a node is active for ticking.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: </li> </ul> <p>Returns: True if node is active and relevant.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#bool-snapigameframeworknodegraphisnodeactiveconst-basenode-node-const","title":"<code>bool SnAPI::GameFramework::NodeGraph::IsNodeActive(const BaseNode &amp;Node) const</code>","text":"<p>Check whether an already-resolved node is active for ticking.</p> <p>Parameters</p> <ul> <li><code>Node</code>: Node reference.</li> </ul> <p>Returns: True if node is active and relevant.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphregistercomponentonnodebasenode-node-const-typeid-type","title":"<code>void SnAPI::GameFramework::NodeGraph::RegisterComponentOnNode(BaseNode &amp;Node, const TypeId &amp;Type)</code>","text":"<p>Register a component type on a node's type list/mask.</p> <p>Parameters</p> <ul> <li><code>Node</code>: Node to update.</li> <li><code>Type</code>: Component type id.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphunregistercomponentonnodebasenode-node-const-typeid-type","title":"<code>void SnAPI::GameFramework::NodeGraph::UnregisterComponentOnNode(BaseNode &amp;Node, const TypeId &amp;Type)</code>","text":"<p>Unregister a component type from a node's type list/mask.</p> <p>Parameters</p> <ul> <li><code>Node</code>: Node to update.</li> <li><code>Type</code>: Component type id.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphrebindownergraph","title":"<code>void SnAPI::GameFramework::NodeGraph::RebindOwnerGraph()</code>","text":"<p>Rebind owner graph pointers after move.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#tcomponentstorage-t-snapigameframeworknodegraphstoragefor","title":"<code>TComponentStorage&lt; T &gt; &amp; SnAPI::GameFramework::NodeGraph::StorageFor()</code>","text":"<p>Get or create a component storage for type T.</p> <p>Returns: Reference to the storage.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#icomponentstorage-snapigameframeworknodegraphstorageconst-typeid-type","title":"<code>IComponentStorage * SnAPI::GameFramework::NodeGraph::Storage(const TypeId &amp;Type)</code>","text":"<p>Get a component storage by type id (mutable).</p> <p>Parameters</p> <ul> <li><code>Type</code>: Component type id.</li> </ul> <p>Returns: Pointer to storage or nullptr if not found.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#const-icomponentstorage-snapigameframeworknodegraphstorageconst-typeid-type-const","title":"<code>const IComponentStorage * SnAPI::GameFramework::NodeGraph::Storage(const TypeId &amp;Type) const</code>","text":"<p>Get a component storage by type id (const).</p> <p>Parameters</p> <ul> <li><code>Type</code>: Component type id.</li> </ul> <p>Returns: Pointer to storage or nullptr if not found.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#void-snapigameframeworknodegraphborrowedcomponentnodehandle-owner-const-typeid-type","title":"<code>void * SnAPI::GameFramework::NodeGraph::BorrowedComponent(NodeHandle Owner, const TypeId &amp;Type)</code>","text":"<p>Borrow a component instance by owner/type (mutable).</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>Type</code>: Component type id.</li> </ul> <p>Returns: Pointer to component or nullptr if missing.</p> <p>Notes</p> <ul> <li>Borrowed pointers must not be cached.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraph/#const-void-snapigameframeworknodegraphborrowedcomponentnodehandle-owner-const-typeid-type-const","title":"<code>const void * SnAPI::GameFramework::NodeGraph::BorrowedComponent(NodeHandle Owner, const TypeId &amp;Type) const</code>","text":"<p>Borrow a component instance by owner/type (const).</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>Type</code>: Component type id.</li> </ul> <p>Returns: Pointer to component or nullptr if missing.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraphSerializer/","title":"SnAPI::GameFramework::NodeGraphSerializer","text":"<p>Serializer for NodeGraph to/from NodeGraphPayload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraphSerializer/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraphSerializer/#uint32_t-snapigameframeworknodegraphserializerkschemaversion","title":"<code>uint32_t SnAPI::GameFramework::NodeGraphSerializer::kSchemaVersion</code>","text":"<p>Current schema version for NodeGraph payloads.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraphSerializer/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraphSerializer/#texpected-nodegraphpayload-snapigameframeworknodegraphserializerserializeconst-nodegraph-graph","title":"<code>TExpected&lt; NodeGraphPayload &gt; SnAPI::GameFramework::NodeGraphSerializer::Serialize(const NodeGraph &amp;Graph)</code>","text":"<p>Serialize a graph to a payload.</p> <p>Parameters</p> <ul> <li><code>Graph</code>: Source graph.</li> </ul> <p>Returns: Payload or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1NodeGraphSerializer/#texpected-void-snapigameframeworknodegraphserializerdeserializeconst-nodegraphpayload-payload-nodegraph-graph","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::NodeGraphSerializer::Deserialize(const NodeGraphPayload &amp;Payload, NodeGraph &amp;Graph)</code>","text":"<p>Deserialize a graph from a payload.</p> <p>Parameters</p> <ul> <li><code>Payload</code>: Payload to read.</li> <li><code>Graph</code>: Destination graph.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/","title":"SnAPI::GameFramework::ObjectRegistry","text":"<p>Global registry mapping UUIDs to live object pointers.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::ObjectRegistry::Entry</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#stdmutex-snapigameframeworkobjectregistrym_mutex","title":"<code>std::mutex SnAPI::GameFramework::ObjectRegistry::m_mutex</code>","text":"<p>Protects the registry map.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#stdunordered_mapuuid-entry-uuidhash-snapigameframeworkobjectregistrym_entries","title":"<code>std::unordered_map&lt;Uuid, Entry, UuidHash&gt; SnAPI::GameFramework::ObjectRegistry::m_entries</code>","text":"<p>UUID -&gt; Entry map.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#static-objectregistry-snapigameframeworkobjectregistryinstance","title":"<code>static ObjectRegistry &amp; SnAPI::GameFramework::ObjectRegistry::Instance()</code>","text":"<p>Access the singleton registry instance.</p> <p>Returns: Reference to the registry.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#void-snapigameframeworkobjectregistryregisternodeconst-uuid-id-basenode-node","title":"<code>void SnAPI::GameFramework::ObjectRegistry::RegisterNode(const Uuid &amp;Id, BaseNode *Node)</code>","text":"<p>Register a node with the registry.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID of the node.</li> <li><code>Node</code>: Pointer to the node.</li> </ul> <p>Notes</p> <ul> <li>Id must not be nil.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#void-snapigameframeworkobjectregistryregistercomponentconst-uuid-id-icomponent-component","title":"<code>void SnAPI::GameFramework::ObjectRegistry::RegisterComponent(const Uuid &amp;Id, IComponent *Component)</code>","text":"<p>Register a component with the registry.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID of the component.</li> <li><code>Component</code>: Pointer to the component.</li> </ul> <p>Notes</p> <ul> <li>Id must not be nil.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#void-snapigameframeworkobjectregistryregisterconst-uuid-id-t-object","title":"<code>void SnAPI::GameFramework::ObjectRegistry::Register(const Uuid &amp;Id, T *Object)</code>","text":"<p>Register an arbitrary object with the registry.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID of the object.</li> <li><code>Object</code>: Pointer to the object.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#void-snapigameframeworkobjectregistryunregisterconst-uuid-id","title":"<code>void SnAPI::GameFramework::ObjectRegistry::Unregister(const Uuid &amp;Id)</code>","text":"<p>Unregister an object by UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to remove.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#t-snapigameframeworkobjectregistryresolveconst-uuid-id-const","title":"<code>T * SnAPI::GameFramework::ObjectRegistry::Resolve(const Uuid &amp;Id) const</code>","text":"<p>Resolve a UUID to a typed pointer.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to resolve.</li> </ul> <p>Returns: Pointer to the object, or nullptr if not found/type mismatch.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#bool-snapigameframeworkobjectregistryisvalidconst-uuid-id-const","title":"<code>bool SnAPI::GameFramework::ObjectRegistry::IsValid(const Uuid &amp;Id) const</code>","text":"<p>Check if a UUID resolves to a live object of type T.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to check.</li> </ul> <p>Returns: True when Resolve returns non-null."},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#private-functions","title":"Private Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ObjectRegistry/#void-snapigameframeworkobjectregistryregisterinternalconst-uuid-id-eobjectkind-kind-basenode-node-icomponent-component-void-other-stdtype_index-type","title":"<code>void SnAPI::GameFramework::ObjectRegistry::RegisterInternal(const Uuid &amp;Id, EObjectKind Kind, BaseNode *Node, IComponent *Component, void *Other, std::type_index Type)</code>","text":"<p>Internal insert/update for registry entries.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID key.</li> <li><code>Kind</code>: Object kind.</li> <li><code>Node</code>: Node pointer.</li> <li><code>Component</code>: Component pointer.</li> <li><code>Other</code>: Opaque pointer.</li> <li><code>Type</code>: type_index for Other.</li> </ul> <p>Notes</p> <ul> <li>Id must not be nil.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/","title":"SnAPI::GameFramework::RelevanceComponent","text":"<p>Component that drives relevance evaluation for a node.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#const-char-snapigameframeworkrelevancecomponentktypename","title":"<code>const char* SnAPI::GameFramework::RelevanceComponent::kTypeName</code>","text":"<p>Stable type name for reflection.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#typeid-snapigameframeworkrelevancecomponentm_policyid","title":"<code>TypeId SnAPI::GameFramework::RelevanceComponent::m_policyId</code>","text":"<p>Reflected type id of current policy object.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#stdshared_ptrvoid-snapigameframeworkrelevancecomponentm_policydata","title":"<code>std::shared_ptr&lt;void&gt; SnAPI::GameFramework::RelevanceComponent::m_policyData</code>","text":"<p>Owned type-erased policy instance payload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#bool-snapigameframeworkrelevancecomponentm_active","title":"<code>bool SnAPI::GameFramework::RelevanceComponent::m_active</code>","text":"<p>Last computed relevance active state applied to node gating.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#float-snapigameframeworkrelevancecomponentm_lastscore","title":"<code>float SnAPI::GameFramework::RelevanceComponent::m_lastScore</code>","text":"<p>Last computed score used for diagnostics/future prioritization.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#void-snapigameframeworkrelevancecomponentpolicypolicyt-policy","title":"<code>void SnAPI::GameFramework::RelevanceComponent::Policy(PolicyT Policy)</code>","text":"<p>Set the relevance policy for this component.</p> <p>Parameters</p> <ul> <li><code>Policy</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#const-typeid-snapigameframeworkrelevancecomponentpolicyid-const","title":"<code>const TypeId &amp; SnAPI::GameFramework::RelevanceComponent::PolicyId() const</code>","text":"<p>Get the policy type id.</p> <p>Returns: TypeId of the policy.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#const-stdshared_ptr-void-snapigameframeworkrelevancecomponentpolicydata-const","title":"<code>const std::shared_ptr&lt; void &gt; &amp; SnAPI::GameFramework::RelevanceComponent::PolicyData() const</code>","text":"<p>Get the stored policy instance.</p> <p>Returns: Shared pointer to the policy data.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#bool-snapigameframeworkrelevancecomponentactive-const","title":"<code>bool SnAPI::GameFramework::RelevanceComponent::Active() const</code>","text":"<p>Get the active state computed by relevance.</p> <p>Returns: True if relevant.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#void-snapigameframeworkrelevancecomponentactivebool-active","title":"<code>void SnAPI::GameFramework::RelevanceComponent::Active(bool Active)</code>","text":"<p>Set the active state computed by relevance.</p> <p>Parameters</p> <ul> <li><code>Active</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#float-snapigameframeworkrelevancecomponentlastscore-const","title":"<code>float SnAPI::GameFramework::RelevanceComponent::LastScore() const</code>","text":"<p>Get the last computed relevance score.</p> <p>Returns: Score value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevanceComponent/#void-snapigameframeworkrelevancecomponentlastscorefloat-score","title":"<code>void SnAPI::GameFramework::RelevanceComponent::LastScore(float Score)</code>","text":"<p>Set the last computed relevance score.</p> <p>Parameters</p> <ul> <li><code>Score</code>: Score value.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/","title":"SnAPI::GameFramework::RelevancePolicyRegistry","text":"<p>Registry for relevance policy types.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::RelevancePolicyRegistry::PolicyInfo</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#public-types","title":"Public Types","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#using-snapigameframeworkrelevancepolicyregistryevaluatefn-boolconst-void-policydata-const-relevancecontext-context","title":"<code>using SnAPI::GameFramework::RelevancePolicyRegistry::EvaluateFn = bool(*)(const void* PolicyData, const RelevanceContext&amp; Context)</code>","text":"<p>Signature for relevance evaluation callbacks.</p> <p>Returns: True if the node is relevant/active.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#private-static-attrib","title":"Private Static Attrib","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#stdmutex-snapigameframeworkrelevancepolicyregistrym_mutex","title":"<code>std::mutex SnAPI::GameFramework::RelevancePolicyRegistry::m_mutex</code>","text":"<p>Protects policy map.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#stdunordered_maptypeid-policyinfo-uuidhash-snapigameframeworkrelevancepolicyregistrym_policies","title":"<code>std::unordered_map&lt;TypeId, PolicyInfo, UuidHash&gt; SnAPI::GameFramework::RelevancePolicyRegistry::m_policies</code>","text":"<p>Policy map by TypeId.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#static-void-snapigameframeworkrelevancepolicyregistryregister","title":"<code>static void SnAPI::GameFramework::RelevancePolicyRegistry::Register()</code>","text":"<p>Register a policy type.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#static-const-policyinfo-snapigameframeworkrelevancepolicyregistryfindconst-typeid-policyid","title":"<code>static const PolicyInfo * SnAPI::GameFramework::RelevancePolicyRegistry::Find(const TypeId &amp;PolicyId)</code>","text":"<p>Find policy metadata by TypeId.</p> <p>Parameters</p> <ul> <li><code>PolicyId</code>: Policy type id.</li> </ul> <p>Returns: Pointer to PolicyInfo or nullptr.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#private-static-func","title":"Private Static Func","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry/#static-bool-snapigameframeworkrelevancepolicyregistryevaluateimplconst-void-policydata-const-relevancecontext-context","title":"<code>static bool SnAPI::GameFramework::RelevancePolicyRegistry::EvaluateImpl(const void *PolicyData, const RelevanceContext &amp;Context)</code>","text":"<p>Internal evaluation wrapper for PolicyT.</p> <p>Parameters</p> <ul> <li><code>PolicyData</code>: Pointer to policy instance.</li> <li><code>Context</code>: Evaluation context.</li> </ul> <p>Returns: True if relevant.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptBindings/","title":"SnAPI::GameFramework::ScriptBindings","text":"<p>Helper for registering reflected types with script bindings.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptBindings/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptBindings/#static-texpected-void-snapigameframeworkscriptbindingsregistertype","title":"<code>static TExpected&lt; void &gt; SnAPI::GameFramework::ScriptBindings::RegisterType()</code>","text":"<p>Register a type for scripting.</p> <p>Returns: Success or error if the type is not reflected.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptComponent/","title":"SnAPI::GameFramework::ScriptComponent","text":"<p>Component that binds a node to a script instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptComponent/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptComponent/#const-char-snapigameframeworkscriptcomponentktypename","title":"<code>const char* SnAPI::GameFramework::ScriptComponent::kTypeName</code>","text":"<p>Stable type name for reflection.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptComponent/#public-members","title":"Public Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptComponent/#stdstring-snapigameframeworkscriptcomponentscriptmodule","title":"<code>std::string SnAPI::GameFramework::ScriptComponent::ScriptModule</code>","text":"<p>Backend-defined module identifier/path used for loading.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptComponent/#stdstring-snapigameframeworkscriptcomponentscripttype","title":"<code>std::string SnAPI::GameFramework::ScriptComponent::ScriptType</code>","text":"<p>Backend-defined type/class identifier instantiated from module.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptComponent/#scriptinstanceid-snapigameframeworkscriptcomponentinstance","title":"<code>ScriptInstanceId SnAPI::GameFramework::ScriptComponent::Instance</code>","text":"<p>Live runtime instance id (0 indicates not currently bound).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/","title":"SnAPI::GameFramework::ScriptRuntime","text":"<p>Wrapper owning a scripting engine instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/#stdshared_ptriscriptengine-snapigameframeworkscriptruntimem_engine","title":"<code>std::shared_ptr&lt;IScriptEngine&gt; SnAPI::GameFramework::ScriptRuntime::m_engine</code>","text":"<p>Owned engine instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/#snapigameframeworkscriptruntimescriptruntimestdshared_ptr-iscriptengine-engine","title":"<code>SnAPI::GameFramework::ScriptRuntime::ScriptRuntime(std::shared_ptr&lt; IScriptEngine &gt; Engine)</code>","text":"<p>Construct with an engine instance.</p> <p>Parameters</p> <ul> <li><code>Engine</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/#texpected-void-snapigameframeworkscriptruntimeinitialize","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ScriptRuntime::Initialize()</code>","text":"<p>Initialize the runtime.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/#texpected-void-snapigameframeworkscriptruntimeshutdown","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ScriptRuntime::Shutdown()</code>","text":"<p>Shutdown the runtime.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ScriptRuntime/#stdshared_ptr-iscriptengine-snapigameframeworkscriptruntimeengine-const","title":"<code>std::shared_ptr&lt; IScriptEngine &gt; SnAPI::GameFramework::ScriptRuntime::Engine() const</code>","text":"<p>Get the underlying engine.</p> <p>Returns: Shared pointer to the engine.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/","title":"SnAPI::GameFramework::TComponentStorage","text":"<p>Typed component storage for a specific component type.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#typeid-snapigameframeworktcomponentstorage-t-m_typeid","title":"<code>TypeId SnAPI::GameFramework::TComponentStorage&lt; T &gt;::m_typeId</code>","text":"<p>Reflected type id for this storage specialization.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#tobjectpoolt-snapigameframeworktcomponentstorage-t-m_pool","title":"<code>TObjectPool&lt;T&gt; SnAPI::GameFramework::TComponentStorage&lt; T &gt;::m_pool</code>","text":"<p>Underlying component object pool with deferred destroy support.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#stdunordered_mapnodehandle-uuid-handlehash-snapigameframeworktcomponentstorage-t-m_index","title":"<code>std::unordered_map&lt;NodeHandle, Uuid, HandleHash&gt; SnAPI::GameFramework::TComponentStorage&lt; T &gt;::m_index</code>","text":"<p>Owner-node handle -&gt; component UUID map.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#stdvectoruuid-snapigameframeworktcomponentstorage-t-m_pendingdestroy","title":"<code>std::vector&lt;Uuid&gt; SnAPI::GameFramework::TComponentStorage&lt; T &gt;::m_pendingDestroy</code>","text":"<p>Component ids scheduled for end-of-frame destroy flush.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#typeid-snapigameframeworktcomponentstorage-t-typekey-const-override","title":"<code>TypeId SnAPI::GameFramework::TComponentStorage&lt; T &gt;::TypeKey() const override</code>","text":"<p>Get the component type id.</p> <p>Returns: TypeId value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#texpectedref-t-snapigameframeworktcomponentstorage-t-addnodehandle-owner","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Add(NodeHandle Owner)</code>","text":"<p>Add a component with a generated UUID.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#texpectedref-t-snapigameframeworktcomponentstorage-t-addnodehandle-owner-args-args","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Add(NodeHandle Owner, Args &amp;&amp;... args)</code>","text":"<p>Add a component with constructor arguments.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>args</code>: Constructor arguments.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#texpectedref-t-snapigameframeworktcomponentstorage-t-addwithidnodehandle-owner-const-uuid-id-args-args","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::TComponentStorage&lt; T &gt;::AddWithId(NodeHandle Owner, const Uuid &amp;Id, Args &amp;&amp;... args)</code>","text":"<p>Add a component with an explicit UUID.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> <li><code>Id</code>: Component UUID.</li> <li><code>args</code>: Constructor arguments.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#texpectedref-t-snapigameframeworktcomponentstorage-t-componentnodehandle-owner","title":"<code>TExpectedRef&lt; T &gt; SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Component(NodeHandle Owner)</code>","text":"<p>Get a component by owner.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Owner node handle.</li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#bool-snapigameframeworktcomponentstorage-t-hasnodehandle-owner-const-override","title":"<code>bool SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Has(NodeHandle Owner) const override</code>","text":"<p>Check if a node has this component.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul> <p>Returns: True if present.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#void-snapigameframeworktcomponentstorage-t-removenodehandle-owner-override","title":"<code>void SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Remove(NodeHandle Owner) override</code>","text":"<p>Remove a component from a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#void-snapigameframeworktcomponentstorage-t-tickcomponentnodehandle-owner-float-deltaseconds-override","title":"<code>void SnAPI::GameFramework::TComponentStorage&lt; T &gt;::TickComponent(NodeHandle Owner, float DeltaSeconds) override</code>","text":"<p>Tick the component for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#void-snapigameframeworktcomponentstorage-t-fixedtickcomponentnodehandle-owner-float-deltaseconds-override","title":"<code>void SnAPI::GameFramework::TComponentStorage&lt; T &gt;::FixedTickComponent(NodeHandle Owner, float DeltaSeconds) override</code>","text":"<p>Fixed-step tick the component for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#void-snapigameframeworktcomponentstorage-t-latetickcomponentnodehandle-owner-float-deltaseconds-override","title":"<code>void SnAPI::GameFramework::TComponentStorage&lt; T &gt;::LateTickComponent(NodeHandle Owner, float DeltaSeconds) override</code>","text":"<p>Late tick the component for a node.</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#void-snapigameframeworktcomponentstorage-t-borrowednodehandle-owner-override","title":"<code>void * SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Borrowed(NodeHandle Owner) override</code>","text":"<p>Borrow the component instance (mutable).</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul> <p>Returns: Pointer to component or nullptr.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#const-void-snapigameframeworktcomponentstorage-t-borrowednodehandle-owner-const-override","title":"<code>const void * SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Borrowed(NodeHandle Owner) const override</code>","text":"<p>Borrow the component instance (const).</p> <p>Parameters</p> <ul> <li><code>Owner</code>: Node handle.</li> </ul> <p>Returns: Pointer to component or nullptr.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#void-snapigameframeworktcomponentstorage-t-endframe-override","title":"<code>void SnAPI::GameFramework::TComponentStorage&lt; T &gt;::EndFrame() override</code>","text":"<p>Process pending destruction at end-of-frame.</p> <p>Notes</p> <ul> <li>Ordering is deterministic by pending queue insertion order.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TComponentStorage/#void-snapigameframeworktcomponentstorage-t-clear-override","title":"<code>void SnAPI::GameFramework::TComponentStorage&lt; T &gt;::Clear() override</code>","text":"<p>Clear all components immediately.</p> <p>Notes</p> <ul> <li>Immediate path bypasses deferred destroy semantics.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/","title":"SnAPI::GameFramework::TExpectedRef","text":"<p>Lightweight expected wrapper that stores a reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#stdexpectedstdreference_wrappert-error-snapigameframeworktexpectedref-t-m_expected","title":"<code>std::expected&lt;std::reference_wrapper&lt;T&gt;, Error&gt; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::m_expected</code>","text":"<p>Stored expected reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#snapigameframeworktexpectedref-t-texpectedrefdefault","title":"<code>SnAPI::GameFramework::TExpectedRef&lt; T &gt;::TExpectedRef()=default</code>","text":"<p>Construct an empty (invalid) expected reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#snapigameframeworktexpectedref-t-texpectedreft-value","title":"<code>SnAPI::GameFramework::TExpectedRef&lt; T &gt;::TExpectedRef(T &amp;Value)</code>","text":"<p>Construct a success result from a reference.</p> <p>Parameters</p> <ul> <li><code>Value</code>: Referenced object.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#snapigameframeworktexpectedref-t-texpectedrefstdreference_wrapper-t-value","title":"<code>SnAPI::GameFramework::TExpectedRef&lt; T &gt;::TExpectedRef(std::reference_wrapper&lt; T &gt; Value)</code>","text":"<p>Construct a success result from a reference wrapper.</p> <p>Parameters</p> <ul> <li><code>Value</code>: Reference wrapper.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#snapigameframeworktexpectedref-t-texpectedrefstdunexpected-error-errorvalue","title":"<code>SnAPI::GameFramework::TExpectedRef&lt; T &gt;::TExpectedRef(std::unexpected&lt; Error &gt; ErrorValue)</code>","text":"<p>Construct a failure result.</p> <p>Parameters</p> <ul> <li><code>ErrorValue</code>: Error payload.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#snapigameframeworktexpectedref-t-operator-bool-const","title":"<code>SnAPI::GameFramework::TExpectedRef&lt; T &gt;::operator bool() const</code>","text":"<p>Boolean conversion for success checks.</p> <p>Returns: True when a valid reference is present.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#t-snapigameframeworktexpectedref-t-operator","title":"<code>T &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::operator*()</code>","text":"<p>Dereference to the underlying object.</p> <p>Returns: Reference to the contained object.</p> <p>Notes</p> <ul> <li>Behavior is undefined if this is in an error state.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#const-t-snapigameframeworktexpectedref-t-operator-const","title":"<code>const T &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::operator*() const</code>","text":"<p>Const dereference to the underlying object.</p> <p>Returns: Const reference to the contained object.</p> <p>Notes</p> <ul> <li>Behavior is undefined if this is in an error state.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#t-snapigameframeworktexpectedref-t-operator-","title":"<code>T * SnAPI::GameFramework::TExpectedRef&lt; T &gt;::operator-&gt;()</code>","text":"<p>Arrow operator access.</p> <p>Returns: Pointer to the contained object.</p> <p>Notes</p> <ul> <li>Behavior is undefined if this is in an error state.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#const-t-snapigameframeworktexpectedref-t-operator-const_1","title":"<code>const T * SnAPI::GameFramework::TExpectedRef&lt; T &gt;::operator-&gt;() const</code>","text":"<p>Const arrow operator access.</p> <p>Returns: Pointer to the contained object.</p> <p>Notes</p> <ul> <li>Behavior is undefined if this is in an error state.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#t-snapigameframeworktexpectedref-t-get","title":"<code>T &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::Get()</code>","text":"<p>Get the contained reference.</p> <p>Returns: Reference to the object.</p> <p>Notes</p> <ul> <li>Throws if no value is present.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#const-t-snapigameframeworktexpectedref-t-get-const","title":"<code>const T &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::Get() const</code>","text":"<p>Get the contained reference (const).</p> <p>Returns: Const reference to the object.</p> <p>Notes</p> <ul> <li>Throws if no value is present.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#error-snapigameframeworktexpectedref-t-error","title":"<code>Error &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::error()</code>","text":"<p>Access the error payload.</p> <p>Returns: Mutable reference to the Error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#const-error-snapigameframeworktexpectedref-t-error-const","title":"<code>const Error &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::error() const</code>","text":"<p>Access the error payload (const).</p> <p>Returns: Const reference to the Error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#t-snapigameframeworktexpectedref-t-value","title":"<code>T &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::value()</code>","text":"<p>Access the value, throwing on error.</p> <p>Returns: Reference to the object.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#const-t-snapigameframeworktexpectedref-t-value-const","title":"<code>const T &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::value() const</code>","text":"<p>Access the value (const), throwing on error.</p> <p>Returns: Const reference to the object.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#stdexpected-stdreference_wrapper-t-error-snapigameframeworktexpectedref-t-raw","title":"<code>std::expected&lt; std::reference_wrapper&lt; T &gt;, Error &gt; &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::Raw()</code>","text":"<p>Access the underlying std::expected.</p> <p>Returns: Mutable reference to the internal std::expected wrapper.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TExpectedRef/#const-stdexpected-stdreference_wrapper-t-error-snapigameframeworktexpectedref-t-raw-const","title":"<code>const std::expected&lt; std::reference_wrapper&lt; T &gt;, Error &gt; &amp; SnAPI::GameFramework::TExpectedRef&lt; T &gt;::Raw() const</code>","text":"<p>Access the underlying std::expected (const).</p> <p>Returns: Const reference to the internal std::expected wrapper.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/","title":"SnAPI::GameFramework::TFlags","text":"<p>Bit-flag helper for strongly-typed enums.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#public-types","title":"Public Types","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#using-snapigameframeworktflags-enum-underlying-stdunderlying_type_tenum","title":"<code>using SnAPI::GameFramework::TFlags&lt; Enum &gt;::Underlying = std::underlying_type_t&lt;Enum&gt;</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#underlying-snapigameframeworktflags-enum-m_value","title":"<code>Underlying SnAPI::GameFramework::TFlags&lt; Enum &gt;::m_value</code>","text":"<p>Raw underlying-bit storage for the wrapped enum flags.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#snapigameframeworktflags-enum-tflagsdefault","title":"<code>SnAPI::GameFramework::TFlags&lt; Enum &gt;::TFlags()=default</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#snapigameframeworktflags-enum-tflagsenum-bits","title":"<code>SnAPI::GameFramework::TFlags&lt; Enum &gt;::TFlags(Enum Bits)</code>","text":"<p>Parameters</p> <ul> <li><code>Bits</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#snapigameframeworktflags-enum-tflagsunderlying-value","title":"<code>SnAPI::GameFramework::TFlags&lt; Enum &gt;::TFlags(Underlying Value)</code>","text":"<p>Parameters</p> <ul> <li><code>Value</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#underlying-snapigameframeworktflags-enum-value-const","title":"<code>Underlying SnAPI::GameFramework::TFlags&lt; Enum &gt;::Value() const</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#bool-snapigameframeworktflags-enum-empty-const","title":"<code>bool SnAPI::GameFramework::TFlags&lt; Enum &gt;::Empty() const</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#bool-snapigameframeworktflags-enum-hasenum-bits-const","title":"<code>bool SnAPI::GameFramework::TFlags&lt; Enum &gt;::Has(Enum Bits) const</code>","text":"<p>Parameters</p> <ul> <li><code>Bits</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#void-snapigameframeworktflags-enum-addenum-bits","title":"<code>void SnAPI::GameFramework::TFlags&lt; Enum &gt;::Add(Enum Bits)</code>","text":"<p>Parameters</p> <ul> <li><code>Bits</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#void-snapigameframeworktflags-enum-removeenum-bits","title":"<code>void SnAPI::GameFramework::TFlags&lt; Enum &gt;::Remove(Enum Bits)</code>","text":"<p>Parameters</p> <ul> <li><code>Bits</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#void-snapigameframeworktflags-enum-clear","title":"<code>void SnAPI::GameFramework::TFlags&lt; Enum &gt;::Clear()</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#tflags-snapigameframeworktflags-enum-operatorenum-bits-const","title":"<code>TFlags SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator|(Enum Bits) const</code>","text":"<p>Parameters</p> <ul> <li><code>Bits</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#tflags-snapigameframeworktflags-enum-operatortflags-other-const","title":"<code>TFlags SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator|(TFlags Other) const</code>","text":"<p>Parameters</p> <ul> <li><code>Other</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#tflags-snapigameframeworktflags-enum-operatorenum-bits-const_1","title":"<code>TFlags SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator&amp;(Enum Bits) const</code>","text":"<p>Parameters</p> <ul> <li><code>Bits</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#tflags-snapigameframeworktflags-enum-operatortflags-other-const_1","title":"<code>TFlags SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator&amp;(TFlags Other) const</code>","text":"<p>Parameters</p> <ul> <li><code>Other</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#tflags-snapigameframeworktflags-enum-operatorenum-bits","title":"<code>TFlags &amp; SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator|=(Enum Bits)</code>","text":"<p>Parameters</p> <ul> <li><code>Bits</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#tflags-snapigameframeworktflags-enum-operatortflags-other","title":"<code>TFlags &amp; SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator|=(TFlags Other)</code>","text":"<p>Parameters</p> <ul> <li><code>Other</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#bool-snapigameframeworktflags-enum-operatortflags-other-const","title":"<code>bool SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator==(TFlags Other) const</code>","text":"<p>Parameters</p> <ul> <li><code>Other</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#bool-snapigameframeworktflags-enum-operatortflags-other-const_1","title":"<code>bool SnAPI::GameFramework::TFlags&lt; Enum &gt;::operator!=(TFlags Other) const</code>","text":"<p>Parameters</p> <ul> <li><code>Other</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TFlags/#static-constexpr-tflags-snapigameframeworktflags-enum-fromrawunderlying-value","title":"<code>static constexpr TFlags SnAPI::GameFramework::TFlags&lt; Enum &gt;::FromRaw(Underlying Value)</code>","text":"<p>Parameters</p> <ul> <li><code>Value</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/","title":"SnAPI::GameFramework::TObjectPool","text":"<p>Thread-safe object pool keyed by UUID handles.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::TObjectPool::Entry</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#public-types","title":"Public Types","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#using-snapigameframeworktobjectpool-t-handle-thandlet","title":"<code>using SnAPI::GameFramework::TObjectPool&lt; T &gt;::Handle = THandle&lt;T&gt;</code>","text":"<p>Handle type for objects in this pool.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#stdmutex-snapigameframeworktobjectpool-t-m_mutex","title":"<code>std::mutex SnAPI::GameFramework::TObjectPool&lt; T &gt;::m_mutex</code>","text":"<p>Protects pool state.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#stdvectorentry-snapigameframeworktobjectpool-t-m_entries","title":"<code>std::vector&lt;Entry&gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::m_entries</code>","text":"<p>Dense storage for entries.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#stdunordered_mapuuid-size_t-uuidhash-snapigameframeworktobjectpool-t-m_index","title":"<code>std::unordered_map&lt;Uuid, size_t, UuidHash&gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::m_index</code>","text":"<p>UUID -&gt; entry index.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#stdvectorsize_t-snapigameframeworktobjectpool-t-m_freelist","title":"<code>std::vector&lt;size_t&gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::m_freeList</code>","text":"<p>Reusable entry indices.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#stdvectorsize_t-snapigameframeworktobjectpool-t-m_pendingdestroy","title":"<code>std::vector&lt;size_t&gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::m_pendingDestroy</code>","text":"<p>Indices scheduled for deletion.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#snapigameframeworktobjectpool-t-tobjectpooldefault","title":"<code>SnAPI::GameFramework::TObjectPool&lt; T &gt;::TObjectPool()=default</code>","text":"<p>Construct an empty pool.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#texpected-handle-snapigameframeworktobjectpool-t-createargs-args","title":"<code>TExpected&lt; Handle &gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::Create(Args &amp;&amp;... args)</code>","text":"<p>Create a new object with a generated UUID.</p> <p>Parameters</p> <ul> <li><code>args</code>: Constructor arguments for U.</li> </ul> <p>Returns: Handle to the created object or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#texpected-handle-snapigameframeworktobjectpool-t-createwithidconst-uuid-id-args-args","title":"<code>TExpected&lt; Handle &gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::CreateWithId(const Uuid &amp;Id, Args &amp;&amp;... args)</code>","text":"<p>Create a new object with an explicit UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to assign to the object.</li> <li><code>args</code>: Constructor arguments for U.</li> </ul> <p>Returns: Handle to the created object or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#texpected-handle-snapigameframeworktobjectpool-t-createfromsharedstdshared_ptr-t-object","title":"<code>TExpected&lt; Handle &gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::CreateFromShared(std::shared_ptr&lt; T &gt; Object)</code>","text":"<p>Insert an existing shared object with a generated UUID.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Shared pointer to insert.</li> </ul> <p>Returns: Handle to the inserted object or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#texpected-handle-snapigameframeworktobjectpool-t-createfromsharedwithidstdshared_ptr-t-object-const-uuid-id","title":"<code>TExpected&lt; Handle &gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::CreateFromSharedWithId(std::shared_ptr&lt; T &gt; Object, const Uuid &amp;Id)</code>","text":"<p>Insert an existing shared object with an explicit UUID.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Shared pointer to insert.</li> <li><code>Id</code>: UUID to assign to the object.</li> </ul> <p>Returns: Handle to the inserted object or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#bool-snapigameframeworktobjectpool-t-isvalidconst-handle-handleref-const","title":"<code>bool SnAPI::GameFramework::TObjectPool&lt; T &gt;::IsValid(const Handle &amp;HandleRef) const</code>","text":"<p>Check if a handle resolves to a live object.</p> <p>Parameters</p> <ul> <li><code>HandleRef</code>: Handle to validate.</li> </ul> <p>Returns: True if object exists and is not pending destroy.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#bool-snapigameframeworktobjectpool-t-isvalidconst-uuid-id-const","title":"<code>bool SnAPI::GameFramework::TObjectPool&lt; T &gt;::IsValid(const Uuid &amp;Id) const</code>","text":"<p>Check if a UUID resolves to a live object.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to validate.</li> </ul> <p>Returns: True if object exists and is not pending destroy.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#t-snapigameframeworktobjectpool-t-borrowedconst-handle-handleref","title":"<code>T * SnAPI::GameFramework::TObjectPool&lt; T &gt;::Borrowed(const Handle &amp;HandleRef)</code>","text":"<p>Resolve a handle to a borrowed pointer.</p> <p>Parameters</p> <ul> <li><code>HandleRef</code>: Handle to resolve.</li> </ul> <p>Returns: Pointer to object or nullptr if not found/pending destroy.</p> <p>Notes</p> <ul> <li>Borrowed pointers must not be cached.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#t-snapigameframeworktobjectpool-t-borrowedconst-uuid-id","title":"<code>T * SnAPI::GameFramework::TObjectPool&lt; T &gt;::Borrowed(const Uuid &amp;Id)</code>","text":"<p>Resolve a UUID to a borrowed pointer.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to resolve.</li> </ul> <p>Returns: Pointer to object or nullptr if not found/pending destroy.</p> <p>Notes</p> <ul> <li>Borrowed pointers must not be cached.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#const-t-snapigameframeworktobjectpool-t-borrowedconst-handle-handleref-const","title":"<code>const T * SnAPI::GameFramework::TObjectPool&lt; T &gt;::Borrowed(const Handle &amp;HandleRef) const</code>","text":"<p>Resolve a handle to a borrowed pointer (const).</p> <p>Parameters</p> <ul> <li><code>HandleRef</code>: Handle to resolve.</li> </ul> <p>Returns: Pointer to object or nullptr if not found/pending destroy.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#const-t-snapigameframeworktobjectpool-t-borrowedconst-uuid-id-const","title":"<code>const T * SnAPI::GameFramework::TObjectPool&lt; T &gt;::Borrowed(const Uuid &amp;Id) const</code>","text":"<p>Resolve a UUID to a borrowed pointer (const).</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to resolve.</li> </ul> <p>Returns: Pointer to object or nullptr if not found/pending destroy.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#texpected-void-snapigameframeworktobjectpool-t-destroylaterconst-handle-handleref","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::DestroyLater(const Handle &amp;HandleRef)</code>","text":"<p>Mark an object for end-of-frame destruction by handle.</p> <p>Parameters</p> <ul> <li><code>HandleRef</code>: Handle to destroy.</li> </ul> <p>Returns: Success or error if not found.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#texpected-void-snapigameframeworktobjectpool-t-destroylaterconst-uuid-id","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::DestroyLater(const Uuid &amp;Id)</code>","text":"<p>Mark an object for end-of-frame destruction by UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to destroy.</li> </ul> <p>Returns: Success or error if not found.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#void-snapigameframeworktobjectpool-t-endframe","title":"<code>void SnAPI::GameFramework::TObjectPool&lt; T &gt;::EndFrame()</code>","text":"<p>Destroy all objects that were marked for deletion.</p> <p>Notes</p> <ul> <li>Should be called at end of frame to keep handles stable.</li> <li>Destroyed UUID keys are removed from index and may be reused on future creates.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#void-snapigameframeworktobjectpool-t-clear","title":"<code>void SnAPI::GameFramework::TObjectPool&lt; T &gt;::Clear()</code>","text":"<p>Remove all objects immediately.</p> <p>Notes</p> <ul> <li>Use cautiously; invalidates all handles immediately.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#bool-snapigameframeworktobjectpool-t-ispendingdestroyconst-handle-handleref-const","title":"<code>bool SnAPI::GameFramework::TObjectPool&lt; T &gt;::IsPendingDestroy(const Handle &amp;HandleRef) const</code>","text":"<p>Check if a handle is pending destruction.</p> <p>Parameters</p> <ul> <li><code>HandleRef</code>: Handle to check.</li> </ul> <p>Returns: True if the object is marked for deletion.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#bool-snapigameframeworktobjectpool-t-ispendingdestroyconst-uuid-id-const","title":"<code>bool SnAPI::GameFramework::TObjectPool&lt; T &gt;::IsPendingDestroy(const Uuid &amp;Id) const</code>","text":"<p>Check if a UUID is pending destruction.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to check.</li> </ul> <p>Returns: True if the object is marked for deletion.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#void-snapigameframeworktobjectpool-t-foreachconst-fn-func-const","title":"<code>void SnAPI::GameFramework::TObjectPool&lt; T &gt;::ForEach(const Fn &amp;Func) const</code>","text":"<p>Iterate over all live (non-pending) objects (const).</p> <p>Parameters</p> <ul> <li><code>Func</code>: Callback invoked with (Handle, Object).</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#void-snapigameframeworktobjectpool-t-foreachallconst-fn-func-const","title":"<code>void SnAPI::GameFramework::TObjectPool&lt; T &gt;::ForEachAll(const Fn &amp;Func) const</code>","text":"<p>Iterate over all objects including pending destroy (const).</p> <p>Parameters</p> <ul> <li><code>Func</code>: Callback invoked with (Handle, Object).</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#void-snapigameframeworktobjectpool-t-foreachconst-fn-func","title":"<code>void SnAPI::GameFramework::TObjectPool&lt; T &gt;::ForEach(const Fn &amp;Func)</code>","text":"<p>Iterate over all live (non-pending) objects (mutable).</p> <p>Parameters</p> <ul> <li><code>Func</code>: Callback invoked with (Handle, Object).</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#void-snapigameframeworktobjectpool-t-foreachallconst-fn-func","title":"<code>void SnAPI::GameFramework::TObjectPool&lt; T &gt;::ForEachAll(const Fn &amp;Func)</code>","text":"<p>Iterate over all objects including pending destroy (mutable).</p> <p>Parameters</p> <ul> <li><code>Func</code>: Callback invoked with (Handle, Object).</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#private-functions","title":"Private Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TObjectPool/#size_t-snapigameframeworktobjectpool-t-allocateslot","title":"<code>size_t SnAPI::GameFramework::TObjectPool&lt; T &gt;::AllocateSlot()</code>","text":"<p>Allocate a storage slot, reusing free slots if possible.</p> <p>Returns: Index into m_entries.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/","title":"SnAPI::GameFramework::TTypeBuilder","text":"<p>Fluent builder for registering reflection metadata.</p> <p>Best-practice lifecycle: 1. define fields/methods/constructors/base types 2. call <code>Register()</code> once in one translation unit (typically through <code>SNAPI_REFLECT_TYPE</code>) 3. let <code>TypeAutoRegistry</code> ensure-on-first-use resolve registration at runtime</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#typeinfo-snapigameframeworkttypebuilder-t-m_info","title":"<code>TypeInfo SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::m_info</code>","text":"<p>Accumulated type metadata.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#snapigameframeworkttypebuilder-t-ttypebuilderconst-char-name","title":"<code>SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::TTypeBuilder(const char *Name)</code>","text":"<p>Construct a builder for a type name.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Fully qualified type name.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#ttypebuilder-snapigameframeworkttypebuilder-t-base","title":"<code>TTypeBuilder &amp; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::Base()</code>","text":"<p>Register a base type.</p> <p>Returns: Reference to the builder for chaining.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#ttypebuilder-snapigameframeworkttypebuilder-t-fieldconst-char-name-fieldt-tmember-fieldflags-flags","title":"<code>TTypeBuilder &amp; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::Field(const char *Name, FieldT T::*Member, FieldFlags Flags={})</code>","text":"<p>Register a field with getter/setter support.</p> <p>Const member fields are reflected as read-only; setter returns error at runtime.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Field name.</li> <li><code>Member</code>: Pointer-to-member field.</li> <li><code>Flags</code>: </li> </ul> <p>Returns: Reference to the builder for chaining.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#ttypebuilder-snapigameframeworkttypebuilder-t-fieldconst-char-name-fieldt-tgetter-const-fieldt-tgetterconst-const-fieldflags-flags","title":"<code>TTypeBuilder &amp; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::Field(const char *Name, FieldT &amp;(T::*Getter)(), const FieldT &amp;(T::*GetterConst)() const, FieldFlags Flags={})</code>","text":"<p>Register a field via accessors that return references.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Field name.</li> <li><code>Getter</code>: Mutable accessor returning FieldT&amp;.</li> <li><code>GetterConst</code>: Const accessor returning const FieldT&amp;.</li> <li><code>Flags</code>: </li> </ul> <p>Returns: Reference to the builder for chaining.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#ttypebuilder-snapigameframeworkttypebuilder-t-methodconst-char-name-rtmethodargs-methodflags-flags","title":"<code>TTypeBuilder &amp; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::Method(const char *Name, R(T::*Method)(Args...), MethodFlags Flags={})</code>","text":"<p>Register a non-const method for reflection.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Method name.</li> <li><code>Method</code>: </li> <li><code>Flags</code>: </li> </ul> <p>Returns: Reference to the builder for chaining.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#ttypebuilder-snapigameframeworkttypebuilder-t-methodconst-char-name-rtmethodargs-const-methodflags-flags","title":"<code>TTypeBuilder &amp; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::Method(const char *Name, R(T::*Method)(Args...) const, MethodFlags Flags={})</code>","text":"<p>Register a const method for reflection.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Method name.</li> <li><code>Method</code>: </li> <li><code>Flags</code>: </li> </ul> <p>Returns: Reference to the builder for chaining.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#ttypebuilder-snapigameframeworkttypebuilder-t-constructor","title":"<code>TTypeBuilder &amp; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::Constructor()</code>","text":"<p>Register a constructor signature.</p> <p>Returns: Reference to the builder for chaining.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#texpected-typeinfo-snapigameframeworkttypebuilder-t-register","title":"<code>TExpected&lt; TypeInfo * &gt; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::Register()</code>","text":"<p>Register the built TypeInfo into the global TypeRegistry.</p> <p>Returns: Pointer to stored TypeInfo or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#private-static-func","title":"Private Static Func","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeBuilder/#static-texpected-stdshared_ptr-void-snapigameframeworkttypebuilder-t-constructimplstdspan-const-variant-argspack-stdindex_sequence-i","title":"<code>static TExpected&lt; std::shared_ptr&lt; void &gt; &gt; SnAPI::GameFramework::TTypeBuilder&lt; T &gt;::ConstructImpl(std::span&lt; const Variant &gt; ArgsPack, std::index_sequence&lt; I... &gt;)</code>","text":"<p>Construct an instance from a Variant argument pack.</p> <p>Parameters</p> <ul> <li><code>ArgsPack</code>: Argument span.</li> </ul> <p>Returns: Shared pointer to the constructed object.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeRegistrar/","title":"SnAPI::GameFramework::TTypeRegistrar","text":"<p>Helper that executes a registration function at static initialization.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeRegistrar/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TTypeRegistrar/#snapigameframeworkttyperegistrarttyperegistrarttyperegisterfn-fn","title":"<code>SnAPI::GameFramework::TTypeRegistrar::TTypeRegistrar(TTypeRegisterFn Fn)</code>","text":"<p>Construct and invoke the registration function.</p> <p>Parameters</p> <ul> <li><code>Fn</code>: Function pointer to call.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TransformComponent/","title":"SnAPI::GameFramework::TransformComponent","text":"<p>Basic transform component (position, quaternion rotation, scale).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TransformComponent/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TransformComponent/#const-char-snapigameframeworktransformcomponentktypename","title":"<code>const char* SnAPI::GameFramework::TransformComponent::kTypeName</code>","text":"<p>Stable type name for reflection.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TransformComponent/#public-members","title":"Public Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TransformComponent/#vec3-snapigameframeworktransformcomponentposition","title":"<code>Vec3 SnAPI::GameFramework::TransformComponent::Position</code>","text":"<p>Local position.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TransformComponent/#snapigameframeworktransformcomponentrotation","title":"<code>&amp; SnAPI::GameFramework::TransformComponent::Rotation</code>","text":"<p>Local rotation as quaternion.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TransformComponent/#vec3-snapigameframeworktransformcomponentscale","title":"<code>Vec3 SnAPI::GameFramework::TransformComponent::Scale</code>","text":"<p>Local scale.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/","title":"SnAPI::GameFramework::TypeAutoRegistry","text":"<p>Auto-registration registry for reflected types keyed by TypeId.</p> <p>The intent is: - Each reflected type registers a lightweight \"ensure\" callback at static-init time (via SNAPI_REFLECT_TYPE in a .cpp). - TypeRegistry/serialization can call Ensure(TypeId) on demand when a TypeId is encountered before its TypeInfo has been registered.</p> <p>This avoids relying on cross-TU static initialization order for the heavy TypeRegistry registration work.</p> <p>Contract: - ensure callbacks must be idempotent and thread-safe for repeated calls - registration collisions are tolerated only when callback identity matches</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#public-types","title":"Public Types","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#using-snapigameframeworktypeautoregistryensurefn-result","title":"<code>using SnAPI::GameFramework::TypeAutoRegistry::EnsureFn = Result(*)()</code>","text":"<p>Ensure callback signature.</p> <p>Should be idempotent.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#stdmutex-snapigameframeworktypeautoregistrym_mutex","title":"<code>std::mutex SnAPI::GameFramework::TypeAutoRegistry::m_mutex</code>","text":"<p>Protects ensure callback and diagnostics maps.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#stdunordered_maptypeid-ensurefn-uuidhash-snapigameframeworktypeautoregistrym_entries","title":"<code>std::unordered_map&lt;TypeId, EnsureFn, UuidHash&gt; SnAPI::GameFramework::TypeAutoRegistry::m_entries</code>","text":"<p>TypeId -&gt; ensure callback mapping.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#stdunordered_maptypeid-stdstring-uuidhash-snapigameframeworktypeautoregistrym_names","title":"<code>std::unordered_map&lt;TypeId, std::string, UuidHash&gt; SnAPI::GameFramework::TypeAutoRegistry::m_names</code>","text":"<p>Optional diagnostics map of TypeId -&gt; human-readable type name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#typeautoregistry-snapigameframeworktypeautoregistryinstance","title":"<code>TypeAutoRegistry &amp; SnAPI::GameFramework::TypeAutoRegistry::Instance()</code>","text":"<p>Access singleton instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#void-snapigameframeworktypeautoregistryregisterconst-typeid-id-stdstring_view-name-ensurefn-fn","title":"<code>void SnAPI::GameFramework::TypeAutoRegistry::Register(const TypeId &amp;Id, std::string_view Name, EnsureFn Fn)</code>","text":"<p>Register an ensure callback for a TypeId.</p> <p>Parameters</p> <ul> <li><code>Id</code>: Stable type id.</li> <li><code>Name</code>: Stable type name (for diagnostics).</li> <li><code>Fn</code>: Ensure function pointer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#result-snapigameframeworktypeautoregistryensureconst-typeid-id-const","title":"<code>Result SnAPI::GameFramework::TypeAutoRegistry::Ensure(const TypeId &amp;Id) const</code>","text":"<p>Ensure a TypeId has been registered with TypeRegistry.</p> <p>Parameters</p> <ul> <li><code>Id</code>: Type id.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeAutoRegistry/#bool-snapigameframeworktypeautoregistryhasconst-typeid-id-const","title":"<code>bool SnAPI::GameFramework::TypeAutoRegistry::Has(const TypeId &amp;Id) const</code>","text":"<p>Check whether an ensure callback is registered for Id.</p> <p>Parameters</p> <ul> <li><code>Id</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/","title":"SnAPI::GameFramework::TypeRegistry","text":"<p>Global registry for reflected types.</p> <p>Read/write model: - normal mode: read/write operations use mutex protection - frozen mode (<code>Freeze(true)</code>): read operations use lock-free fast path and registrations are rejected</p> <p>This enables high-frequency lookup paths (replication/serialization) to avoid lock contention after startup metadata registration has completed.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#stdmutex-snapigameframeworktyperegistrym_mutex","title":"<code>std::mutex SnAPI::GameFramework::TypeRegistry::m_mutex</code>","text":"<p>Guards registry mutation and non-frozen lookups.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#stdatomicbool-snapigameframeworktyperegistrym_frozen","title":"<code>std::atomic&lt;bool&gt; SnAPI::GameFramework::TypeRegistry::m_frozen</code>","text":"<p>Frozen state flag controlling read/write mode behavior.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#stdunordered_maptypeid-typeinfo-uuidhash-snapigameframeworktyperegistrym_types","title":"<code>std::unordered_map&lt;TypeId, TypeInfo, UuidHash&gt; SnAPI::GameFramework::TypeRegistry::m_types</code>","text":"<p>Primary metadata store keyed by TypeId.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#stdunordered_mapstdstring-typeid-transparentstringhash-transparentstringequal-snapigameframeworktyperegistrym_nametoid","title":"<code>std::unordered_map&lt;std::string, TypeId, TransparentStringHash, TransparentStringEqual&gt; SnAPI::GameFramework::TypeRegistry::m_nameToId</code>","text":"<p>Secondary name index for lookup by stable type name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#typeregistry-snapigameframeworktyperegistryinstance","title":"<code>TypeRegistry &amp; SnAPI::GameFramework::TypeRegistry::Instance()</code>","text":"<p>Access the singleton TypeRegistry instance.</p> <p>Returns: Reference to the registry.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#texpected-typeinfo-snapigameframeworktyperegistryregistertypeinfo-info","title":"<code>TExpected&lt; TypeInfo * &gt; SnAPI::GameFramework::TypeRegistry::Register(TypeInfo Info)</code>","text":"<p>Register a new type.</p> <p>Parameters</p> <ul> <li><code>Info</code>: Type metadata.</li> </ul> <p>Returns: Pointer to the stored TypeInfo or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#const-typeinfo-snapigameframeworktyperegistryfindconst-typeid-id-const","title":"<code>const TypeInfo * SnAPI::GameFramework::TypeRegistry::Find(const TypeId &amp;Id) const</code>","text":"<p>Find a type by TypeId.</p> <p>Parameters</p> <ul> <li><code>Id</code>: TypeId to lookup.</li> </ul> <p>Returns: Pointer to TypeInfo or nullptr if not found.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#const-typeinfo-snapigameframeworktyperegistryfindbynamestdstring_view-name-const","title":"<code>const TypeInfo * SnAPI::GameFramework::TypeRegistry::FindByName(std::string_view Name) const</code>","text":"<p>Find a type by name.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Fully qualified type name.</li> </ul> <p>Returns: Pointer to TypeInfo or nullptr if not found.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#bool-snapigameframeworktyperegistryisaconst-typeid-type-const-typeid-base-const","title":"<code>bool SnAPI::GameFramework::TypeRegistry::IsA(const TypeId &amp;Type, const TypeId &amp;Base) const</code>","text":"<p>Check inheritance between two types.</p> <p>Parameters</p> <ul> <li><code>Type</code>: Derived type id.</li> <li><code>Base</code>: Base type id.</li> </ul> <p>Returns: True if Type is-a Base.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#stdvector-const-typeinfo-snapigameframeworktyperegistryderivedconst-typeid-base-const","title":"<code>std::vector&lt; const TypeInfo * &gt; SnAPI::GameFramework::TypeRegistry::Derived(const TypeId &amp;Base) const</code>","text":"<p>Get all types derived from a base.</p> <p>Parameters</p> <ul> <li><code>Base</code>: Base type id.</li> </ul> <p>Returns: Vector of derived type infos.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#void-snapigameframeworktyperegistryfreezebool-enable","title":"<code>void SnAPI::GameFramework::TypeRegistry::Freeze(bool Enable)</code>","text":"<p>Enable or disable lock-free reads.</p> <p>Parameters</p> <ul> <li><code>Enable</code>: True to freeze the registry (no further registration).</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1TypeRegistry/#bool-snapigameframeworktyperegistryisfrozen-const","title":"<code>bool SnAPI::GameFramework::TypeRegistry::IsFrozen() const</code>","text":"<p>Check if the registry is frozen.</p> <p>Returns: True if frozen.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/","title":"SnAPI::GameFramework::ValueCodecRegistry","text":"<p>Registry for value codecs used by reflection serialization.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::ValueCodecRegistry::CodecEntry</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#public-types","title":"Public Types","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#using-snapigameframeworkvaluecodecregistryencodefn-texpectedvoidconst-void-value-cerealbinaryoutputarchive-archive-const-tserializationcontext-context","title":"<code>using SnAPI::GameFramework::ValueCodecRegistry::EncodeFn = TExpected&lt;void&gt;(*)(const void* Value, cereal::BinaryOutputArchive&amp; Archive, const TSerializationContext&amp; Context)</code>","text":"<p>Encoder function signature.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#using-snapigameframeworkvaluecodecregistrydecodefn-texpectedvariantcerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>using SnAPI::GameFramework::ValueCodecRegistry::DecodeFn = TExpected&lt;Variant&gt;(*)(cereal::BinaryInputArchive&amp; Archive, const TSerializationContext&amp; Context)</code>","text":"<p>Decoder function signature.</p> <p>Returns: Variant containing decoded value or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#using-snapigameframeworkvaluecodecregistrydecodeintofn-texpectedvoidvoid-value-cerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>using SnAPI::GameFramework::ValueCodecRegistry::DecodeIntoFn = TExpected&lt;void&gt;(*)(void* Value, cereal::BinaryInputArchive&amp; Archive, const TSerializationContext&amp; Context)</code>","text":"<p>Decode-into function signature.</p> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#stdunordered_maptypeid-codecentry-uuidhash-snapigameframeworkvaluecodecregistrym_entries","title":"<code>std::unordered_map&lt;TypeId, CodecEntry, UuidHash&gt; SnAPI::GameFramework::ValueCodecRegistry::m_entries</code>","text":"<p>Runtime codec dispatch table keyed by reflected TypeId.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#uint32_t-snapigameframeworkvaluecodecregistrym_version","title":"<code>uint32_t SnAPI::GameFramework::ValueCodecRegistry::m_version</code>","text":"<p>Monotonic cache-invalidation version incremented on each registration.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#valuecodecregistry-snapigameframeworkvaluecodecregistryinstance","title":"<code>ValueCodecRegistry &amp; SnAPI::GameFramework::ValueCodecRegistry::Instance()</code>","text":"<p>Access the singleton registry.</p> <p>Returns: Registry instance.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#void-snapigameframeworkvaluecodecregistryregister","title":"<code>void SnAPI::GameFramework::ValueCodecRegistry::Register()</code>","text":"<p>Register a codec for type T.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#bool-snapigameframeworkvaluecodecregistryhasconst-typeid-type-const","title":"<code>bool SnAPI::GameFramework::ValueCodecRegistry::Has(const TypeId &amp;Type) const</code>","text":"<p>Check if a codec exists for a type.</p> <p>Parameters</p> <ul> <li><code>Type</code>: TypeId to query.</li> </ul> <p>Returns: True if registered.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#const-valuecodecregistrycodecentry-snapigameframeworkvaluecodecregistryfindentryconst-typeid-type-const","title":"<code>const ValueCodecRegistry::CodecEntry * SnAPI::GameFramework::ValueCodecRegistry::FindEntry(const TypeId &amp;Type) const</code>","text":"<p>Lookup the codec entry for a type.</p> <p>Parameters</p> <ul> <li><code>Type</code>: TypeId to query.</li> </ul> <p>Returns: Pointer to codec entry or nullptr if not found.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#uint32_t-snapigameframeworkvaluecodecregistryversion-const","title":"<code>uint32_t SnAPI::GameFramework::ValueCodecRegistry::Version() const</code>","text":"<p>Get the codec registry version.</p> <p>Returns: Version counter incremented on registration.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#texpected-void-snapigameframeworkvaluecodecregistryencodeconst-typeid-type-const-void-value-cerealbinaryoutputarchive-archive-const-tserializationcontext-context-const","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ValueCodecRegistry::Encode(const TypeId &amp;Type, const void *Value, cereal::BinaryOutputArchive &amp;Archive, const TSerializationContext &amp;Context) const</code>","text":"<p>Encode a value by type id.</p> <p>Parameters</p> <ul> <li><code>Type</code>: TypeId of the value.</li> <li><code>Value</code>: Pointer to the value.</li> <li><code>Archive</code>: Output archive.</li> <li><code>Context</code>: Serialization context.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#texpected-variant-snapigameframeworkvaluecodecregistrydecodeconst-typeid-type-cerealbinaryinputarchive-archive-const-tserializationcontext-context-const","title":"<code>TExpected&lt; Variant &gt; SnAPI::GameFramework::ValueCodecRegistry::Decode(const TypeId &amp;Type, cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context) const</code>","text":"<p>Decode a value by type id.</p> <p>Parameters</p> <ul> <li><code>Type</code>: TypeId of the value.</li> <li><code>Archive</code>: Input archive.</li> <li><code>Context</code>: Serialization context.</li> </ul> <p>Returns: Variant containing decoded value or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#texpected-void-snapigameframeworkvaluecodecregistrydecodeintoconst-typeid-type-void-value-cerealbinaryinputarchive-archive-const-tserializationcontext-context-const","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ValueCodecRegistry::DecodeInto(const TypeId &amp;Type, void *Value, cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context) const</code>","text":"<p>Decode a value by type id directly into memory.</p> <p>Parameters</p> <ul> <li><code>Type</code>: TypeId of the value.</li> <li><code>Value</code>: Output pointer.</li> <li><code>Archive</code>: Input archive.</li> <li><code>Context</code>: Serialization context.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#private-static-func","title":"Private Static Func","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#texpected-void-snapigameframeworkvaluecodecregistryencodeimplconst-void-value-cerealbinaryoutputarchive-archive-const-tserializationcontext-context","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ValueCodecRegistry::EncodeImpl(const void *Value, cereal::BinaryOutputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Template encoder implementation.</p> <p>Parameters</p> <ul> <li><code>Value</code>: </li> <li><code>Archive</code>: </li> <li><code>Context</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#texpected-variant-snapigameframeworkvaluecodecregistrydecodeimplcerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>TExpected&lt; Variant &gt; SnAPI::GameFramework::ValueCodecRegistry::DecodeImpl(cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Template decoder implementation.</p> <p>Parameters</p> <ul> <li><code>Archive</code>: </li> <li><code>Context</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1ValueCodecRegistry/#texpected-void-snapigameframeworkvaluecodecregistrydecodeintoimplvoid-value-cerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::ValueCodecRegistry::DecodeIntoImpl(void *Value, cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Template decode-into implementation.</p> <p>Parameters</p> <ul> <li><code>Value</code>: </li> <li><code>Archive</code>: </li> <li><code>Context</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/","title":"SnAPI::GameFramework::Variant","text":"<p>Type-erased value container used by reflection and scripting.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#typeid-snapigameframeworkvariantm_type","title":"<code>TypeId SnAPI::GameFramework::Variant::m_type</code>","text":"<p>Reflected type id of stored payload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#stdshared_ptrvoid-snapigameframeworkvariantm_storage","title":"<code>std::shared_ptr&lt;void&gt; SnAPI::GameFramework::Variant::m_storage</code>","text":"<p>Owned object storage or non-owning reference wrapper pointer.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#bool-snapigameframeworkvariantm_isref","title":"<code>bool SnAPI::GameFramework::Variant::m_isRef</code>","text":"<p>Reference mode flag (<code>true</code> for non-owning reference payload).</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#bool-snapigameframeworkvariantm_isconst","title":"<code>bool SnAPI::GameFramework::Variant::m_isConst</code>","text":"<p>Const-reference qualifier for reference mode payloads.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#snapigameframeworkvariantvariantdefault","title":"<code>SnAPI::GameFramework::Variant::Variant()=default</code>","text":"<p>Construct an empty (void) variant.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#const-typeid-snapigameframeworkvarianttype-const","title":"<code>const TypeId &amp; SnAPI::GameFramework::Variant::Type() const</code>","text":"<p>Get the stored type id.</p> <p>Returns: TypeId for the stored value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#bool-snapigameframeworkvariantisvoid-const","title":"<code>bool SnAPI::GameFramework::Variant::IsVoid() const</code>","text":"<p>Check whether this is a void variant.</p> <p>Returns: True if the variant represents void.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#bool-snapigameframeworkvariantisref-const","title":"<code>bool SnAPI::GameFramework::Variant::IsRef() const</code>","text":"<p>Check whether this variant stores a reference.</p> <p>Returns: True if it stores a reference; false if it owns the value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#bool-snapigameframeworkvariantisconst-const","title":"<code>bool SnAPI::GameFramework::Variant::IsConst() const</code>","text":"<p>Check whether a referenced value is const.</p> <p>Returns: True if reference is const.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#void-snapigameframeworkvariantborrowed","title":"<code>void * SnAPI::GameFramework::Variant::Borrowed()</code>","text":"<p>Borrow the underlying pointer (mutable).</p> <p>Returns: Pointer to stored value or reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#const-void-snapigameframeworkvariantborrowed-const","title":"<code>const void * SnAPI::GameFramework::Variant::Borrowed() const</code>","text":"<p>Borrow the underlying pointer (const).</p> <p>Returns: Pointer to stored value or reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#bool-snapigameframeworkvariantis-const","title":"<code>bool SnAPI::GameFramework::Variant::Is() const</code>","text":"<p>Type check helper.</p> <p>Returns: True if the stored type matches T.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#texpected-stdreference_wrapper-t-snapigameframeworkvariantasref","title":"<code>TExpected&lt; std::reference_wrapper&lt; T &gt; &gt; SnAPI::GameFramework::Variant::AsRef()</code>","text":"<p>Get a mutable reference to the stored value.</p> <p>Returns: Reference wrapper on success; error otherwise.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#texpected-stdreference_wrapper-const-t-snapigameframeworkvariantasconstref-const","title":"<code>TExpected&lt; std::reference_wrapper&lt; const T &gt; &gt; SnAPI::GameFramework::Variant::AsConstRef() const</code>","text":"<p>Get a const reference to the stored value.</p> <p>Returns: Const reference wrapper on success; error otherwise.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#static-variant-snapigameframeworkvariantvoid","title":"<code>static Variant SnAPI::GameFramework::Variant::Void()</code>","text":"<p>Create a void variant.</p> <p>Returns: Variant representing void.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#static-variant-snapigameframeworkvariantfromvaluet-value","title":"<code>static Variant SnAPI::GameFramework::Variant::FromValue(T Value)</code>","text":"<p>Create a variant that owns a value.</p> <p>Parameters</p> <ul> <li><code>Value</code>: Value to store (moved or copied).</li> </ul> <p>Returns: Variant owning the value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#static-variant-snapigameframeworkvariantfromreft-value","title":"<code>static Variant SnAPI::GameFramework::Variant::FromRef(T &amp;Value)</code>","text":"<p>Create a variant that references a mutable object.</p> <p>Parameters</p> <ul> <li><code>Value</code>: Reference to the object.</li> </ul> <p>Returns: Variant referencing the object.</p> <p>Notes</p> <ul> <li>Caller must guarantee lifetime; no ownership is transferred.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#static-variant-snapigameframeworkvariantfromconstrefconst-t-value","title":"<code>static Variant SnAPI::GameFramework::Variant::FromConstRef(const T &amp;Value)</code>","text":"<p>Create a variant that references a const object.</p> <p>Parameters</p> <ul> <li><code>Value</code>: Const reference to the object.</li> </ul> <p>Returns: Variant referencing the object as const.</p> <p>Notes</p> <ul> <li>Caller must guarantee lifetime; mutable extraction will fail by design.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#private-static-func","title":"Private Static Func","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#static-const-typeid-snapigameframeworkvariantvoidtypeid","title":"<code>static const TypeId &amp; SnAPI::GameFramework::Variant::VoidTypeId()</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1Variant/#static-const-typeid-snapigameframeworkvariantcachedtypeid","title":"<code>static const TypeId &amp; SnAPI::GameFramework::Variant::CachedTypeId()</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/","title":"SnAPI::GameFramework::VariantView","text":"<p>Non-owning view into a Variant-like value.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#typeid-snapigameframeworkvariantviewm_type","title":"<code>TypeId SnAPI::GameFramework::VariantView::m_type</code>","text":"<p>Reflected payload type id.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#const-void-snapigameframeworkvariantviewm_ptr","title":"<code>const void* SnAPI::GameFramework::VariantView::m_ptr</code>","text":"<p>Non-owning payload pointer.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#bool-snapigameframeworkvariantviewm_isconst","title":"<code>bool SnAPI::GameFramework::VariantView::m_isConst</code>","text":"<p>Constness gate for mutable borrowing.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#snapigameframeworkvariantviewvariantviewdefault","title":"<code>SnAPI::GameFramework::VariantView::VariantView()=default</code>","text":"<p>Construct an empty invalid view.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#snapigameframeworkvariantviewvariantviewtypeid-type-const-void-ptr-bool-isconst","title":"<code>SnAPI::GameFramework::VariantView::VariantView(TypeId Type, const void *Ptr, bool IsConst)</code>","text":"<p>Construct explicit typed view.</p> <p>Parameters</p> <ul> <li><code>Type</code>: </li> <li><code>Ptr</code>: Raw payload pointer.</li> <li><code>IsConst</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#const-typeid-snapigameframeworkvariantviewtype-const","title":"<code>const TypeId &amp; SnAPI::GameFramework::VariantView::Type() const</code>","text":"<p>Get reflected payload type id for this view.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#bool-snapigameframeworkvariantviewisconst-const","title":"<code>bool SnAPI::GameFramework::VariantView::IsConst() const</code>","text":"<p>Check if mutable access is disallowed.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#const-void-snapigameframeworkvariantviewborrowed-const","title":"<code>const void * SnAPI::GameFramework::VariantView::Borrowed() const</code>","text":"<p>Borrow const payload pointer.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1VariantView/#void-snapigameframeworkvariantviewborrowedmutable","title":"<code>void * SnAPI::GameFramework::VariantView::BorrowedMutable()</code>","text":"<p>Borrow mutable payload pointer.</p> <p>Returns: Mutable pointer when view is non-const, otherwise nullptr.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/","title":"SnAPI::GameFramework::World","text":"<p>Concrete world root that owns levels and subsystems.</p> <p>Responsibility boundaries: - world controls frame lifecycle and end-of-frame flush - levels are represented as child nodes/graphs under the world - nodes/components can query world context through <code>Owner()-&gt;World()</code></p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#const-char-snapigameframeworkworldktypename","title":"<code>const char* SnAPI::GameFramework::World::kTypeName</code>","text":"<p>Stable type name for reflection.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#jobsystem-snapigameframeworkworldm_jobsystem","title":"<code>JobSystem SnAPI::GameFramework::World::m_jobSystem</code>","text":"<p>World-scoped job dispatch facade for framework/runtime tasks.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#snapigameframeworkworldworld","title":"<code>SnAPI::GameFramework::World::World()</code>","text":"<p>Construct a world with default name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#snapigameframeworkworldworldstdstring-name","title":"<code>SnAPI::GameFramework::World::World(std::string Name)</code>","text":"<p>Construct a world with a name.</p> <p>Parameters</p> <ul> <li><code>Name</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#snapigameframeworkworldworld-override","title":"<code>SnAPI::GameFramework::World::~World() override</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#snapigameframeworkworldworldconst-world-delete","title":"<code>SnAPI::GameFramework::World::World(const World &amp;)=delete</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#world-snapigameframeworkworldoperatorconst-world-delete","title":"<code>World &amp; SnAPI::GameFramework::World::operator=(const World &amp;)=delete</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#snapigameframeworkworldworldworld-noexceptdefault","title":"<code>SnAPI::GameFramework::World::World(World &amp;&amp;) noexcept=default</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#world-snapigameframeworkworldoperatorworld-noexceptdefault","title":"<code>World &amp; SnAPI::GameFramework::World::operator=(World &amp;&amp;) noexcept=default</code>","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#void-snapigameframeworkworldtickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::World::Tick(float DeltaSeconds) override</code>","text":"<p>Per-frame tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#void-snapigameframeworkworldfixedtickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::World::FixedTick(float DeltaSeconds) override</code>","text":"<p>Fixed-step tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Fixed time step.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#void-snapigameframeworkworldlatetickfloat-deltaseconds-override","title":"<code>void SnAPI::GameFramework::World::LateTick(float DeltaSeconds) override</code>","text":"<p>Late tick.</p> <p>Parameters</p> <ul> <li><code>DeltaSeconds</code>: Time since last tick.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#void-snapigameframeworkworldendframe-override","title":"<code>void SnAPI::GameFramework::World::EndFrame() override</code>","text":"<p>End-of-frame processing.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#texpected-nodehandle-snapigameframeworkworldcreatelevelstdstring-name-override","title":"<code>TExpected&lt; NodeHandle &gt; SnAPI::GameFramework::World::CreateLevel(std::string Name) override</code>","text":"<p>Create a level as a child node.</p> <p>Parameters</p> <ul> <li><code>Name</code>: </li> </ul> <p>Returns: Handle to the created level or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#texpectedref-level-snapigameframeworkworldlevelrefnodehandle-handle-override","title":"<code>TExpectedRef&lt; Level &gt; SnAPI::GameFramework::World::LevelRef(NodeHandle Handle) override</code>","text":"<p>Access a level by handle.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: </li> </ul> <p>Returns: Reference wrapper or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#stdvector-nodehandle-snapigameframeworkworldlevels-const","title":"<code>std::vector&lt; NodeHandle &gt; SnAPI::GameFramework::World::Levels() const</code>","text":"<p>Get all level handles.</p> <p>Returns: Vector of level handles.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1World/#jobsystem-snapigameframeworkworldjobs","title":"<code>JobSystem &amp; SnAPI::GameFramework::World::Jobs()</code>","text":"<p>Access the job system for parallel internal tasks.</p> <p>Returns: Reference to JobSystem.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1WorldSerializer/","title":"SnAPI::GameFramework::WorldSerializer","text":"<p>Serializer for World to/from WorldPayload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1WorldSerializer/#public-static-members","title":"Public Static Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1WorldSerializer/#uint32_t-snapigameframeworkworldserializerkschemaversion","title":"<code>uint32_t SnAPI::GameFramework::WorldSerializer::kSchemaVersion</code>","text":"<p>Current schema version for World payloads.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1WorldSerializer/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1WorldSerializer/#texpected-worldpayload-snapigameframeworkworldserializerserializeconst-world-worldref","title":"<code>TExpected&lt; WorldPayload &gt; SnAPI::GameFramework::WorldSerializer::Serialize(const World &amp;WorldRef)</code>","text":"<p>Serialize a world to a payload.</p> <p>Parameters</p> <ul> <li><code>WorldRef</code>: Source world.</li> </ul> <p>Returns: Payload or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1WorldSerializer/#texpected-void-snapigameframeworkworldserializerdeserializeconst-worldpayload-payload-world-worldref","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::WorldSerializer::Deserialize(const WorldPayload &amp;Payload, World &amp;WorldRef)</code>","text":"<p>Deserialize a world from a payload.</p> <p>Parameters</p> <ul> <li><code>Payload</code>: Payload to read.</li> <li><code>WorldRef</code>: Destination world.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TLevelFactory/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TLevelFactory","text":"<p>AssetFactory for Level runtime objects.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TLevelFactory/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TLevelFactory/#snapiassetpipelinetypeid-snapigameframeworkanonymous_namespaceassetpipelinefactoriescpptlevelfactorygetcookedpayloadtype-const-override","title":"<code>::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TLevelFactory::GetCookedPayloadType() const override</code>","text":"<p>Get the cooked payload type handled by this factory.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TLevelFactory/#protected-functions","title":"Protected Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TLevelFactory/#stdexpected-level-stdstring-snapigameframeworkanonymous_namespaceassetpipelinefactoriescpptlevelfactorydoloadconst-snapiassetpipelineassetloadcontext-context-override","title":"<code>std::expected&lt; Level, std::string &gt; SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TLevelFactory::DoLoad(const ::SnAPI::AssetPipeline::AssetLoadContext &amp;Context) override</code>","text":"<p>Load a Level from cooked data.</p> <p>Parameters</p> <ul> <li><code>Context</code>: Asset load context.</li> </ul> <p>Returns: Loaded Level or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TNodeGraphFactory/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TNodeGraphFactory","text":"<p>AssetFactory for NodeGraph runtime objects.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TNodeGraphFactory/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TNodeGraphFactory/#snapiassetpipelinetypeid-snapigameframeworkanonymous_namespaceassetpipelinefactoriescpptnodegraphfactorygetcookedpayloadtype-const-override","title":"<code>::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TNodeGraphFactory::GetCookedPayloadType() const override</code>","text":"<p>Get the cooked payload type handled by this factory.</p> <p>Returns: Payload TypeId.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TNodeGraphFactory/#protected-functions","title":"Protected Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TNodeGraphFactory/#stdexpected-nodegraph-stdstring-snapigameframeworkanonymous_namespaceassetpipelinefactoriescpptnodegraphfactorydoloadconst-snapiassetpipelineassetloadcontext-context-override","title":"<code>std::expected&lt; NodeGraph, std::string &gt; SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TNodeGraphFactory::DoLoad(const ::SnAPI::AssetPipeline::AssetLoadContext &amp;Context) override</code>","text":"<p>Load a NodeGraph from cooked data.</p> <p>Parameters</p> <ul> <li><code>Context</code>: Asset load context.</li> </ul> <p>Returns: Loaded NodeGraph or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TWorldFactory/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TWorldFactory","text":"<p>AssetFactory for World runtime objects.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TWorldFactory/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TWorldFactory/#snapiassetpipelinetypeid-snapigameframeworkanonymous_namespaceassetpipelinefactoriescpptworldfactorygetcookedpayloadtype-const-override","title":"<code>::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TWorldFactory::GetCookedPayloadType() const override</code>","text":"<p>Get the cooked payload type handled by this factory.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TWorldFactory/#protected-functions","title":"Protected Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03_1_1TWorldFactory/#stdexpected-world-stdstring-snapigameframeworkanonymous_namespaceassetpipelinefactoriescpptworldfactorydoloadconst-snapiassetpipelineassetloadcontext-context-override","title":"<code>std::expected&lt; World, std::string &gt; SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TWorldFactory::DoLoad(const ::SnAPI::AssetPipeline::AssetLoadContext &amp;Context) override</code>","text":"<p>Load a World from cooked data.</p> <p>Parameters</p> <ul> <li><code>Context</code>: Asset load context.</li> </ul> <p>Returns: Loaded World or error.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1LevelPayloadSerializer/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer","text":"<p>AssetPipeline serializer for LevelPayload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1LevelPayloadSerializer/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1LevelPayloadSerializer/#snapiassetpipelinetypeid-snapigameframeworkanonymous_namespaceassetpipelineserializerscpplevelpayloadserializergettypeid-const-override","title":"<code>::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer::GetTypeId() const override</code>","text":"<p>Get the payload type id.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1LevelPayloadSerializer/#const-char-snapigameframeworkanonymous_namespaceassetpipelineserializerscpplevelpayloadserializergettypename-const-override","title":"<code>const char * SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer::GetTypeName() const override</code>","text":"<p>Get the payload type name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1LevelPayloadSerializer/#uint32_t-snapigameframeworkanonymous_namespaceassetpipelineserializerscpplevelpayloadserializergetschemaversion-const-override","title":"<code>uint32_t SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer::GetSchemaVersion() const override</code>","text":"<p>Get the payload schema version.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1LevelPayloadSerializer/#void-snapigameframeworkanonymous_namespaceassetpipelineserializerscpplevelpayloadserializerserializetobytesconst-void-object-stdvector-uint8_t-outbytes-const-override","title":"<code>void SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer::SerializeToBytes(const void *Object, std::vector&lt; uint8_t &gt; &amp;OutBytes) const override</code>","text":"<p>Serialize a LevelPayload into bytes.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Pointer to LevelPayload.</li> <li><code>OutBytes</code>: Output byte buffer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1LevelPayloadSerializer/#bool-snapigameframeworkanonymous_namespaceassetpipelineserializerscpplevelpayloadserializerdeserializefrombytesvoid-object-const-uint8_t-bytes-stdsize_t-size-const-override","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer::DeserializeFromBytes(void *Object, const uint8_t *Bytes, std::size_t Size) const override</code>","text":"<p>Deserialize a LevelPayload from bytes.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Pointer to destination payload.</li> <li><code>Bytes</code>: Byte buffer.</li> <li><code>Size</code>: Byte count.</li> </ul> <p>Returns: True on success.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1NodeGraphPayloadSerializer/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer","text":"<p>AssetPipeline serializer for NodeGraphPayload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1NodeGraphPayloadSerializer/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1NodeGraphPayloadSerializer/#snapiassetpipelinetypeid-snapigameframeworkanonymous_namespaceassetpipelineserializerscppnodegraphpayloadserializergettypeid-const-override","title":"<code>::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer::GetTypeId() const override</code>","text":"<p>Get the payload type id.</p> <p>Returns: Payload type id for NodeGraph.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1NodeGraphPayloadSerializer/#const-char-snapigameframeworkanonymous_namespaceassetpipelineserializerscppnodegraphpayloadserializergettypename-const-override","title":"<code>const char * SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer::GetTypeName() const override</code>","text":"<p>Get the payload type name.</p> <p>Returns: Payload type name string.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1NodeGraphPayloadSerializer/#uint32_t-snapigameframeworkanonymous_namespaceassetpipelineserializerscppnodegraphpayloadserializergetschemaversion-const-override","title":"<code>uint32_t SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer::GetSchemaVersion() const override</code>","text":"<p>Get the payload schema version.</p> <p>Returns: Schema version for NodeGraph payloads.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1NodeGraphPayloadSerializer/#void-snapigameframeworkanonymous_namespaceassetpipelineserializerscppnodegraphpayloadserializerserializetobytesconst-void-object-stdvector-uint8_t-outbytes-const-override","title":"<code>void SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer::SerializeToBytes(const void *Object, std::vector&lt; uint8_t &gt; &amp;OutBytes) const override</code>","text":"<p>Serialize a NodeGraphPayload into bytes.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Pointer to NodeGraphPayload.</li> <li><code>OutBytes</code>: Output byte buffer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1NodeGraphPayloadSerializer/#bool-snapigameframeworkanonymous_namespaceassetpipelineserializerscppnodegraphpayloadserializerdeserializefrombytesvoid-object-const-uint8_t-bytes-stdsize_t-size-const-override","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer::DeserializeFromBytes(void *Object, const uint8_t *Bytes, std::size_t Size) const override</code>","text":"<p>Deserialize a NodeGraphPayload from bytes.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Pointer to destination payload.</li> <li><code>Bytes</code>: Byte buffer.</li> <li><code>Size</code>: Byte count.</li> </ul> <p>Returns: True on success.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1WorldPayloadSerializer/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer","text":"<p>AssetPipeline serializer for WorldPayload.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1WorldPayloadSerializer/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1WorldPayloadSerializer/#snapiassetpipelinetypeid-snapigameframeworkanonymous_namespaceassetpipelineserializerscppworldpayloadserializergettypeid-const-override","title":"<code>::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer::GetTypeId() const override</code>","text":"<p>Get the payload type id.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1WorldPayloadSerializer/#const-char-snapigameframeworkanonymous_namespaceassetpipelineserializerscppworldpayloadserializergettypename-const-override","title":"<code>const char * SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer::GetTypeName() const override</code>","text":"<p>Get the payload type name.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1WorldPayloadSerializer/#uint32_t-snapigameframeworkanonymous_namespaceassetpipelineserializerscppworldpayloadserializergetschemaversion-const-override","title":"<code>uint32_t SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer::GetSchemaVersion() const override</code>","text":"<p>Get the payload schema version.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1WorldPayloadSerializer/#void-snapigameframeworkanonymous_namespaceassetpipelineserializerscppworldpayloadserializerserializetobytesconst-void-object-stdvector-uint8_t-outbytes-const-override","title":"<code>void SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer::SerializeToBytes(const void *Object, std::vector&lt; uint8_t &gt; &amp;OutBytes) const override</code>","text":"<p>Serialize a WorldPayload into bytes.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Pointer to WorldPayload.</li> <li><code>OutBytes</code>: Output byte buffer.</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03_1_1WorldPayloadSerializer/#bool-snapigameframeworkanonymous_namespaceassetpipelineserializerscppworldpayloadserializerdeserializefrombytesvoid-object-const-uint8_t-bytes-stdsize_t-size-const-override","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer::DeserializeFromBytes(void *Object, const uint8_t *Bytes, std::size_t Size) const override</code>","text":"<p>Deserialize a WorldPayload from bytes.</p> <p>Parameters</p> <ul> <li><code>Object</code>: Pointer to destination payload.</li> <li><code>Bytes</code>: Byte buffer.</li> <li><code>Size</code>: Byte count.</li> </ul> <p>Returns: True on success.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1MemoryReadStreambuf/","title":"SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::MemoryReadStreambuf","text":"<p>Streambuf adapter exposing immutable memory as input stream.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1MemoryReadStreambuf/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1MemoryReadStreambuf/#snapigameframeworkanonymous_namespaceserializationcppmemoryreadstreambufmemoryreadstreambufconst-uint8_t-data-size_t-size","title":"<code>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::MemoryReadStreambuf::MemoryReadStreambuf(const uint8_t *Data, size_t Size)</code>","text":"<p>Parameters</p> <ul> <li><code>Data</code>: </li> <li><code>Size</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/","title":"SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf","text":"<p>Streambuf that appends cereal output bytes directly into a vector.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/#private-members","title":"Private Members","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/#stdvectoruint8_t-snapigameframeworkanonymous_namespaceserializationcppvectorwritestreambufm_buffer","title":"<code>std::vector&lt;uint8_t&gt;&amp; SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf::m_buffer</code>","text":"<p>Destination byte vector reference.</p>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/#public-functions","title":"Public Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/#snapigameframeworkanonymous_namespaceserializationcppvectorwritestreambufvectorwritestreambufstdvector-uint8_t-buffer","title":"<code>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf::VectorWriteStreambuf(std::vector&lt; uint8_t &gt; &amp;Buffer)</code>","text":"<p>Parameters</p> <ul> <li><code>Buffer</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/#protected-functions","title":"Protected Functions","text":""},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/#int_type-snapigameframeworkanonymous_namespaceserializationcppvectorwritestreambufoverflowint_type-ch-override","title":"<code>int_type SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf::overflow(int_type Ch) override</code>","text":"<p>Parameters</p> <ul> <li><code>Ch</code>:</li> </ul>"},{"location":"api/classSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1VectorWriteStreambuf/#stdstreamsize-snapigameframeworkanonymous_namespaceserializationcppvectorwritestreambufxsputnconst-char-data-stdstreamsize-count-override","title":"<code>std::streamsize SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf::xsputn(const char *Data, std::streamsize Count) override</code>","text":"<p>Parameters</p> <ul> <li><code>Data</code>: </li> <li><code>Count</code>:</li> </ul>"},{"location":"api/files/","title":"Files","text":"<ul> <li>Assert.h</li> <li>AssetPipelineFactories.cpp</li> <li>AssetPipelineFactories.h</li> <li>AssetPipelineIds.h</li> <li>AssetPipelinePlugin.cpp</li> <li>AssetPipelineSerializers.cpp</li> <li>AssetPipelineSerializers.h</li> <li>AudioListenerComponent.cpp</li> <li>AudioListenerComponent.h</li> <li>AudioSourceComponent.cpp</li> <li>AudioSourceComponent.h</li> <li>AudioSystem.cpp</li> <li>AudioSystem.h</li> <li>BaseNode.cpp</li> <li>BaseNode.h</li> <li>BuiltinTypes.h</li> <li>CameraComponent.cpp</li> <li>CameraComponent.h</li> <li>CharacterMovementController.cpp</li> <li>CharacterMovementController.h</li> <li>ColliderComponent.cpp</li> <li>ColliderComponent.h</li> <li>CollisionFilters.h</li> <li>ComponentStorage.h</li> <li>Expected.h</li> <li>Export.h</li> <li>Flags.h</li> <li>GameFramework.cpp</li> <li>GameFramework.hpp</li> <li>GameRuntime.cpp</li> <li>GameRuntime.h</li> <li>Handle.h</li> <li>HandleFwd.h</li> <li>Handles.h</li> <li>IComponent.cpp</li> <li>IComponent.h</li> <li>ILevel.h</li> <li>INode.cpp</li> <li>INode.h</li> <li>IWorld.h</li> <li>Invoker.h</li> <li>JobSystem.h</li> <li>Level.cpp</li> <li>Level.h</li> <li>Math.h</li> <li>NetReplication.cpp</li> <li>NetReplication.h</li> <li>NetRpc.cpp</li> <li>NetRpc.h</li> <li>NetworkSystem.cpp</li> <li>NetworkSystem.h</li> <li>NodeGraph.cpp</li> <li>NodeGraph.h</li> <li>ObjectPool.h</li> <li>ObjectRegistry.h</li> <li>PhysicsSystem.cpp</li> <li>PhysicsSystem.h</li> <li>Profiling.h</li> <li>Reflection.h</li> <li>Relevance.h</li> <li>RendererSystem.cpp</li> <li>RendererSystem.h</li> <li>RigidBodyComponent.cpp</li> <li>RigidBodyComponent.h</li> <li>ScriptABI.cpp</li> <li>ScriptABI.h</li> <li>ScriptBindings.h</li> <li>ScriptComponent.h</li> <li>ScriptEngine.h</li> <li>Serialization.cpp</li> <li>Serialization.h</li> <li>SkeletalMeshComponent.cpp</li> <li>SkeletalMeshComponent.h</li> <li>StaticMeshComponent.cpp</li> <li>StaticMeshComponent.h</li> <li>StaticTypeId.h</li> <li>TransformComponent.h</li> <li>TypeAutoRegistration.h</li> <li>TypeAutoRegistry.cpp</li> <li>TypeAutoRegistry.h</li> <li>TypeBuilder.h</li> <li>TypeName.h</li> <li>TypeRegistration.h</li> <li>TypeRegistry.cpp</li> <li>TypeRegistry.h</li> <li>Uuid.h</li> <li>Variant.h</li> <li>World.cpp</li> <li>World.h</li> <li>main.cpp</li> <li>main.cpp</li> <li>main.cpp</li> </ul>"},{"location":"api/namespaceSnAPI/","title":"SnAPI","text":""},{"location":"api/namespaceSnAPI/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI::GameFramework</li> <li>Namespace: SnAPI::AssetPipeline</li> </ul>"},{"location":"api/namespaceSnAPI_1_1AssetPipeline/","title":"SnAPI::AssetPipeline","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/","title":"SnAPI::GameFramework","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#contents","title":"Contents","text":"<ul> <li>Namespace: SnAPI::GameFramework::detail</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{INode.cpp}</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}</li> <li>Namespace: SnAPI::GameFramework::anonymous_namespace{TypeRegistry.cpp}</li> <li>Type: SnAPI::GameFramework::BaseNode</li> <li>Type: SnAPI::GameFramework::ComponentTypeRegistry</li> <li>Type: SnAPI::GameFramework::IComponentStorage</li> <li>Type: SnAPI::GameFramework::TComponentStorage</li> <li>Type: SnAPI::GameFramework::Error</li> <li>Type: SnAPI::GameFramework::TExpectedRef</li> <li>Type: SnAPI::GameFramework::TFlags</li> <li>Type: SnAPI::GameFramework::EnableFlags</li> <li>Type: SnAPI::GameFramework::GameRuntimeTickSettings</li> <li>Type: SnAPI::GameFramework::GameRuntimeSettings</li> <li>Type: SnAPI::GameFramework::GameRuntime</li> <li>Type: SnAPI::GameFramework::THandle</li> <li>Type: SnAPI::GameFramework::HandleHash</li> <li>Type: SnAPI::GameFramework::IComponent</li> <li>Type: SnAPI::GameFramework::ILevel</li> <li>Type: SnAPI::GameFramework::INode</li> <li>Type: SnAPI::GameFramework::IWorld</li> <li>Type: SnAPI::GameFramework::JobSystem</li> <li>Type: SnAPI::GameFramework::Level</li> <li>Type: SnAPI::GameFramework::NodeGraph</li> <li>Type: SnAPI::GameFramework::TObjectPool</li> <li>Type: SnAPI::GameFramework::ObjectRegistry</li> <li>Type: SnAPI::GameFramework::RelevanceContext</li> <li>Type: SnAPI::GameFramework::RelevancePolicyRegistry</li> <li>Type: SnAPI::GameFramework::RelevanceComponent</li> <li>Type: SnAPI::GameFramework::ScriptBindings</li> <li>Type: SnAPI::GameFramework::ScriptComponent</li> <li>Type: SnAPI::GameFramework::IScriptEngine</li> <li>Type: SnAPI::GameFramework::ScriptRuntime</li> <li>Type: SnAPI::GameFramework::TSerializationContext</li> <li>Type: SnAPI::GameFramework::TValueCodec</li> <li>Type: SnAPI::GameFramework::ValueCodecRegistry</li> <li>Type: SnAPI::GameFramework::ComponentSerializationRegistry</li> <li>Type: SnAPI::GameFramework::NodeComponentPayload</li> <li>Type: SnAPI::GameFramework::NodePayload</li> <li>Type: SnAPI::GameFramework::NodeGraphPayload</li> <li>Type: SnAPI::GameFramework::LevelPayload</li> <li>Type: SnAPI::GameFramework::WorldPayload</li> <li>Type: SnAPI::GameFramework::NodeGraphSerializer</li> <li>Type: SnAPI::GameFramework::LevelSerializer</li> <li>Type: SnAPI::GameFramework::WorldSerializer</li> <li>Type: SnAPI::GameFramework::TransformComponent</li> <li>Type: SnAPI::GameFramework::TTypeRegistrar</li> <li>Type: SnAPI::GameFramework::TypeAutoRegistry</li> <li>Type: SnAPI::GameFramework::TTypeBuilder</li> <li>Type: SnAPI::GameFramework::TTypeName</li> <li>Type: SnAPI::GameFramework::TransparentStringHash</li> <li>Type: SnAPI::GameFramework::TransparentStringEqual</li> <li>Type: SnAPI::GameFramework::EnableFlags&lt; EFieldFlagBits &gt;</li> <li>Type: SnAPI::GameFramework::EnableFlags&lt; EMethodFlagBits &gt;</li> <li>Type: SnAPI::GameFramework::FieldInfo</li> <li>Type: SnAPI::GameFramework::MethodInfo</li> <li>Type: SnAPI::GameFramework::ConstructorInfo</li> <li>Type: SnAPI::GameFramework::TypeInfo</li> <li>Type: SnAPI::GameFramework::TypeRegistry</li> <li>Type: SnAPI::GameFramework::UuidParts</li> <li>Type: SnAPI::GameFramework::UuidHash</li> <li>Type: SnAPI::GameFramework::Variant</li> <li>Type: SnAPI::GameFramework::VariantView</li> <li>Type: SnAPI::GameFramework::World</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#enumerations","title":"Enumerations","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#enum-eerrorcode","title":"<code>enum EErrorCode</code>","text":"<p>Canonical error codes used by the framework.</p> <p>Values</p> <ul> <li><code>None</code>: No error.</li> <li><code>NotFound</code>: Requested item was not found.</li> <li><code>InvalidArgument</code>: One or more arguments are invalid.</li> <li><code>TypeMismatch</code>: Type mismatch or unsafe conversion.</li> <li><code>OutOfRange</code>: Index or value is out of range.</li> <li><code>AlreadyExists</code>: Attempted to create an object that already exists.</li> <li><code>NotReady</code>: Subsystem or object is not ready.</li> <li><code>InternalError</code>: Unexpected internal failure.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#enum-eobjectkind","title":"<code>enum EObjectKind</code>","text":"<p>Kind of object stored in the registry.</p> <p>Values</p> <ul> <li><code>Node</code>: BaseNode-derived object.</li> <li><code>Component</code>: IComponent-derived object.</li> <li><code>Other</code>: Arbitrary registered type.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#enum-efieldflagbits","title":"<code>enum EFieldFlagBits</code>","text":"<p>Field-level flags for reflection metadata.</p> <p>Values</p> <ul> <li><code>None</code>: No special field behavior flags.</li> <li><code>Replication</code>: Field is eligible for replication payload traversal.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#enum-emethodflagbits","title":"<code>enum EMethodFlagBits</code>","text":"<p>Method-level flags for reflection metadata.</p> <p>Values</p> <ul> <li><code>None</code>: No special method behavior flags.</li> <li><code>RpcReliable</code>: Prefer reliable transport channel for RPC dispatch.</li> <li><code>RpcUnreliable</code>: Prefer unreliable transport channel for RPC dispatch.</li> <li><code>RpcNetServer</code>: Method is intended as server-target endpoint.</li> <li><code>RpcNetClient</code>: Method is intended as client-target endpoint.</li> <li><code>RpcNetMulticast</code>: Method is intended for server-initiated multicast dispatch.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#type-aliases","title":"Type Aliases","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworktexpected-stdexpectedt-error","title":"<code>using SnAPI::GameFramework::TExpected = std::expected&lt;T, Error&gt;</code>","text":"<p>Convenience alias for std::expected with framework Error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkresult-texpectedvoid","title":"<code>using SnAPI::GameFramework::Result = TExpected&lt;void&gt;</code>","text":"<p>Convenience alias for operations returning only success/failure.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#typedef-thandle-basenode-snapigameframeworknodehandle-thandlebasenode","title":"<code>typedef THandle&lt; BaseNode &gt; SnAPI::GameFramework::NodeHandle = THandle&lt;BaseNode&gt;</code>","text":"<p>Handle type for nodes.</p> <p>Handle type for nodes (local alias).</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkcomponenthandle-thandleicomponent","title":"<code>using SnAPI::GameFramework::ComponentHandle = THandle&lt;IComponent&gt;</code>","text":"<p>Handle type for components.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkmethodinvoker-stdfunctiontexpectedvariantvoid-instance-stdspanconst-variant-args","title":"<code>using SnAPI::GameFramework::MethodInvoker = std::function&lt;TExpected&lt;Variant&gt;(void* Instance, std::span&lt;const Variant&gt; Args)&gt;</code>","text":"<p>Function type for reflected method invocation.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkscalar-snapimathscalar","title":"<code>using SnAPI::GameFramework::Scalar = SnAPI::Math::Scalar</code>","text":"<p>Canonical scalar type used by GameFramework math aliases.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkvec3-snapimathvec3","title":"<code>using SnAPI::GameFramework::Vec3 = SnAPI::Math::Vec3</code>","text":"<p>Canonical 3D vector type used across runtime and serialization.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkquat-snapimathquat","title":"<code>using SnAPI::GameFramework::Quat = SnAPI::Math::Quat</code>","text":"<p>Canonical quaternion type used for interop with systems that need quaternion rotation.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworktransform-snapimathtransform","title":"<code>using SnAPI::GameFramework::Transform = SnAPI::Math::Transform</code>","text":"<p>Canonical transform type (position + quaternion rotation).</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkaabb-snapimathaabb","title":"<code>using SnAPI::GameFramework::Aabb = SnAPI::Math::Aabb</code>","text":"<p>Canonical AABB type.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkscriptinstanceid-uint64_t","title":"<code>using SnAPI::GameFramework::ScriptInstanceId = uint64_t</code>","text":"<p>Unique identifier for a script instance.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkttyperegisterfn-void","title":"<code>using SnAPI::GameFramework::TTypeRegisterFn = void(*)()</code>","text":"<p>Auto-registration helpers for reflection and serialization.</p> <p>Usage (place in a single .cpp per type to avoid duplicate registration): SNAPI_REFLECT_TYPE(MyType, (TTypeBuilder(MyType::kTypeName) .Base() .Field(\"Health\", &amp;MyType::m_health) .Constructor&lt;&gt;() .Register())); <p>SNAPI_REFLECT_COMPONENT(MyComponent, (TTypeBuilder(MyComponent::kTypeName) .Field(\"Speed\", &amp;MyComponent::m_speed) .Constructor&lt;&gt;() .Register())); <p>The builder expression should register the type with TypeRegistry. If a node must be created by TypeId (serialization, scripting), register a default constructor. Types are registered lazily: the macro installs an \"ensure\" callback keyed by deterministic TypeId. The actual TypeRegistry registration is performed on first use (TypeRegistry::Find on miss, or explicit TypeAutoRegistry::Ensure).</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkfieldflags-tflagsefieldflagbits","title":"<code>using SnAPI::GameFramework::FieldFlags = TFlags&lt;EFieldFlagBits&gt;</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkmethodflags-tflagsemethodflagbits","title":"<code>using SnAPI::GameFramework::MethodFlags = TFlags&lt;EMethodFlagBits&gt;</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworkuuid-uuidsuuid","title":"<code>using SnAPI::GameFramework::Uuid = uuids::uuid</code>","text":"<p>UUID type used throughout the framework.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#using-snapigameframeworktypeid-uuid","title":"<code>using SnAPI::GameFramework::TypeId = Uuid</code>","text":"<p>Strong alias for TypeId values.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#variables","title":"Variables","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-char-snapigameframeworkkassetkindnodegraphname","title":"<code>const char* SnAPI::GameFramework::kAssetKindNodeGraphName</code>","text":"<p>Asset kind name for NodeGraph assets.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-char-snapigameframeworkkassetkindlevelname","title":"<code>const char* SnAPI::GameFramework::kAssetKindLevelName</code>","text":"<p>Asset kind name for Level assets.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-char-snapigameframeworkkassetkindworldname","title":"<code>const char* SnAPI::GameFramework::kAssetKindWorldName</code>","text":"<p>Asset kind name for World assets.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-char-snapigameframeworkkpayloadnodegraphname","title":"<code>const char* SnAPI::GameFramework::kPayloadNodeGraphName</code>","text":"<p>Payload type name for NodeGraph cooked data.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-char-snapigameframeworkkpayloadlevelname","title":"<code>const char* SnAPI::GameFramework::kPayloadLevelName</code>","text":"<p>Payload type name for Level cooked data.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-char-snapigameframeworkkpayloadworldname","title":"<code>const char* SnAPI::GameFramework::kPayloadWorldName</code>","text":"<p>Payload type name for World cooked data.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#bool-snapigameframeworkenableflagsv","title":"<code>bool SnAPI::GameFramework::EnableFlagsV</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-char-snapigameframeworkttypenamev","title":"<code>const char* SnAPI::GameFramework::TTypeNameV</code>","text":"<p>Convenience alias for TTypeName::Value."},{"location":"api/namespaceSnAPI_1_1GameFramework/#functions","title":"Functions","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkregisterassetpipelinepayloadssnapiassetpipelinepayloadregistry-registry","title":"<code>void SnAPI::GameFramework::RegisterAssetPipelinePayloads(::SnAPI::AssetPipeline::PayloadRegistry &amp;Registry)</code>","text":"<p>Register GameFramework payload serializers with the AssetPipeline registry.</p> <p>Parameters</p> <ul> <li><code>Registry</code>: Payload registry.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkregisterassetpipelinefactoriessnapiassetpipelineassetmanager-manager","title":"<code>void SnAPI::GameFramework::RegisterAssetPipelineFactories(::SnAPI::AssetPipeline::AssetManager &amp;Manager)</code>","text":"<p>Register GameFramework runtime factories with the AssetManager.</p> <p>Parameters</p> <ul> <li><code>Manager</code>: Asset manager.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelineuuid-snapigameframeworkassetpipelinenamespace","title":"<code>inline ::SnAPI::AssetPipeline::Uuid SnAPI::GameFramework::AssetPipelineNamespace()</code>","text":"<p>Namespace UUID for AssetPipeline ids.</p> <p>Returns: Namespace UUID.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelinetypeid-snapigameframeworkassetpipelinetypeidfromnamestdstring_view-name","title":"<code>inline ::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::AssetPipelineTypeIdFromName(std::string_view Name)</code>","text":"<p>Generate a deterministic TypeId from a name.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Name string.</li> </ul> <p>Returns: UUIDv5-based TypeId.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelineassetid-snapigameframeworkassetpipelineassetidfromnamestdstring_view-name","title":"<code>inline ::SnAPI::AssetPipeline::AssetId SnAPI::GameFramework::AssetPipelineAssetIdFromName(std::string_view Name)</code>","text":"<p>Generate a deterministic AssetId from a name.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Name string.</li> </ul> <p>Returns: UUIDv5-based AssetId.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelinetypeid-snapigameframeworkassetkindnodegraph","title":"<code>inline ::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::AssetKindNodeGraph()</code>","text":"<p>Get the AssetPipeline TypeId for NodeGraph assets.</p> <p>Returns: TypeId value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelinetypeid-snapigameframeworkassetkindlevel","title":"<code>inline ::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::AssetKindLevel()</code>","text":"<p>Get the AssetPipeline TypeId for Level assets.</p> <p>Returns: TypeId value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelinetypeid-snapigameframeworkassetkindworld","title":"<code>inline ::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::AssetKindWorld()</code>","text":"<p>Get the AssetPipeline TypeId for World assets.</p> <p>Returns: TypeId value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelinetypeid-snapigameframeworkpayloadnodegraph","title":"<code>inline ::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::PayloadNodeGraph()</code>","text":"<p>Get the payload TypeId for NodeGraph payloads.</p> <p>Returns: TypeId value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelinetypeid-snapigameframeworkpayloadlevel","title":"<code>inline ::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::PayloadLevel()</code>","text":"<p>Get the payload TypeId for Level payloads.</p> <p>Returns: TypeId value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#inline-snapiassetpipelinetypeid-snapigameframeworkpayloadworld","title":"<code>inline ::SnAPI::AssetPipeline::TypeId SnAPI::GameFramework::PayloadWorld()</code>","text":"<p>Get the payload TypeId for World payloads.</p> <p>Returns: TypeId value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#stdunique_ptrsnapiassetpipelineipayloadserializer-snapigameframeworkcreatenodegraphpayloadserializer","title":"<code>std::unique_ptr&lt;::SnAPI::AssetPipeline::IPayloadSerializer &gt; SnAPI::GameFramework::CreateNodeGraphPayloadSerializer()</code>","text":"<p>Create the payload serializer for NodeGraph cooked data.</p> <p>Create the NodeGraph payload serializer.</p> <p>Returns: Serializer instance.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#stdunique_ptrsnapiassetpipelineipayloadserializer-snapigameframeworkcreatelevelpayloadserializer","title":"<code>std::unique_ptr&lt;::SnAPI::AssetPipeline::IPayloadSerializer &gt; SnAPI::GameFramework::CreateLevelPayloadSerializer()</code>","text":"<p>Create the payload serializer for Level cooked data.</p> <p>Create the Level payload serializer.</p> <p>Returns: Serializer instance.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#stdunique_ptrsnapiassetpipelineipayloadserializer-snapigameframeworkcreateworldpayloadserializer","title":"<code>std::unique_ptr&lt;::SnAPI::AssetPipeline::IPayloadSerializer &gt; SnAPI::GameFramework::CreateWorldPayloadSerializer()</code>","text":"<p>Create the payload serializer for World cooked data.</p> <p>Create the World payload serializer.</p> <p>Returns: Serializer instance.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#result-snapigameframeworkok","title":"<code>Result SnAPI::GameFramework::Ok()</code>","text":"<p>Construct a success Result.</p> <p>Returns: Result with no error.</p> <p>Notes</p> <ul> <li>Use for functions returning Result.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#error-snapigameframeworkmakeerroreerrorcode-code-stdstring-message","title":"<code>Error SnAPI::GameFramework::MakeError(EErrorCode Code, std::string Message)</code>","text":"<p>Construct an Error value.</p> <p>Parameters</p> <ul> <li><code>Code</code>: Error category.</li> <li><code>Message</code>: Diagnostic message.</li> </ul> <p>Returns: Error instance with the provided data.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#stdenable_if_t-enableflagsv-enum-tflags-enum-snapigameframeworkoperatorenum-left-enum-right","title":"<code>std::enable_if_t&lt; EnableFlagsV&lt; Enum &gt;, TFlags&lt; Enum &gt; &gt; SnAPI::GameFramework::operator|(Enum Left, Enum Right)</code>","text":"<p>Combine two enum flag bits into a TFlags value.</p> <p>Parameters</p> <ul> <li><code>Left</code>: </li> <li><code>Right</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#stdenable_if_t-enableflagsv-enum-tflags-enum-snapigameframeworkoperatorenum-left-enum-right_1","title":"<code>std::enable_if_t&lt; EnableFlagsV&lt; Enum &gt;, TFlags&lt; Enum &gt; &gt; SnAPI::GameFramework::operator&amp;(Enum Left, Enum Right)</code>","text":"<p>Intersect two enum flag bits into a TFlags value.</p> <p>Parameters</p> <ul> <li><code>Left</code>: </li> <li><code>Right</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#methodinvoker-snapigameframeworkmakeinvokerrtmethodargs","title":"<code>MethodInvoker SnAPI::GameFramework::MakeInvoker(R(T::*Method)(Args...))</code>","text":"<p>Create a MethodInvoker for a non-const member function.</p> <p>Create a MethodInvoker for a const member function.</p> <p>Parameters</p> <ul> <li><code>Method</code>: Const member function pointer.</li> </ul> <p>Returns: Callable MethodInvoker.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#texpected-void-snapigameframeworkserializenodegraphpayloadconst-nodegraphpayload-payload-stdvector-uint8_t-outbytes","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::SerializeNodeGraphPayload(const NodeGraphPayload &amp;Payload, std::vector&lt; uint8_t &gt; &amp;OutBytes)</code>","text":"<p>Serialize a NodeGraphPayload to bytes.</p> <p>Parameters</p> <ul> <li><code>Payload</code>: Payload to serialize.</li> <li><code>OutBytes</code>: Output byte vector.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#texpected-nodegraphpayload-snapigameframeworkdeserializenodegraphpayloadconst-uint8_t-bytes-size_t-size","title":"<code>TExpected&lt; NodeGraphPayload &gt; SnAPI::GameFramework::DeserializeNodeGraphPayload(const uint8_t *Bytes, size_t Size)</code>","text":"<p>Deserialize a NodeGraphPayload from bytes.</p> <p>Parameters</p> <ul> <li><code>Bytes</code>: Byte buffer.</li> <li><code>Size</code>: Byte count.</li> </ul> <p>Returns: Payload or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#texpected-void-snapigameframeworkserializelevelpayloadconst-levelpayload-payload-stdvector-uint8_t-outbytes","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::SerializeLevelPayload(const LevelPayload &amp;Payload, std::vector&lt; uint8_t &gt; &amp;OutBytes)</code>","text":"<p>Serialize a LevelPayload to bytes.</p> <p>Parameters</p> <ul> <li><code>Payload</code>: Payload to serialize.</li> <li><code>OutBytes</code>: Output byte vector.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#texpected-levelpayload-snapigameframeworkdeserializelevelpayloadconst-uint8_t-bytes-size_t-size","title":"<code>TExpected&lt; LevelPayload &gt; SnAPI::GameFramework::DeserializeLevelPayload(const uint8_t *Bytes, size_t Size)</code>","text":"<p>Deserialize a LevelPayload from bytes.</p> <p>Parameters</p> <ul> <li><code>Bytes</code>: Byte buffer.</li> <li><code>Size</code>: Byte count.</li> </ul> <p>Returns: Payload or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#texpected-void-snapigameframeworkserializeworldpayloadconst-worldpayload-payload-stdvector-uint8_t-outbytes","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::SerializeWorldPayload(const WorldPayload &amp;Payload, std::vector&lt; uint8_t &gt; &amp;OutBytes)</code>","text":"<p>Serialize a WorldPayload to bytes.</p> <p>Parameters</p> <ul> <li><code>Payload</code>: Payload to serialize.</li> <li><code>OutBytes</code>: Output byte vector.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#texpected-worldpayload-snapigameframeworkdeserializeworldpayloadconst-uint8_t-bytes-size_t-size","title":"<code>TExpected&lt; WorldPayload &gt; SnAPI::GameFramework::DeserializeWorldPayload(const uint8_t *Bytes, size_t Size)</code>","text":"<p>Deserialize a WorldPayload from bytes.</p> <p>Parameters</p> <ul> <li><code>Bytes</code>: Byte buffer.</li> <li><code>Size</code>: Byte count.</li> </ul> <p>Returns: Payload or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkregisterserializationdefaults","title":"<code>void SnAPI::GameFramework::RegisterSerializationDefaults()</code>","text":"<p>Register default serialization codecs and component serializers.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-typeid-snapigameframeworkstatictypeid","title":"<code>const TypeId &amp; SnAPI::GameFramework::StaticTypeId()</code>","text":"<p>Get the deterministic TypeId for a type, cached in a function-local static.</p> <p>Returns: Stable TypeId reference.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#texpected-typeid-snapigameframeworkstatictype","title":"<code>TExpected&lt; TypeId * &gt; SnAPI::GameFramework::StaticType()</code>","text":"<p>Ensure a type is registered in TypeRegistry and return its TypeId pointer.</p> <p>Returns: Pointer to a stable TypeId on success, or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkensurereflectionregistered","title":"<code>void SnAPI::GameFramework::EnsureReflectionRegistered()</code>","text":"<p>Ensure reflection registration for a type.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkregisterbuiltintypes","title":"<code>void SnAPI::GameFramework::RegisterBuiltinTypes()</code>","text":"<p>Register built-in types and default serializers.</p> <p>Notes</p> <ul> <li>Safe to call multiple times; duplicate registrations are ignored or fail gracefully.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#const-uuid-snapigameframeworktypeidnamespace","title":"<code>const Uuid &amp; SnAPI::GameFramework::TypeIdNamespace()</code>","text":"<p>Namespace UUID for deterministic type id generation.</p> <p>Returns: Stable namespace UUID.</p> <p>Notes</p> <ul> <li>Keep this stable across versions for serialized compatibility.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#typeid-snapigameframeworktypeidfromnamestdstring_view-name","title":"<code>TypeId SnAPI::GameFramework::TypeIdFromName(std::string_view Name)</code>","text":"<p>Generate a stable TypeId from a fully qualified name.</p> <p>Parameters</p> <ul> <li><code>Name</code>: Fully qualified type name.</li> </ul> <p>Returns: UUIDv5 derived from the name and TypeIdNamespace.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#uuid-snapigameframeworknewuuid","title":"<code>Uuid SnAPI::GameFramework::NewUuid()</code>","text":"<p>Generate a new random UUID (UUIDv4).</p> <p>Returns: Newly generated UUID.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#stdstring-snapigameframeworktostringconst-uuid-id","title":"<code>std::string SnAPI::GameFramework::ToString(const Uuid &amp;Id)</code>","text":"<p>Convert a UUID to its canonical string form.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to convert.</li> </ul> <p>Returns: Lowercase UUID string.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#uuidparts-snapigameframeworktopartsconst-uuid-id","title":"<code>UuidParts SnAPI::GameFramework::ToParts(const Uuid &amp;Id)</code>","text":"<p>Convert a UUID to a split High/Low representation.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to split.</li> </ul> <p>Returns: UuidParts containing the high/low 64-bit values.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#uuid-snapigameframeworkfrompartsuuidparts-parts","title":"<code>Uuid SnAPI::GameFramework::FromParts(UuidParts Parts)</code>","text":"<p>Reconstruct a UUID from split High/Low parts.</p> <p>Parameters</p> <ul> <li><code>Parts</code>: High/Low representation.</li> </ul> <p>Returns: Reconstructed UUID.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#static-void-snapigameframeworkregisterassetpipelinepluginsnapiassetpipelineipluginregistrar-registrar","title":"<code>static void SnAPI::GameFramework::RegisterAssetPipelinePlugin(::SnAPI::AssetPipeline::IPluginRegistrar &amp;Registrar)</code>","text":"<p>Register the GameFramework AssetPipeline plugin.</p> <p>Parameters</p> <ul> <li><code>Registrar</code>: AssetPipeline plugin registrar.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#perfcomponentbm_value-constructor-register","title":"<code>&amp;PerfComponentB::m_value Constructor() .Register()))</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#snapigameframeworkbase-basenode-constructor-register","title":"<code>SnAPI::GameFramework::Base&lt; BaseNode &gt;() .Constructor&lt;&gt;() .Register()))</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#snapigameframeworkbase-nodegraph-constructor-register","title":"<code>SnAPI::GameFramework::Base&lt; NodeGraph &gt;() .Constructor&lt;&gt;() .Register()))</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#snapigameframeworkfieldposition-transformcomponentposition-efieldflagbitsreplication-fieldrotation","title":"<code>SnAPI::GameFramework::Field(\"Position\", &amp;TransformComponent::Position, EFieldFlagBits::Replication) .Field(\"Rotation\"</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#efieldflagbitsreplication-snapigameframeworkfieldscale-transformcomponentscale-efieldflagbitsreplication-constructor-register","title":"<code>EFieldFlagBits::Replication SnAPI::GameFramework::Field(\"Scale\", &amp;TransformComponent::Scale, EFieldFlagBits::Replication) .Constructor&lt;&gt;() .Register()))</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#snapigameframeworkfieldscriptmodule-scriptcomponentscriptmodule-fieldscripttype","title":"<code>SnAPI::GameFramework::Field(\"ScriptModule\", &amp;ScriptComponent::ScriptModule) .Field(\"ScriptType\"</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#scriptcomponentscripttype-snapigameframeworkfieldinstance-scriptcomponentinstance-constructor-register","title":"<code>&amp;ScriptComponent::ScriptType SnAPI::GameFramework::Field(\"Instance\", &amp;ScriptComponent::Instance) .Constructor&lt;&gt;() .Register()))</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkserializearchive-archiveref-nodecomponentpayload-value","title":"<code>void SnAPI::GameFramework::serialize(Archive &amp;ArchiveRef, NodeComponentPayload &amp;Value)</code>","text":"<p>cereal serialize for NodeComponentPayload.</p> <p>Parameters</p> <ul> <li><code>ArchiveRef</code>: Archive.</li> <li><code>Value</code>: Payload to serialize.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkserializearchive-archiveref-nodepayload-value","title":"<code>void SnAPI::GameFramework::serialize(Archive &amp;ArchiveRef, NodePayload &amp;Value)</code>","text":"<p>cereal serialize for NodePayload.</p> <p>Parameters</p> <ul> <li><code>ArchiveRef</code>: Archive.</li> <li><code>Value</code>: Payload to serialize.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkserializearchive-archiveref-nodegraphpayload-value","title":"<code>void SnAPI::GameFramework::serialize(Archive &amp;ArchiveRef, NodeGraphPayload &amp;Value)</code>","text":"<p>cereal serialize for NodeGraphPayload.</p> <p>Parameters</p> <ul> <li><code>ArchiveRef</code>: Archive.</li> <li><code>Value</code>: Payload to serialize.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkserializearchive-archiveref-levelpayload-value","title":"<code>void SnAPI::GameFramework::serialize(Archive &amp;ArchiveRef, LevelPayload &amp;Value)</code>","text":"<p>cereal serialize for LevelPayload.</p> <p>Parameters</p> <ul> <li><code>ArchiveRef</code>: Archive.</li> <li><code>Value</code>: Payload to serialize.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework/#void-snapigameframeworkserializearchive-archiveref-worldpayload-value","title":"<code>void SnAPI::GameFramework::serialize(Archive &amp;ArchiveRef, WorldPayload &amp;Value)</code>","text":"<p>cereal serialize for WorldPayload.</p> <p>Parameters</p> <ul> <li><code>ArchiveRef</code>: Archive.</li> <li><code>Value</code>: Payload to serialize.</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineFactories_8cpp_03/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TNodeGraphFactory</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TLevelFactory</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TWorldFactory</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03/","title":"SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02AssetPipelineSerializers_8cpp_03/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02IComponent_8cpp_03/","title":"SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02IComponent_8cpp_03/#variables","title":"Variables","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02IComponent_8cpp_03/#stduint8_t-snapigameframeworkanonymous_namespaceicomponentcppkrpctargetcomponent","title":"<code>std::uint8_t SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}::kRpcTargetComponent</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02IComponent_8cpp_03/#functions","title":"Functions","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02IComponent_8cpp_03/#bool-snapigameframeworkanonymous_namespaceicomponentcppisrpcmethodconst-methodinfo-method","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}::IsRpcMethod(const MethodInfo &amp;Method)</code>","text":"<p>Parameters</p> <ul> <li><code>Method</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02IComponent_8cpp_03/#const-methodinfo-snapigameframeworkanonymous_namespaceicomponentcppfindrpcmethodconst-typeid-type-stdstring_view-methodname-stdspan-const-variant-args-typeid-outownertype","title":"<code>const MethodInfo * SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}::FindRpcMethod(const TypeId &amp;Type, std::string_view MethodName, std::span&lt; const Variant &gt; Args, TypeId &amp;OutOwnerType)</code>","text":"<p>Parameters</p> <ul> <li><code>Type</code>: </li> <li><code>MethodName</code>: </li> <li><code>Args</code>: </li> <li><code>OutOwnerType</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02IComponent_8cpp_03/#bool-snapigameframeworkanonymous_namespaceicomponentcppinvokelocalvoid-instance-const-methodinfo-method-stdspan-const-variant-args","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}::InvokeLocal(void *Instance, const MethodInfo &amp;Method, std::span&lt; const Variant &gt; Args)</code>","text":"<p>Parameters</p> <ul> <li><code>Instance</code>: </li> <li><code>Method</code>: </li> <li><code>Args</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02INode_8cpp_03/","title":"SnAPI::GameFramework::anonymous_namespace{INode.cpp}","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02INode_8cpp_03/#variables","title":"Variables","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02INode_8cpp_03/#stduint8_t-snapigameframeworkanonymous_namespaceinodecppkrpctargetnode","title":"<code>std::uint8_t SnAPI::GameFramework::anonymous_namespace{INode.cpp}::kRpcTargetNode</code>","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02INode_8cpp_03/#functions","title":"Functions","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02INode_8cpp_03/#bool-snapigameframeworkanonymous_namespaceinodecppisrpcmethodconst-methodinfo-method","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{INode.cpp}::IsRpcMethod(const MethodInfo &amp;Method)</code>","text":"<p>Parameters</p> <ul> <li><code>Method</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02INode_8cpp_03/#const-methodinfo-snapigameframeworkanonymous_namespaceinodecppfindrpcmethodconst-typeid-type-stdstring_view-methodname-stdspan-const-variant-args-typeid-outownertype","title":"<code>const MethodInfo * SnAPI::GameFramework::anonymous_namespace{INode.cpp}::FindRpcMethod(const TypeId &amp;Type, std::string_view MethodName, std::span&lt; const Variant &gt; Args, TypeId &amp;OutOwnerType)</code>","text":"<p>Parameters</p> <ul> <li><code>Type</code>: </li> <li><code>MethodName</code>: </li> <li><code>Args</code>: </li> <li><code>OutOwnerType</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02INode_8cpp_03/#bool-snapigameframeworkanonymous_namespaceinodecppinvokelocalvoid-instance-const-methodinfo-method-stdspan-const-variant-args","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{INode.cpp}::InvokeLocal(void *Instance, const MethodInfo &amp;Method, std::span&lt; const Variant &gt; Args)</code>","text":"<p>Parameters</p> <ul> <li><code>Instance</code>: </li> <li><code>Method</code>: </li> <li><code>Args</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02ScriptABI_8cpp_03/","title":"SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02ScriptABI_8cpp_03/#functions","title":"Functions","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02ScriptABI_8cpp_03/#sngfuuid-snapigameframeworkanonymous_namespacescriptabicpptocconst-typeid-id","title":"<code>SnGfUuid SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}::ToC(const TypeId &amp;Id)</code>","text":"<p>Convert a TypeId to the C ABI UUID struct.</p> <p>Parameters</p> <ul> <li><code>Id</code>: TypeId to convert.</li> </ul> <p>Returns: C ABI UUID representation.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02ScriptABI_8cpp_03/#typeid-snapigameframeworkanonymous_namespacescriptabicppfromcconst-sngfuuid-id","title":"<code>TypeId SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}::FromC(const SnGfUuid &amp;Id)</code>","text":"<p>Convert a C ABI UUID struct to a TypeId.</p> <p>Parameters</p> <ul> <li><code>Id</code>: C ABI UUID.</li> </ul> <p>Returns: TypeId value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02ScriptABI_8cpp_03/#uint64_t-snapigameframeworkanonymous_namespacescriptabicppinvalidhandle","title":"<code>uint64_t SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}::InvalidHandle()</code>","text":"<p>Get the sentinel value used for invalid handles.</p> <p>Returns: Sentinel handle value.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02ScriptABI_8cpp_03/#variant-snapigameframeworkanonymous_namespacescriptabicppfromhandlesngfvarianthandle-handle","title":"<code>Variant * SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}::FromHandle(SnGfVariantHandle Handle)</code>","text":"<p>Convert a variant handle to a Variant pointer.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: Variant handle.</li> </ul> <p>Returns: Variant pointer or nullptr.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02ScriptABI_8cpp_03/#sngfvarianthandle-snapigameframeworkanonymous_namespacescriptabicpptohandlevariant-ptr","title":"<code>SnGfVariantHandle SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}::ToHandle(Variant *Ptr)</code>","text":"<p>Convert a Variant pointer to a handle.</p> <p>Parameters</p> <ul> <li><code>Ptr</code>: Variant pointer.</li> </ul> <p>Returns: Variant handle.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/","title":"SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::MemoryReadStreambuf</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableFieldCacheEntry</li> <li>Type: SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#variables","title":"Variables","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#stdunordered_maptypeid-stdshared_ptrserializablefieldcacheentry-uuidhash-snapigameframeworkanonymous_namespaceserializationcppg_serializablefieldcache","title":"<code>std::unordered_map&lt;TypeId, std::shared_ptr&lt;SerializableFieldCacheEntry&gt;, UuidHash&gt; SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::g_serializableFieldCache</code>","text":"<p>TypeId -&gt; cached serializable field plan.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#stdmutex-snapigameframeworkanonymous_namespaceserializationcppg_serializablefieldmutex","title":"<code>std::mutex SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::g_serializableFieldMutex</code>","text":"<p>Guards serializable field cache map.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#functions","title":"Functions","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#void-snapigameframeworkanonymous_namespaceserializationcppbuildserializablefieldsconst-typeid-type-stdvector-serializablefield-out-stdunordered_map-typeid-bool-uuidhash-visited","title":"<code>void SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::BuildSerializableFields(const TypeId &amp;Type, std::vector&lt; SerializableField &gt; &amp;Out, std::unordered_map&lt; TypeId, bool, UuidHash &gt; &amp;Visited)</code>","text":"<p>Parameters</p> <ul> <li><code>Type</code>: </li> <li><code>Out</code>: </li> <li><code>Visited</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#stdshared_ptr-const-serializablefieldcacheentry-snapigameframeworkanonymous_namespaceserializationcppgetserializablefieldcacheconst-typeid-type","title":"<code>std::shared_ptr&lt; const SerializableFieldCacheEntry &gt; SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::GetSerializableFieldCache(const TypeId &amp;Type)</code>","text":"<p>Parameters</p> <ul> <li><code>Type</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#bool-snapigameframeworkanonymous_namespaceserializationcpphasserializablefieldsconst-typeid-type","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::HasSerializableFields(const TypeId &amp;Type)</code>","text":"<p>Parameters</p> <ul> <li><code>Type</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#texpected-void-snapigameframeworkanonymous_namespaceserializationcppserializefieldsrecursiveconst-typeid-type-const-void-instance-cerealbinaryoutputarchive-archive-const-tserializationcontext-context-stdunordered_map-typeid-bool-uuidhash-visited","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializeFieldsRecursive(const TypeId &amp;Type, const void *Instance, cereal::BinaryOutputArchive &amp;Archive, const TSerializationContext &amp;Context, std::unordered_map&lt; TypeId, bool, UuidHash &gt; &amp;Visited)</code>","text":"<p>Serialize fields recursively for a type and its bases.</p> <p>Parameters</p> <ul> <li><code>Type</code>: TypeId to serialize.</li> <li><code>Instance</code>: Pointer to instance.</li> <li><code>Archive</code>: Output archive.</li> <li><code>Context</code>: Serialization context.</li> <li><code>Visited</code>: Cycle guard for type traversal.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03/#texpected-void-snapigameframeworkanonymous_namespaceserializationcppdeserializefieldsrecursiveconst-typeid-type-void-instance-cerealbinaryinputarchive-archive-const-tserializationcontext-context-stdunordered_map-typeid-bool-uuidhash-visited","title":"<code>TExpected&lt; void &gt; SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::DeserializeFieldsRecursive(const TypeId &amp;Type, void *Instance, cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context, std::unordered_map&lt; TypeId, bool, UuidHash &gt; &amp;Visited)</code>","text":"<p>Deserialize fields recursively for a type and its bases.</p> <p>Parameters</p> <ul> <li><code>Type</code>: TypeId to deserialize.</li> <li><code>Instance</code>: Pointer to instance.</li> <li><code>Archive</code>: Input archive.</li> <li><code>Context</code>: Serialization context.</li> <li><code>Visited</code>: Cycle guard for type traversal.</li> </ul> <p>Returns: Success or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02TypeRegistry_8cpp_03/","title":"SnAPI::GameFramework::anonymous_namespace{TypeRegistry.cpp}","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02TypeRegistry_8cpp_03/#functions","title":"Functions","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1anonymous__namespace_02TypeRegistry_8cpp_03/#bool-snapigameframeworkanonymous_namespacetyperegistrycppisaunlockedconst-stdunordered_map-typeid-typeinfo-uuidhash-types-const-typeid-type-const-typeid-base","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{TypeRegistry.cpp}::IsAUnlocked(const std::unordered_map&lt; TypeId, TypeInfo, UuidHash &gt; &amp;Types, const TypeId &amp;Type, const TypeId &amp;Base)</code>","text":"<p>Parameters</p> <ul> <li><code>Types</code>: </li> <li><code>Type</code>: </li> <li><code>Base</code>:</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/","title":"SnAPI::GameFramework::detail","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#contents","title":"Contents","text":"<ul> <li>Type: SnAPI::GameFramework::detail::TArgStorage</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#type-aliases","title":"Type Aliases","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#using-snapigameframeworkdetailtargstoraget-typename-targstorageargtype","title":"<code>using SnAPI::GameFramework::detail::TArgStorageT = typename TArgStorage&lt;Arg&gt;::Type</code>","text":"<p>Helper alias for argument storage type.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#functions","title":"Functions","text":""},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#void-snapigameframeworkdetaildebugassertfailconst-char-file-int-line-const-char-condition-const-stdstring-message","title":"<code>void SnAPI::GameFramework::detail::DebugAssertFail(const char *File, int Line, const char *Condition, const std::string &amp;Message)</code>","text":"<p>Internal handler for failed debug assertions.</p> <p>Parameters</p> <ul> <li><code>File</code>: Source file where the assertion failed.</li> <li><code>Line</code>: Line number where the assertion failed.</li> <li><code>Condition</code>: Stringified assertion condition.</li> <li><code>Message</code>: Formatted diagnostic message.</li> </ul> <p>Notes</p> <ul> <li>This function always terminates the process via std::abort().</li> </ul>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#texpected-targstoraget-arg-snapigameframeworkdetailextractargconst-variant-value","title":"<code>TExpected&lt; TArgStorageT&lt; Arg &gt; &gt; SnAPI::GameFramework::detail::ExtractArg(const Variant &amp;Value)</code>","text":"<p>Extract a typed argument from a Variant.</p> <p>Parameters</p> <ul> <li><code>Value</code>: Variant to extract from.</li> </ul> <p>Returns: Storage wrapper containing the argument or an error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#arg-snapigameframeworkdetailconvertargtargstoraget-arg-storage","title":"<code>Arg SnAPI::GameFramework::detail::ConvertArg(TArgStorageT&lt; Arg &gt; &amp;Storage)</code>","text":"<p>Convert storage wrapper to the actual argument type.</p> <p>Parameters</p> <ul> <li><code>Storage</code>: Storage wrapper.</li> </ul> <p>Returns: Argument value or reference.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#texpected-variant-snapigameframeworkdetailinvokeimplt-instance-rtmethodargs-stdspan-const-variant-argspack-stdindex_sequence-i","title":"<code>TExpected&lt; Variant &gt; SnAPI::GameFramework::detail::InvokeImpl(T *Instance, R(T::*Method)(Args...), std::span&lt; const Variant &gt; ArgsPack, std::index_sequence&lt; I... &gt;)</code>","text":"<p>Invoke a non-const member function with reflected args.</p> <p>Parameters</p> <ul> <li><code>Instance</code>: Pointer to instance.</li> <li><code>Method</code>: Member function pointer.</li> <li><code>ArgsPack</code>: Packed arguments.</li> </ul> <p>Returns: Variant containing the result or error.</p>"},{"location":"api/namespaceSnAPI_1_1GameFramework_1_1detail/#texpected-variant-snapigameframeworkdetailinvokeconstimplconst-t-instance-rtmethodargs-const-stdspan-const-variant-argspack-stdindex_sequence-i","title":"<code>TExpected&lt; Variant &gt; SnAPI::GameFramework::detail::InvokeConstImpl(const T *Instance, R(T::*Method)(Args...) const, std::span&lt; const Variant &gt; ArgsPack, std::index_sequence&lt; I... &gt;)</code>","text":"<p>Invoke a const member function with reflected args.</p> <p>Parameters</p> <ul> <li><code>Instance</code>: Pointer to const instance.</li> <li><code>Method</code>: Const member function pointer.</li> <li><code>ArgsPack</code>: Packed arguments.</li> </ul> <p>Returns: Variant containing the result or error.</p>"},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/","title":"anonymous_namespace{main.cpp}","text":""},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#type-aliases","title":"Type Aliases","text":""},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#using-anonymous_namespacemaincppclock-stdchronosteady_clock","title":"<code>using anonymous_namespace{main.cpp}::Clock = std::chrono::steady_clock</code>","text":""},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#functions","title":"Functions","text":""},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#nodehandle-anonymous_namespacemaincppfindnodebynamenodegraph-graph-const-stdstring-name","title":"<code>NodeHandle anonymous_namespace{main.cpp}::FindNodeByName(NodeGraph &amp;Graph, const std::string &amp;Name)</code>","text":"<p>Parameters</p> <ul> <li><code>Graph</code>: </li> <li><code>Name</code>:</li> </ul>"},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#nodegraph-anonymous_namespacemaincppfindgraphbynamenodegraph-graph-const-stdstring-name","title":"<code>NodeGraph * anonymous_namespace{main.cpp}::FindGraphByName(NodeGraph &amp;Graph, const std::string &amp;Name)</code>","text":"<p>Parameters</p> <ul> <li><code>Graph</code>: </li> <li><code>Name</code>:</li> </ul>"},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#bool-anonymous_namespacemaincppvalidatedemonodenodegraph-graph-const-stdstring-nodename-const-stdstring-targetname-int-expectedhealth-float-expectedspeed-const-stdstring-expectedtag-const-vec3-expectedspawn-int-expectedscore-const-stdstring-expectedlabel-const-vec3-expectedtint","title":"<code>bool anonymous_namespace{main.cpp}::ValidateDemoNode(NodeGraph &amp;Graph, const std::string &amp;NodeName, const std::string &amp;TargetName, int ExpectedHealth, float ExpectedSpeed, const std::string &amp;ExpectedTag, const Vec3 &amp;ExpectedSpawn, int ExpectedScore, const std::string &amp;ExpectedLabel, const Vec3 &amp;ExpectedTint)</code>","text":"<p>Parameters</p> <ul> <li><code>Graph</code>: </li> <li><code>NodeName</code>: </li> <li><code>TargetName</code>: </li> <li><code>ExpectedHealth</code>: </li> <li><code>ExpectedSpeed</code>: </li> <li><code>ExpectedTag</code>: </li> <li><code>ExpectedSpawn</code>: </li> <li><code>ExpectedScore</code>: </li> <li><code>ExpectedLabel</code>: </li> <li><code>ExpectedTint</code>:</li> </ul>"},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#double-anonymous_namespacemaincpptomillisecondsconst-clockduration-duration","title":"<code>double anonymous_namespace{main.cpp}::ToMilliseconds(const Clock::duration &amp;Duration)</code>","text":"<p>Parameters</p> <ul> <li><code>Duration</code>:</li> </ul>"},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#level-anonymous_namespacemaincppfindlevelbynameworld-worldref-const-stdstring-name","title":"<code>Level * anonymous_namespace{main.cpp}::FindLevelByName(World &amp;WorldRef, const std::string &amp;Name)</code>","text":"<p>Parameters</p> <ul> <li><code>WorldRef</code>: </li> <li><code>Name</code>:</li> </ul>"},{"location":"api/namespaceanonymous__namespace_02main_8cpp_03/#nodegraph-anonymous_namespacemaincppfindgraphbynamelevel-levelref-const-stdstring-name","title":"<code>NodeGraph * anonymous_namespace{main.cpp}::FindGraphByName(Level &amp;LevelRef, const std::string &amp;Name)</code>","text":"<p>Parameters</p> <ul> <li><code>LevelRef</code>: </li> <li><code>Name</code>:</li> </ul>"},{"location":"api/namespacecereal/","title":"cereal","text":""},{"location":"api/namespacecereal/#functions","title":"Functions","text":""},{"location":"api/namespacecereal/#void-cerealsavearchive-archiveref-const-snapigameframeworkuuid-id","title":"<code>void cereal::save(Archive &amp;ArchiveRef, const SnAPI::GameFramework::Uuid &amp;Id)</code>","text":"<p>cereal save function for Uuid.</p> <p>Parameters</p> <ul> <li><code>ArchiveRef</code>: Output archive.</li> <li><code>Id</code>: UUID to serialize.</li> </ul>"},{"location":"api/namespacecereal/#void-cerealloadarchive-archiveref-snapigameframeworkuuid-id","title":"<code>void cereal::load(Archive &amp;ArchiveRef, SnAPI::GameFramework::Uuid &amp;Id)</code>","text":"<p>cereal load function for Uuid.</p> <p>Parameters</p> <ul> <li><code>ArchiveRef</code>: Input archive.</li> <li><code>Id</code>: UUID to deserialize into.</li> </ul>"},{"location":"api/namespaces/","title":"Namespaces","text":"<ul> <li>SnAPI</li> <li>SnAPI::AssetPipeline</li> <li>SnAPI::GameFramework</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}</li> <li>SnAPI::GameFramework::anonymous_namespace{IComponent.cpp}</li> <li>SnAPI::GameFramework::anonymous_namespace{INode.cpp}</li> <li>SnAPI::GameFramework::anonymous_namespace{ScriptABI.cpp}</li> <li>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}</li> <li>SnAPI::GameFramework::anonymous_namespace{TypeRegistry.cpp}</li> <li>SnAPI::GameFramework::detail</li> <li>anonymous_namespace{main.cpp}</li> <li>cereal</li> <li>std</li> </ul>"},{"location":"api/namespacestd/","title":"std","text":"<p>STL namespace.</p>"},{"location":"api/namespacestd/#contents","title":"Contents","text":"<ul> <li>Type: std::allocator</li> <li>Type: std::auto_ptr</li> <li>Type: std::smart_ptr</li> <li>Type: std::unique_ptr</li> <li>Type: std::shared_ptr</li> <li>Type: std::weak_ptr</li> <li>Type: std::atomic</li> <li>Type: std::atomic_ref</li> <li>Type: std::lock_guard</li> <li>Type: std::unique_lock</li> <li>Type: std::shared_lock</li> <li>Type: std::ios_base</li> <li>Type: std::error_code</li> <li>Type: std::error_category</li> <li>Type: std::system_error</li> <li>Type: std::error_condition</li> <li>Type: std::thread</li> <li>Type: std::jthread</li> <li>Type: std::mutex</li> <li>Type: std::timed_mutex</li> <li>Type: std::recursive_mutex</li> <li>Type: std::recursive_timed_mutex</li> <li>Type: std::shared_mutex</li> <li>Type: std::shared_timed_mutex</li> <li>Type: std::basic_ios</li> <li>Type: std::basic_istream</li> <li>Type: std::basic_ostream</li> <li>Type: std::basic_iostream</li> <li>Type: std::basic_ifstream</li> <li>Type: std::basic_ofstream</li> <li>Type: std::basic_fstream</li> <li>Type: std::basic_istringstream</li> <li>Type: std::basic_ostringstream</li> <li>Type: std::basic_stringstream</li> <li>Type: std::ios</li> <li>Type: std::wios</li> <li>Type: std::istream</li> <li>Type: std::wistream</li> <li>Type: std::ostream</li> <li>Type: std::wostream</li> <li>Type: std::ifstream</li> <li>Type: std::wifstream</li> <li>Type: std::ofstream</li> <li>Type: std::wofstream</li> <li>Type: std::fstream</li> <li>Type: std::wfstream</li> <li>Type: std::istringstream</li> <li>Type: std::wistringstream</li> <li>Type: std::ostringstream</li> <li>Type: std::wostringstream</li> <li>Type: std::stringstream</li> <li>Type: std::wstringstream</li> <li>Type: std::basic_string</li> <li>Type: std::string</li> <li>Type: std::wstring</li> <li>Type: std::u8string</li> <li>Type: std::u16string</li> <li>Type: std::u32string</li> <li>Type: std::basic_string_view</li> <li>Type: std::string_view</li> <li>Type: std::wstring_view</li> <li>Type: std::u8string_view</li> <li>Type: std::u16string_view</li> <li>Type: std::u32string_view</li> <li>Type: std::complex</li> <li>Type: std::bitset</li> <li>Type: std::deque</li> <li>Type: std::list</li> <li>Type: std::forward_list</li> <li>Type: std::pair</li> <li>Type: std::map</li> <li>Type: std::unordered_map</li> <li>Type: std::multimap</li> <li>Type: std::unordered_multimap</li> <li>Type: std::set</li> <li>Type: std::unordered_set</li> <li>Type: std::multiset</li> <li>Type: std::unordered_multiset</li> <li>Type: std::array</li> <li>Type: std::vector</li> <li>Type: std::span</li> <li>Type: std::queue</li> <li>Type: std::priority_queue</li> <li>Type: std::stack</li> <li>Type: std::valarray</li> <li>Type: std::exception</li> <li>Type: std::bad_alloc</li> <li>Type: std::bad_cast</li> <li>Type: std::bad_typeid</li> <li>Type: std::logic_error</li> <li>Type: std::runtime_error</li> <li>Type: std::bad_exception</li> <li>Type: std::domain_error</li> <li>Type: std::invalid_argument</li> <li>Type: std::length_error</li> <li>Type: std::out_of_range</li> <li>Type: std::range_error</li> <li>Type: std::overflow_error</li> <li>Type: std::underflow_error</li> </ul>"},{"location":"api/structAlwaysActivePolicy/","title":"AlwaysActivePolicy","text":"<p>Example relevance policy that always keeps nodes active.</p>"},{"location":"api/structAlwaysActivePolicy/#public-static-members","title":"Public Static Members","text":""},{"location":"api/structAlwaysActivePolicy/#const-char-alwaysactivepolicyktypename","title":"<code>const char* AlwaysActivePolicy::kTypeName</code>","text":""},{"location":"api/structAlwaysActivePolicy/#public-functions","title":"Public Functions","text":""},{"location":"api/structAlwaysActivePolicy/#bool-alwaysactivepolicyevaluateconst-relevancecontext-const","title":"<code>bool AlwaysActivePolicy::Evaluate(const RelevanceContext &amp;) const</code>","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry_1_1Entry/","title":"SnAPI::GameFramework::ComponentSerializationRegistry::Entry","text":"<p>Registry entry storing creation and serialization callbacks.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry_1_1Entry/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry_1_1Entry/#createfn-snapigameframeworkcomponentserializationregistryentrycreate","title":"<code>CreateFn SnAPI::GameFramework::ComponentSerializationRegistry::Entry::Create</code>","text":"<p>Creation callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry_1_1Entry/#createwithidfn-snapigameframeworkcomponentserializationregistryentrycreatewithid","title":"<code>CreateWithIdFn SnAPI::GameFramework::ComponentSerializationRegistry::Entry::CreateWithId</code>","text":"<p>Creation-with-id callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry_1_1Entry/#serializefn-snapigameframeworkcomponentserializationregistryentryserialize","title":"<code>SerializeFn SnAPI::GameFramework::ComponentSerializationRegistry::Entry::Serialize</code>","text":"<p>Serialization callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ComponentSerializationRegistry_1_1Entry/#deserializefn-snapigameframeworkcomponentserializationregistryentrydeserialize","title":"<code>DeserializeFn SnAPI::GameFramework::ComponentSerializationRegistry::Entry::Deserialize</code>","text":"<p>Deserialization callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ConstructorInfo/","title":"SnAPI::GameFramework::ConstructorInfo","text":"<p>Reflection metadata for a constructor.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ConstructorInfo/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1ConstructorInfo/#stdvectortypeid-snapigameframeworkconstructorinfoparamtypes","title":"<code>std::vector&lt;TypeId&gt; SnAPI::GameFramework::ConstructorInfo::ParamTypes</code>","text":"<p>Parameter type ids.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ConstructorInfo/#stdfunctiontexpectedstdshared_ptrvoid-stdspanconst-variant-args-snapigameframeworkconstructorinfoconstruct","title":"<code>std::function&lt;TExpected&lt;std::shared_ptr&lt;void&gt; &gt;(std::span&lt;const Variant&gt; Args)&gt; SnAPI::GameFramework::ConstructorInfo::Construct</code>","text":"<p>Construction callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1EnableFlags/","title":"SnAPI::GameFramework::EnableFlags","text":"<p>Trait to opt enums into flag operators.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1EnableFlags_3_01EFieldFlagBits_01_4/","title":"SnAPI::GameFramework::EnableFlags&lt; EFieldFlagBits &gt;","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1EnableFlags_3_01EMethodFlagBits_01_4/","title":"SnAPI::GameFramework::EnableFlags&lt; EMethodFlagBits &gt;","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/","title":"SnAPI::GameFramework::Error","text":"<p>Error payload for TExpected results.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/#eerrorcode-snapigameframeworkerrorcode","title":"<code>EErrorCode SnAPI::GameFramework::Error::Code</code>","text":"<p>Error category.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/#stdstring-snapigameframeworkerrormessage","title":"<code>std::string SnAPI::GameFramework::Error::Message</code>","text":"<p>Human-readable diagnostic message.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/#public-functions","title":"Public Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/#snapigameframeworkerrorerrordefault","title":"<code>SnAPI::GameFramework::Error::Error()=default</code>","text":"<p>Construct a success error value.</p> <p>Notes</p> <ul> <li>A success Error evaluates to false.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/#snapigameframeworkerrorerroreerrorcode-incode-stdstring-inmessage","title":"<code>SnAPI::GameFramework::Error::Error(EErrorCode InCode, std::string InMessage)</code>","text":"<p>Construct an error with code and message.</p> <p>Parameters</p> <ul> <li><code>InCode</code>: Error category.</li> <li><code>InMessage</code>: Diagnostic message.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1Error/#snapigameframeworkerroroperator-bool-const-noexcept","title":"<code>SnAPI::GameFramework::Error::operator bool() const noexcept</code>","text":"<p>Boolean conversion for quick success checks.</p> <p>Notes</p> <ul> <li>This intentionally inverts the typical \"success\" meaning.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/","title":"SnAPI::GameFramework::FieldInfo","text":"<p>Reflection metadata for a field.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#stdstring-snapigameframeworkfieldinfoname","title":"<code>std::string SnAPI::GameFramework::FieldInfo::Name</code>","text":"<p>Field name as registered.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#typeid-snapigameframeworkfieldinfofieldtype","title":"<code>TypeId SnAPI::GameFramework::FieldInfo::FieldType</code>","text":"<p>TypeId of the field.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#fieldflags-snapigameframeworkfieldinfoflags","title":"<code>FieldFlags SnAPI::GameFramework::FieldInfo::Flags</code>","text":"<p>Field flags (replication, etc.).</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#stdfunctiontexpectedvariantvoid-instance-snapigameframeworkfieldinfogetter","title":"<code>std::function&lt;TExpected&lt;Variant&gt;(void* Instance)&gt; SnAPI::GameFramework::FieldInfo::Getter</code>","text":"<p>Getter callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#stdfunctionresultvoid-instance-const-variant-value-snapigameframeworkfieldinfosetter","title":"<code>std::function&lt;Result(void* Instance, const Variant&amp; Value)&gt; SnAPI::GameFramework::FieldInfo::Setter</code>","text":"<p>Setter callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#stdfunctiontexpectedvariantviewvoid-instance-snapigameframeworkfieldinfoviewgetter","title":"<code>std::function&lt;TExpected&lt;VariantView&gt;(void* Instance)&gt; SnAPI::GameFramework::FieldInfo::ViewGetter</code>","text":"<p>Non-owning getter.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#stdfunctionconst-voidconst-void-instance-snapigameframeworkfieldinfoconstpointer","title":"<code>std::function&lt;const void*(const void* Instance)&gt; SnAPI::GameFramework::FieldInfo::ConstPointer</code>","text":"<p>Direct const pointer accessor.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#stdfunctionvoidvoid-instance-snapigameframeworkfieldinfomutablepointer","title":"<code>std::function&lt;void*(void* Instance)&gt; SnAPI::GameFramework::FieldInfo::MutablePointer</code>","text":"<p>Direct mutable pointer accessor.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1FieldInfo/#bool-snapigameframeworkfieldinfoisconst","title":"<code>bool SnAPI::GameFramework::FieldInfo::IsConst</code>","text":"<p>True if field is const-qualified.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeSettings/","title":"SnAPI::GameFramework::GameRuntimeSettings","text":"<p>High-level runtime settings for bootstrap and update policy.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeSettings/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeSettings/#stdstring-snapigameframeworkgameruntimesettingsworldname","title":"<code>std::string SnAPI::GameFramework::GameRuntimeSettings::WorldName</code>","text":"<p>Name assigned to the created world instance.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeSettings/#bool-snapigameframeworkgameruntimesettingsregisterbuiltins","title":"<code>bool SnAPI::GameFramework::GameRuntimeSettings::RegisterBuiltins</code>","text":"<p>Register built-in reflection/serialization types once during init.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeSettings/#gameruntimeticksettings-snapigameframeworkgameruntimesettingstick","title":"<code>GameRuntimeTickSettings SnAPI::GameFramework::GameRuntimeSettings::Tick</code>","text":"<p>Tick/lifecycle policy for <code>Update</code>.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeTickSettings/","title":"SnAPI::GameFramework::GameRuntimeTickSettings","text":"<p>Tick/lifecycle policy for <code>GameRuntime::Update</code>.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeTickSettings/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeTickSettings/#bool-snapigameframeworkgameruntimeticksettingsenablefixedtick","title":"<code>bool SnAPI::GameFramework::GameRuntimeTickSettings::EnableFixedTick</code>","text":"<p>Execute fixed-step ticks from accumulator time.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeTickSettings/#float-snapigameframeworkgameruntimeticksettingsfixeddeltaseconds","title":"<code>float SnAPI::GameFramework::GameRuntimeTickSettings::FixedDeltaSeconds</code>","text":"<p>Fixed-step interval used when <code>EnableFixedTick</code> is true.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeTickSettings/#stdsize_t-snapigameframeworkgameruntimeticksettingsmaxfixedstepsperupdate","title":"<code>std::size_t SnAPI::GameFramework::GameRuntimeTickSettings::MaxFixedStepsPerUpdate</code>","text":"<p>Safety cap to avoid spiral-of-death under long frames.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeTickSettings/#bool-snapigameframeworkgameruntimeticksettingsenablelatetick","title":"<code>bool SnAPI::GameFramework::GameRuntimeTickSettings::EnableLateTick</code>","text":"<p>Execute <code>World::LateTick</code> each update.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1GameRuntimeTickSettings/#bool-snapigameframeworkgameruntimeticksettingsenableendframe","title":"<code>bool SnAPI::GameFramework::GameRuntimeTickSettings::EnableEndFrame</code>","text":"<p>Execute <code>World::EndFrame</code> each update.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1HandleHash/","title":"SnAPI::GameFramework::HandleHash","text":"<p>Hash functor for THandle.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1HandleHash/#public-functions","title":"Public Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1HandleHash/#stdsize_t-snapigameframeworkhandlehashoperatorconst-thandle-t-handle-const-noexcept","title":"<code>std::size_t SnAPI::GameFramework::HandleHash::operator()(const THandle&lt; T &gt; &amp;Handle) const noexcept</code>","text":"<p>Compute hash for a handle.</p> <p>Parameters</p> <ul> <li><code>Handle</code>: Handle to hash.</li> </ul> <p>Returns: Hash value.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1LevelPayload/","title":"SnAPI::GameFramework::LevelPayload","text":"<p>Serialized level payload.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1LevelPayload/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1LevelPayload/#stdstring-snapigameframeworklevelpayloadname","title":"<code>std::string SnAPI::GameFramework::LevelPayload::Name</code>","text":"<p>Level name.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1LevelPayload/#nodegraphpayload-snapigameframeworklevelpayloadgraph","title":"<code>NodeGraphPayload SnAPI::GameFramework::LevelPayload::Graph</code>","text":"<p>Level root graph payload.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/","title":"SnAPI::GameFramework::MethodInfo","text":"<p>Reflection metadata for a method.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/#stdstring-snapigameframeworkmethodinfoname","title":"<code>std::string SnAPI::GameFramework::MethodInfo::Name</code>","text":"<p>Method name as registered.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/#typeid-snapigameframeworkmethodinforeturntype","title":"<code>TypeId SnAPI::GameFramework::MethodInfo::ReturnType</code>","text":"<p>Return type id.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/#stdvectortypeid-snapigameframeworkmethodinfoparamtypes","title":"<code>std::vector&lt;TypeId&gt; SnAPI::GameFramework::MethodInfo::ParamTypes</code>","text":"<p>Parameter type ids.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/#methodinvoker-snapigameframeworkmethodinfoinvoke","title":"<code>MethodInvoker SnAPI::GameFramework::MethodInfo::Invoke</code>","text":"<p>Invocation callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/#methodflags-snapigameframeworkmethodinfoflags","title":"<code>MethodFlags SnAPI::GameFramework::MethodInfo::Flags</code>","text":"<p>Method flags (rpc, etc.).</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1MethodInfo/#bool-snapigameframeworkmethodinfoisconst","title":"<code>bool SnAPI::GameFramework::MethodInfo::IsConst</code>","text":"<p>True if method is const-qualified.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeComponentPayload/","title":"SnAPI::GameFramework::NodeComponentPayload","text":"<p>Serialized component data attached to a node.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeComponentPayload/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeComponentPayload/#uuid-snapigameframeworknodecomponentpayloadcomponentid","title":"<code>Uuid SnAPI::GameFramework::NodeComponentPayload::ComponentId</code>","text":"<p>Component UUID.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeComponentPayload/#typeid-snapigameframeworknodecomponentpayloadcomponenttype","title":"<code>TypeId SnAPI::GameFramework::NodeComponentPayload::ComponentType</code>","text":"<p>Component type id.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeComponentPayload/#stdvectoruint8_t-snapigameframeworknodecomponentpayloadbytes","title":"<code>std::vector&lt;uint8_t&gt; SnAPI::GameFramework::NodeComponentPayload::Bytes</code>","text":"<p>Serialized component bytes.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeGraphPayload/","title":"SnAPI::GameFramework::NodeGraphPayload","text":"<p>Serialized node graph payload.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeGraphPayload/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeGraphPayload/#stdstring-snapigameframeworknodegraphpayloadname","title":"<code>std::string SnAPI::GameFramework::NodeGraphPayload::Name</code>","text":"<p>Graph name.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodeGraphPayload/#stdvectornodepayload-snapigameframeworknodegraphpayloadnodes","title":"<code>std::vector&lt;NodePayload&gt; SnAPI::GameFramework::NodeGraphPayload::Nodes</code>","text":"<p>Node payloads.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/","title":"SnAPI::GameFramework::NodePayload","text":"<p>Serialized node data within a graph.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#uuid-snapigameframeworknodepayloadnodeid","title":"<code>Uuid SnAPI::GameFramework::NodePayload::NodeId</code>","text":"<p>Node UUID.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#typeid-snapigameframeworknodepayloadnodetype","title":"<code>TypeId SnAPI::GameFramework::NodePayload::NodeType</code>","text":"<p>Node type id.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#stdstring-snapigameframeworknodepayloadnodetypename","title":"<code>std::string SnAPI::GameFramework::NodePayload::NodeTypeName</code>","text":"<p>Type name fallback when TypeId is missing.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#stdstring-snapigameframeworknodepayloadname","title":"<code>std::string SnAPI::GameFramework::NodePayload::Name</code>","text":"<p>Node name.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#bool-snapigameframeworknodepayloadactive","title":"<code>bool SnAPI::GameFramework::NodePayload::Active</code>","text":"<p>Active state.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#uuid-snapigameframeworknodepayloadparentid","title":"<code>Uuid SnAPI::GameFramework::NodePayload::ParentId</code>","text":"<p>Parent node UUID (nil if root).</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#bool-snapigameframeworknodepayloadhasnodedata","title":"<code>bool SnAPI::GameFramework::NodePayload::HasNodeData</code>","text":"<p>True if node fields were serialized.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#stdvectoruint8_t-snapigameframeworknodepayloadnodebytes","title":"<code>std::vector&lt;uint8_t&gt; SnAPI::GameFramework::NodePayload::NodeBytes</code>","text":"<p>Serialized node field bytes.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#stdvectornodecomponentpayload-snapigameframeworknodepayloadcomponents","title":"<code>std::vector&lt;NodeComponentPayload&gt; SnAPI::GameFramework::NodePayload::Components</code>","text":"<p>Component payloads.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#bool-snapigameframeworknodepayloadhasgraph","title":"<code>bool SnAPI::GameFramework::NodePayload::HasGraph</code>","text":"<p>True if node contains a nested graph.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1NodePayload/#stdvectoruint8_t-snapigameframeworknodepayloadgraphbytes","title":"<code>std::vector&lt;uint8_t&gt; SnAPI::GameFramework::NodePayload::GraphBytes</code>","text":"<p>Serialized nested graph bytes.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ObjectRegistry_1_1Entry/","title":"SnAPI::GameFramework::ObjectRegistry::Entry","text":"<p>Registry entry payload.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ObjectRegistry_1_1Entry/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1ObjectRegistry_1_1Entry/#eobjectkind-snapigameframeworkobjectregistryentrykind","title":"<code>EObjectKind SnAPI::GameFramework::ObjectRegistry::Entry::Kind</code>","text":"<p>Object kind.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ObjectRegistry_1_1Entry/#basenode-snapigameframeworkobjectregistryentrynode","title":"<code>BaseNode* SnAPI::GameFramework::ObjectRegistry::Entry::Node</code>","text":"<p>Node pointer if Kind == Node.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ObjectRegistry_1_1Entry/#icomponent-snapigameframeworkobjectregistryentrycomponent","title":"<code>IComponent* SnAPI::GameFramework::ObjectRegistry::Entry::Component</code>","text":"<p>Component pointer if Kind == Component.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ObjectRegistry_1_1Entry/#void-snapigameframeworkobjectregistryentryother","title":"<code>void* SnAPI::GameFramework::ObjectRegistry::Entry::Other</code>","text":"<p>Opaque pointer if Kind == Other.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ObjectRegistry_1_1Entry/#stdtype_index-snapigameframeworkobjectregistryentrytype","title":"<code>std::type_index SnAPI::GameFramework::ObjectRegistry::Entry::Type</code>","text":"<p>Concrete type for Other.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1RelevanceContext/","title":"SnAPI::GameFramework::RelevanceContext","text":"<p>Context passed to relevance policy evaluation.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1RelevanceContext/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1RelevanceContext/#nodehandle-snapigameframeworkrelevancecontextnode","title":"<code>NodeHandle SnAPI::GameFramework::RelevanceContext::Node</code>","text":"<p>Node being evaluated.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1RelevanceContext/#stdreference_wrappernodegraph-snapigameframeworkrelevancecontextgraph","title":"<code>std::reference_wrapper&lt;NodeGraph&gt; SnAPI::GameFramework::RelevanceContext::Graph</code>","text":"<p>Owning graph.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry_1_1PolicyInfo/","title":"SnAPI::GameFramework::RelevancePolicyRegistry::PolicyInfo","text":"<p>Stored policy metadata.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry_1_1PolicyInfo/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1RelevancePolicyRegistry_1_1PolicyInfo/#evaluatefn-snapigameframeworkrelevancepolicyregistrypolicyinfoevaluate","title":"<code>EvaluateFn SnAPI::GameFramework::RelevancePolicyRegistry::PolicyInfo::Evaluate</code>","text":"<p>Evaluation callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/","title":"SnAPI::GameFramework::THandle","text":"<p>Strongly typed UUID handle for framework objects.</p> <p>Strongly typed handle that stores a UUID.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#uuid-snapigameframeworkthandle-t-id","title":"<code>Uuid SnAPI::GameFramework::THandle&lt; T &gt;::Id</code>","text":"<p>UUID of the referenced object.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#public-functions","title":"Public Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#snapigameframeworkthandle-t-thandledefault","title":"<code>SnAPI::GameFramework::THandle&lt; T &gt;::THandle()=default</code>","text":"<p>Construct a null handle.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#snapigameframeworkthandle-t-thandleuuid-inid","title":"<code>SnAPI::GameFramework::THandle&lt; T &gt;::THandle(Uuid InId)</code>","text":"<p>Construct a handle from a UUID.</p> <p>Parameters</p> <ul> <li><code>InId</code>: UUID of the target object.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#bool-snapigameframeworkthandle-t-isnull-const-noexcept","title":"<code>bool SnAPI::GameFramework::THandle&lt; T &gt;::IsNull() const noexcept</code>","text":"<p>Check if the handle is null.</p> <p>Returns: True when the UUID is nil.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#snapigameframeworkthandle-t-operator-bool-const-noexcept","title":"<code>SnAPI::GameFramework::THandle&lt; T &gt;::operator bool() const noexcept</code>","text":"<p>Boolean conversion for validity checks.</p> <p>Returns: True when the handle is not null.</p> <p>Notes</p> <ul> <li>This does not guarantee the object is loaded.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#bool-snapigameframeworkthandle-t-operatorconst-thandle-other-const-noexcept","title":"<code>bool SnAPI::GameFramework::THandle&lt; T &gt;::operator==(const THandle &amp;Other) const noexcept</code>","text":"<p>Equality comparison.</p> <p>Parameters</p> <ul> <li><code>Other</code>: Another handle.</li> </ul> <p>Returns: True when UUIDs match.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#bool-snapigameframeworkthandle-t-operatorconst-thandle-other-const-noexcept_1","title":"<code>bool SnAPI::GameFramework::THandle&lt; T &gt;::operator!=(const THandle &amp;Other) const noexcept</code>","text":"<p>Inequality comparison.</p> <p>Parameters</p> <ul> <li><code>Other</code>: Another handle.</li> </ul> <p>Returns: True when UUIDs differ.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#t-snapigameframeworkthandle-t-borrowed-const","title":"<code>T * SnAPI::GameFramework::THandle&lt; T &gt;::Borrowed() const</code>","text":"<p>Resolve to a borrowed pointer (const).</p> <p>Returns: Pointer to the object, or nullptr if not loaded/registered.</p> <p>Notes</p> <ul> <li>The returned pointer must not be stored.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#t-snapigameframeworkthandle-t-borrowed","title":"<code>T * SnAPI::GameFramework::THandle&lt; T &gt;::Borrowed()</code>","text":"<p>Resolve to a borrowed pointer (mutable).</p> <p>Returns: Pointer to the object, or nullptr if not loaded/registered.</p> <p>Notes</p> <ul> <li>The returned pointer must not be stored.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1THandle/#bool-snapigameframeworkthandle-t-isvalid-const","title":"<code>bool SnAPI::GameFramework::THandle&lt; T &gt;::IsValid() const</code>","text":"<p>Check whether the handle resolves to a live object.</p> <p>Returns: True when the object is registered.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TObjectPool_1_1Entry/","title":"SnAPI::GameFramework::TObjectPool::Entry","text":"<p>Internal storage entry.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TObjectPool_1_1Entry/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TObjectPool_1_1Entry/#uuid-snapigameframeworktobjectpool-t-entryid","title":"<code>Uuid SnAPI::GameFramework::TObjectPool&lt; T &gt;::Entry::Id</code>","text":"<p>UUID key for this entry.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TObjectPool_1_1Entry/#stdshared_ptrt-snapigameframeworktobjectpool-t-entrym_object","title":"<code>std::shared_ptr&lt;T&gt; SnAPI::GameFramework::TObjectPool&lt; T &gt;::Entry::m_object</code>","text":"<p>Stored object pointer.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TObjectPool_1_1Entry/#bool-snapigameframeworktobjectpool-t-entrym_pendingdestroy","title":"<code>bool SnAPI::GameFramework::TObjectPool&lt; T &gt;::Entry::m_pendingDestroy</code>","text":"<p>True when scheduled for deletion.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TSerializationContext/","title":"SnAPI::GameFramework::TSerializationContext","text":"<p>Context used during serialization/deserialization.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TSerializationContext/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TSerializationContext/#const-nodegraph-snapigameframeworktserializationcontextgraph","title":"<code>const NodeGraph* SnAPI::GameFramework::TSerializationContext::Graph</code>","text":"<p>Graph being serialized/deserialized.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TTypeName/","title":"SnAPI::GameFramework::TTypeName","text":"<p>Type trait that provides a stable type name string.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TTypeName/#public-static-members","title":"Public Static Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TTypeName/#const-char-snapigameframeworkttypename-t-value","title":"<code>const char* SnAPI::GameFramework::TTypeName&lt; T &gt;::Value</code>","text":"<p>Stable fully-qualified type name used for deterministic TypeId generation.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TValueCodec/","title":"SnAPI::GameFramework::TValueCodec","text":"<p>Customization point for value serialization.</p> <p>Default behavior includes: - common framework scalar/value types - UUID/handle binary encoding - trivially-copyable fallback for POD-like values</p> <p>For high-performance hot paths, prefer custom codecs to avoid generic reflection walk costs.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TValueCodec/#public-static-functions","title":"Public Static Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TValueCodec/#static-texpected-void-snapigameframeworktvaluecodec-t-encodeconst-t-value-cerealbinaryoutputarchive-archive-const-tserializationcontext-context","title":"<code>static TExpected&lt; void &gt; SnAPI::GameFramework::TValueCodec&lt; T &gt;::Encode(const T &amp;Value, cereal::BinaryOutputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Parameters</p> <ul> <li><code>Value</code>: </li> <li><code>Archive</code>: </li> <li><code>Context</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TValueCodec/#static-texpected-t-snapigameframeworktvaluecodec-t-decodecerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>static TExpected&lt; T &gt; SnAPI::GameFramework::TValueCodec&lt; T &gt;::Decode(cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Parameters</p> <ul> <li><code>Archive</code>: </li> <li><code>Context</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TValueCodec/#static-texpected-void-snapigameframeworktvaluecodec-t-decodeintot-value-cerealbinaryinputarchive-archive-const-tserializationcontext-context","title":"<code>static TExpected&lt; void &gt; SnAPI::GameFramework::TValueCodec&lt; T &gt;::DecodeInto(T &amp;Value, cereal::BinaryInputArchive &amp;Archive, const TSerializationContext &amp;Context)</code>","text":"<p>Parameters</p> <ul> <li><code>Value</code>: </li> <li><code>Archive</code>: </li> <li><code>Context</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/","title":"SnAPI::GameFramework::TransparentStringEqual","text":"<p>Heterogeneous equality functor for string-key lookups.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/#public-types","title":"Public Types","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/#using-snapigameframeworktransparentstringequalis_transparent-void","title":"<code>using SnAPI::GameFramework::TransparentStringEqual::is_transparent = void</code>","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/#public-functions","title":"Public Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/#bool-snapigameframeworktransparentstringequaloperatorstdstring_view-left-stdstring_view-right-const-noexcept","title":"<code>bool SnAPI::GameFramework::TransparentStringEqual::operator()(std::string_view Left, std::string_view Right) const noexcept</code>","text":"<p>Parameters</p> <ul> <li><code>Left</code>: </li> <li><code>Right</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/#bool-snapigameframeworktransparentstringequaloperatorstdstring_view-left-const-stdstring-right-const-noexcept","title":"<code>bool SnAPI::GameFramework::TransparentStringEqual::operator()(std::string_view Left, const std::string &amp;Right) const noexcept</code>","text":"<p>Parameters</p> <ul> <li><code>Left</code>: </li> <li><code>Right</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/#bool-snapigameframeworktransparentstringequaloperatorconst-stdstring-left-stdstring_view-right-const-noexcept","title":"<code>bool SnAPI::GameFramework::TransparentStringEqual::operator()(const std::string &amp;Left, std::string_view Right) const noexcept</code>","text":"<p>Parameters</p> <ul> <li><code>Left</code>: </li> <li><code>Right</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringEqual/#bool-snapigameframeworktransparentstringequaloperatorconst-stdstring-left-const-stdstring-right-const-noexcept","title":"<code>bool SnAPI::GameFramework::TransparentStringEqual::operator()(const std::string &amp;Left, const std::string &amp;Right) const noexcept</code>","text":"<p>Parameters</p> <ul> <li><code>Left</code>: </li> <li><code>Right</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringHash/","title":"SnAPI::GameFramework::TransparentStringHash","text":"<p>Heterogeneous hash functor for string-key lookups.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringHash/#public-types","title":"Public Types","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringHash/#using-snapigameframeworktransparentstringhashis_transparent-void","title":"<code>using SnAPI::GameFramework::TransparentStringHash::is_transparent = void</code>","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringHash/#public-functions","title":"Public Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringHash/#size_t-snapigameframeworktransparentstringhashoperatorstdstring_view-value-const-noexcept","title":"<code>size_t SnAPI::GameFramework::TransparentStringHash::operator()(std::string_view Value) const noexcept</code>","text":"<p>Parameters</p> <ul> <li><code>Value</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TransparentStringHash/#size_t-snapigameframeworktransparentstringhashoperatorconst-stdstring-value-const-noexcept","title":"<code>size_t SnAPI::GameFramework::TransparentStringHash::operator()(const std::string &amp;Value) const noexcept</code>","text":"<p>Parameters</p> <ul> <li><code>Value</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/","title":"SnAPI::GameFramework::TypeInfo","text":"<p>Reflection metadata for a type.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#typeid-snapigameframeworktypeinfoid","title":"<code>TypeId SnAPI::GameFramework::TypeInfo::Id</code>","text":"<p>Type id (UUID).</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#stdstring-snapigameframeworktypeinfoname","title":"<code>std::string SnAPI::GameFramework::TypeInfo::Name</code>","text":"<p>Fully qualified type name.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#size_t-snapigameframeworktypeinfosize","title":"<code>size_t SnAPI::GameFramework::TypeInfo::Size</code>","text":"<p>sizeof(T).</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#size_t-snapigameframeworktypeinfoalign","title":"<code>size_t SnAPI::GameFramework::TypeInfo::Align</code>","text":"<p>alignof(T).</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#stdvectortypeid-snapigameframeworktypeinfobasetypes","title":"<code>std::vector&lt;TypeId&gt; SnAPI::GameFramework::TypeInfo::BaseTypes</code>","text":"<p>Base class TypeIds.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#stdvectorfieldinfo-snapigameframeworktypeinfofields","title":"<code>std::vector&lt;FieldInfo&gt; SnAPI::GameFramework::TypeInfo::Fields</code>","text":"<p>Field metadata.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#stdvectormethodinfo-snapigameframeworktypeinfomethods","title":"<code>std::vector&lt;MethodInfo&gt; SnAPI::GameFramework::TypeInfo::Methods</code>","text":"<p>Method metadata.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1TypeInfo/#stdvectorconstructorinfo-snapigameframeworktypeinfoconstructors","title":"<code>std::vector&lt;ConstructorInfo&gt; SnAPI::GameFramework::TypeInfo::Constructors</code>","text":"<p>Constructor metadata.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1UuidHash/","title":"SnAPI::GameFramework::UuidHash","text":"<p>Hash functor for UUID.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1UuidHash/#public-functions","title":"Public Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1UuidHash/#stdsize_t-snapigameframeworkuuidhashoperatorconst-uuid-id-const-noexcept","title":"<code>std::size_t SnAPI::GameFramework::UuidHash::operator()(const Uuid &amp;Id) const noexcept</code>","text":"<p>Compute a hash value for a UUID.</p> <p>Parameters</p> <ul> <li><code>Id</code>: UUID to hash.</li> </ul> <p>Returns: Hash value.</p> <p>Notes</p> <ul> <li>Combines High/Low with a 64-bit mix.</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1UuidParts/","title":"SnAPI::GameFramework::UuidParts","text":"<p>Split UUID representation for hashing or ABI transport.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1UuidParts/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1UuidParts/#uint64_t-snapigameframeworkuuidpartshigh","title":"<code>uint64_t SnAPI::GameFramework::UuidParts::High</code>","text":"<p>High 64 bits.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1UuidParts/#uint64_t-snapigameframeworkuuidpartslow","title":"<code>uint64_t SnAPI::GameFramework::UuidParts::Low</code>","text":"<p>Low 64 bits.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ValueCodecRegistry_1_1CodecEntry/","title":"SnAPI::GameFramework::ValueCodecRegistry::CodecEntry","text":"<p>Entry storing encode/decode callbacks.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ValueCodecRegistry_1_1CodecEntry/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1ValueCodecRegistry_1_1CodecEntry/#encodefn-snapigameframeworkvaluecodecregistrycodecentryencode","title":"<code>EncodeFn SnAPI::GameFramework::ValueCodecRegistry::CodecEntry::Encode</code>","text":"<p>Encode callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ValueCodecRegistry_1_1CodecEntry/#decodefn-snapigameframeworkvaluecodecregistrycodecentrydecode","title":"<code>DecodeFn SnAPI::GameFramework::ValueCodecRegistry::CodecEntry::Decode</code>","text":"<p>Decode callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1ValueCodecRegistry_1_1CodecEntry/#decodeintofn-snapigameframeworkvaluecodecregistrycodecentrydecodeinto","title":"<code>DecodeIntoFn SnAPI::GameFramework::ValueCodecRegistry::CodecEntry::DecodeInto</code>","text":"<p>Decode-into callback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1WorldPayload/","title":"SnAPI::GameFramework::WorldPayload","text":"<p>Serialized world payload.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1WorldPayload/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1WorldPayload/#nodegraphpayload-snapigameframeworkworldpayloadgraph","title":"<code>NodeGraphPayload SnAPI::GameFramework::WorldPayload::Graph</code>","text":"<p>World root graph payload.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableField/","title":"SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableField/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableField/#const-fieldinfo-snapigameframeworkanonymous_namespaceserializationcppserializablefieldfield","title":"<code>const FieldInfo* SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField::Field</code>","text":"<p>Reflected field metadata pointer.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableField/#const-valuecodecregistrycodecentry-snapigameframeworkanonymous_namespaceserializationcppserializablefieldcodec","title":"<code>const ValueCodecRegistry::CodecEntry* SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField::Codec</code>","text":"<p>Value codec pointer when direct codec serialization is available.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableField/#typeid-snapigameframeworkanonymous_namespaceserializationcppserializablefieldnestedtype","title":"<code>TypeId SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField::NestedType</code>","text":"<p>Nested reflected type id for recursive traversal fallback.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableField/#bool-snapigameframeworkanonymous_namespaceserializationcppserializablefieldhasnested","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField::HasNested</code>","text":"<p>True when nested reflected traversal is required.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableFieldCacheEntry/","title":"SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableFieldCacheEntry","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableFieldCacheEntry/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableFieldCacheEntry/#uint32_t-snapigameframeworkanonymous_namespaceserializationcppserializablefieldcacheentrycodecversion","title":"<code>uint32_t SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableFieldCacheEntry::CodecVersion</code>","text":"<p>Value-codec registry version used to build this cache.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableFieldCacheEntry/#bool-snapigameframeworkanonymous_namespaceserializationcppserializablefieldcacheentrytypefound","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableFieldCacheEntry::TypeFound</code>","text":"<p>False when type metadata was not registered at build time.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1SerializableFieldCacheEntry/#stdvectorserializablefield-snapigameframeworkanonymous_namespaceserializationcppserializablefieldcacheentryfields","title":"<code>std::vector&lt;SerializableField&gt; SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableFieldCacheEntry::Fields</code>","text":"<p>Flattened ordered field plan for serializer traversal.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/","title":"SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/#public-members","title":"Public Members","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/#stdunordered_maptypeid-bool-uuidhash-snapigameframeworkanonymous_namespaceserializationcpptypevisitguardvisited","title":"<code>std::unordered_map&lt;TypeId, bool, UuidHash&gt;&amp; SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard::Visited</code>","text":"<p>Shared visited-type set for recursion/cycle detection.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/#typeid-snapigameframeworkanonymous_namespaceserializationcpptypevisitguardtype","title":"<code>TypeId SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard::Type</code>","text":"<p>Type currently being traversed.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/#bool-snapigameframeworkanonymous_namespaceserializationcpptypevisitguardinserted","title":"<code>bool SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard::Inserted</code>","text":"<p>True when this guard inserted new visited entry.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/#public-functions","title":"Public Functions","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/#snapigameframeworkanonymous_namespaceserializationcpptypevisitguardtypevisitguardstdunordered_map-typeid-bool-uuidhash-invisited-const-typeid-intype","title":"<code>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard::TypeVisitGuard(std::unordered_map&lt; TypeId, bool, UuidHash &gt; &amp;InVisited, const TypeId &amp;InType)</code>","text":"<p>Parameters</p> <ul> <li><code>InVisited</code>: </li> <li><code>InType</code>:</li> </ul>"},{"location":"api/structSnAPI_1_1GameFramework_1_1anonymous__namespace_02Serialization_8cpp_03_1_1TypeVisitGuard/#snapigameframeworkanonymous_namespaceserializationcpptypevisitguardtypevisitguard","title":"<code>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard::~TypeVisitGuard()</code>","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1detail_1_1TArgStorage/","title":"SnAPI::GameFramework::detail::TArgStorage","text":"<p>Storage selection for reflected arguments.</p>"},{"location":"api/structSnAPI_1_1GameFramework_1_1detail_1_1TArgStorage/#public-types","title":"Public Types","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1detail_1_1TArgStorage/#using-snapigameframeworkdetailtargstorage-arg-raw-stdremove_reference_targ","title":"<code>using SnAPI::GameFramework::detail::TArgStorage&lt; Arg &gt;::Raw = std::remove_reference_t&lt;Arg&gt;</code>","text":""},{"location":"api/structSnAPI_1_1GameFramework_1_1detail_1_1TArgStorage/#using-snapigameframeworkdetailtargstorage-arg-type-stdconditional_tstdis_lvalue_reference_varg-stdreference_wrapperraw-stdremove_cvref_targ","title":"<code>using SnAPI::GameFramework::detail::TArgStorage&lt; Arg &gt;::Type = std::conditional_t&lt;std::is_lvalue_reference_v&lt;Arg&gt;, std::reference_wrapper&lt;Raw&gt;, std::remove_cvref_t&lt;Arg&gt;&gt;</code>","text":""},{"location":"api/structSnGfUuid/","title":"SnGfUuid","text":"<p>C ABI representation of a UUID.</p>"},{"location":"api/structSnGfUuid/#public-members","title":"Public Members","text":""},{"location":"api/structSnGfUuid/#uint64_t-sngfuuidhigh","title":"<code>uint64_t SnGfUuid::High</code>","text":"<p>High 64 bits.</p>"},{"location":"api/structSnGfUuid/#uint64_t-sngfuuidlow","title":"<code>uint64_t SnGfUuid::Low</code>","text":"<p>Low 64 bits.</p>"},{"location":"api/structSnGfVariantHandle/","title":"SnGfVariantHandle","text":"<p>Opaque handle to a Variant owned by the runtime.</p>"},{"location":"api/structSnGfVariantHandle/#public-members","title":"Public Members","text":""},{"location":"api/structSnGfVariantHandle/#void-sngfvarianthandleptr","title":"<code>void* SnGfVariantHandle::Ptr</code>","text":"<p>Opaque pointer to internal Variant storage.</p>"},{"location":"api/types/","title":"Types","text":"<ul> <li>AlwaysActivePolicy</li> <li>DemoComponent</li> <li>DemoNode</li> <li>PerfComponentA</li> <li>PerfComponentB</li> <li>SnAPI::GameFramework::BaseNode</li> <li>SnAPI::GameFramework::ComponentSerializationRegistry</li> <li>SnAPI::GameFramework::ComponentSerializationRegistry::Entry</li> <li>SnAPI::GameFramework::ComponentTypeRegistry</li> <li>SnAPI::GameFramework::ConstructorInfo</li> <li>SnAPI::GameFramework::EnableFlags</li> <li>SnAPI::GameFramework::EnableFlags&lt; EFieldFlagBits &gt;</li> <li>SnAPI::GameFramework::EnableFlags&lt; EMethodFlagBits &gt;</li> <li>SnAPI::GameFramework::Error</li> <li>SnAPI::GameFramework::FieldInfo</li> <li>SnAPI::GameFramework::GameRuntime</li> <li>SnAPI::GameFramework::GameRuntimeSettings</li> <li>SnAPI::GameFramework::GameRuntimeTickSettings</li> <li>SnAPI::GameFramework::HandleHash</li> <li>SnAPI::GameFramework::IComponent</li> <li>SnAPI::GameFramework::IComponentStorage</li> <li>SnAPI::GameFramework::ILevel</li> <li>SnAPI::GameFramework::INode</li> <li>SnAPI::GameFramework::IScriptEngine</li> <li>SnAPI::GameFramework::IWorld</li> <li>SnAPI::GameFramework::JobSystem</li> <li>SnAPI::GameFramework::Level</li> <li>SnAPI::GameFramework::LevelPayload</li> <li>SnAPI::GameFramework::LevelSerializer</li> <li>SnAPI::GameFramework::MethodInfo</li> <li>SnAPI::GameFramework::NodeComponentPayload</li> <li>SnAPI::GameFramework::NodeGraph</li> <li>SnAPI::GameFramework::NodeGraphPayload</li> <li>SnAPI::GameFramework::NodeGraphSerializer</li> <li>SnAPI::GameFramework::NodePayload</li> <li>SnAPI::GameFramework::ObjectRegistry</li> <li>SnAPI::GameFramework::ObjectRegistry::Entry</li> <li>SnAPI::GameFramework::RelevanceComponent</li> <li>SnAPI::GameFramework::RelevanceContext</li> <li>SnAPI::GameFramework::RelevancePolicyRegistry</li> <li>SnAPI::GameFramework::RelevancePolicyRegistry::PolicyInfo</li> <li>SnAPI::GameFramework::ScriptBindings</li> <li>SnAPI::GameFramework::ScriptComponent</li> <li>SnAPI::GameFramework::ScriptRuntime</li> <li>SnAPI::GameFramework::TComponentStorage</li> <li>SnAPI::GameFramework::TExpectedRef</li> <li>SnAPI::GameFramework::TFlags</li> <li>SnAPI::GameFramework::THandle</li> <li>SnAPI::GameFramework::TObjectPool</li> <li>SnAPI::GameFramework::TObjectPool::Entry</li> <li>SnAPI::GameFramework::TSerializationContext</li> <li>SnAPI::GameFramework::TTypeBuilder</li> <li>SnAPI::GameFramework::TTypeName</li> <li>SnAPI::GameFramework::TTypeRegistrar</li> <li>SnAPI::GameFramework::TValueCodec</li> <li>SnAPI::GameFramework::TransformComponent</li> <li>SnAPI::GameFramework::TransparentStringEqual</li> <li>SnAPI::GameFramework::TransparentStringHash</li> <li>SnAPI::GameFramework::TypeAutoRegistry</li> <li>SnAPI::GameFramework::TypeInfo</li> <li>SnAPI::GameFramework::TypeRegistry</li> <li>SnAPI::GameFramework::UuidHash</li> <li>SnAPI::GameFramework::UuidParts</li> <li>SnAPI::GameFramework::ValueCodecRegistry</li> <li>SnAPI::GameFramework::ValueCodecRegistry::CodecEntry</li> <li>SnAPI::GameFramework::Variant</li> <li>SnAPI::GameFramework::VariantView</li> <li>SnAPI::GameFramework::World</li> <li>SnAPI::GameFramework::WorldPayload</li> <li>SnAPI::GameFramework::WorldSerializer</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TLevelFactory</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TNodeGraphFactory</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineFactories.cpp}::TWorldFactory</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::LevelPayloadSerializer</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::NodeGraphPayloadSerializer</li> <li>SnAPI::GameFramework::anonymous_namespace{AssetPipelineSerializers.cpp}::WorldPayloadSerializer</li> <li>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::MemoryReadStreambuf</li> <li>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableField</li> <li>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::SerializableFieldCacheEntry</li> <li>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::TypeVisitGuard</li> <li>SnAPI::GameFramework::anonymous_namespace{Serialization.cpp}::VectorWriteStreambuf</li> <li>SnAPI::GameFramework::detail::TArgStorage</li> <li>SnGfUuid</li> <li>SnGfVariantHandle</li> </ul>"},{"location":"tutorials/assetpipeline/","title":"AssetPipeline Integration","text":"<p>This page shows the full flow to package a <code>World</code>/<code>Level</code>/<code>NodeGraph</code> into <code>.snpak</code> and load it back through <code>AssetManager</code>.</p> <p>The same pattern is used by <code>examples/FeatureShowcase</code> and <code>examples/WorldPerfBenchmark</code>.</p>"},{"location":"tutorials/assetpipeline/#1-build-runtime-data","title":"1. Build Runtime Data","text":"<pre><code>RegisterBuiltinTypes();\n\nWorld WorldInstance(\"GameWorld\");\nauto LevelHandle = WorldInstance.CreateLevel(\"MainLevel\");\nauto LevelRef = WorldInstance.LevelRef(LevelHandle.value());\n\nauto GraphHandle = LevelRef-&gt;CreateGraph(\"Gameplay\");\nauto GraphRef = LevelRef-&gt;Graph(GraphHandle.value());\n\n(void)GraphRef-&gt;CreateNode(\"Player\");\n</code></pre>"},{"location":"tutorials/assetpipeline/#2-serialize-to-payload-bytes","title":"2. Serialize to Payload Bytes","text":"<pre><code>auto WorldPayloadResult = WorldSerializer::Serialize(WorldInstance);\nif (!WorldPayloadResult)\n{\n    return;\n}\n\nstd::vector&lt;uint8_t&gt; WorldBytes;\nif (!SerializeWorldPayload(WorldPayloadResult.value(), WorldBytes))\n{\n    return;\n}\n</code></pre>"},{"location":"tutorials/assetpipeline/#3-write-a-snpak","title":"3. Write a <code>.snpak</code>","text":"<pre><code>#include \"AssetPackWriter.h\"\n\n::SnAPI::AssetPipeline::AssetPackWriter Writer;\n\n::SnAPI::AssetPipeline::AssetPackEntry Entry;\nEntry.Id = AssetPipelineAssetIdFromName(\"demo.world\");\nEntry.AssetKind = AssetKindWorld();\nEntry.Name = \"demo.world\";\nEntry.VariantKey = \"\";\nEntry.Cooked = ::SnAPI::AssetPipeline::TypedPayload(\n    PayloadWorld(),\n    WorldSerializer::kSchemaVersion,\n    WorldBytes);\n\nWriter.AddAsset(std::move(Entry));\n\nauto WriteResult = Writer.Write(\"DemoContent.snpak\");\nif (!WriteResult)\n{\n    return;\n}\n</code></pre>"},{"location":"tutorials/assetpipeline/#4-register-gameframework-payload-runtime-factories","title":"4. Register GameFramework Payload + Runtime Factories","text":"<pre><code>#include \"AssetManager.h\"\n\n::SnAPI::AssetPipeline::AssetManager Manager;\n\nRegisterAssetPipelinePayloads(Manager.GetRegistry());\nManager.GetRegistry().Freeze();\nRegisterAssetPipelineFactories(Manager);\n</code></pre> <p>Why this order matters:</p> <ol> <li>payload serializers must be in the payload registry</li> <li>optional <code>Freeze()</code> locks registry for fast read-only lookups</li> <li>runtime factories enable <code>Load&lt;T&gt;</code>/<code>Get&lt;T&gt;</code> materialization</li> </ol>"},{"location":"tutorials/assetpipeline/#5-mount-and-load","title":"5. Mount and Load","text":"<pre><code>auto MountResult = Manager.MountPack(\"DemoContent.snpak\");\nif (!MountResult)\n{\n    return;\n}\n\nauto LoadedWorld = Manager.Load&lt;World&gt;(\"demo.world\");\nif (!LoadedWorld)\n{\n    return;\n}\n</code></pre> <p>The returned world can be traversed normally (<code>Levels()</code>, <code>CreateNode</code>, <code>NodePool().ForEach</code>, etc.).</p>"},{"location":"tutorials/assetpipeline/#6-common-failure-cases","title":"6. Common Failure Cases","text":"<ul> <li><code>Type not registered</code> on load:<ul> <li><code>RegisterBuiltinTypes()</code> was not called early enough.</li> <li>The type\u2019s reflection macro was never linked/referenced.</li> </ul> </li> <li><code>Failed to load world from AssetManager</code>:<ul> <li>payload serializers/factories were not registered.</li> <li>payload type/schema mismatch.</li> </ul> </li> <li>Objects deserialize but links are missing:<ul> <li>verify handles/UUID fields were reflected and serialized.</li> </ul> </li> </ul>"},{"location":"tutorials/assetpipeline/#7-compression-notes","title":"7. Compression Notes","text":"<p>Compression behavior is primarily configured in SnAPI.AssetPipeline (writer settings and optional per-entry overrides). GameFramework payload integration is compatible with those settings because it only provides payload bytes and factories.</p> <p>Next: Networking Replication and RPC</p>"},{"location":"tutorials/audio/","title":"Audio Components","text":"<p>This page explains how audio is integrated into GameFramework through world-owned subsystems and components.</p>"},{"location":"tutorials/audio/#1-architecture","title":"1. Architecture","text":"<ul> <li><code>World</code> owns <code>AudioSystem</code>.</li> <li><code>World</code> also owns <code>NetworkSystem</code>, so audio gameplay RPC can route through world networking.</li> <li><code>World::Tick(...)</code> performs the per-frame <code>AudioSystem::Update(...)</code>.</li> <li><code>AudioListenerComponent</code> writes listener transform each tick.</li> <li><code>AudioSourceComponent</code> controls emitter, sound loading, playback, and spatial settings.</li> </ul> <p>Design goal: gameplay code accesses systems through world context (<code>Owner()-&gt;World()-&gt;Audio()</code> pattern), not globals.</p>"},{"location":"tutorials/audio/#2-add-a-listener-to-a-camera-node","title":"2. Add a Listener to a Camera Node","text":"<pre><code>auto CameraNodeResult = Graph.CreateNode(\"Camera\");\nauto* CameraNode = CameraNodeResult-&gt;Borrowed();\n\nauto CameraTransform = CameraNode-&gt;Add&lt;TransformComponent&gt;();\nCameraTransform-&gt;Position = Vec3(0.0f, 2.0f, -6.0f);\n\nauto Listener = CameraNode-&gt;Add&lt;AudioListenerComponent&gt;();\nListener-&gt;Active(true);\n</code></pre> <p>What happens:</p> <ul> <li><code>OnCreate()</code> initializes audio system lazily.</li> <li>Each tick, listener transform is pushed to <code>AudioEngine</code>.</li> <li>The audio backend frame update itself is handled once by <code>World::Tick(...)</code>.</li> </ul>"},{"location":"tutorials/audio/#3-add-a-source-to-an-actor-node","title":"3. Add a Source to an Actor Node","text":"<pre><code>auto ActorNodeResult = Graph.CreateNode(\"Speaker\");\nauto* ActorNode = ActorNodeResult-&gt;Borrowed();\n\nauto ActorTransform = ActorNode-&gt;Add&lt;TransformComponent&gt;();\nActorTransform-&gt;Position = Vec3(3.0f, 0.0f, 0.0f);\n\nauto Source = ActorNode-&gt;Add&lt;AudioSourceComponent&gt;();\nSource-&gt;EditSettings().SoundPath = \"assets/audio/loop.wav\";\nSource-&gt;EditSettings().Streaming = false;\nSource-&gt;EditSettings().AutoPlay = true;\nSource-&gt;EditSettings().Looping = true;\nSource-&gt;EditSettings().Volume = 0.8f;\nSource-&gt;EditSettings().MinDistance = 1.0f;\nSource-&gt;EditSettings().MaxDistance = 40.0f;\nSource-&gt;EditSettings().Rolloff = 1.0f;\n</code></pre>"},{"location":"tutorials/audio/#4-runtime-control","title":"4. Runtime Control","text":"<pre><code>Source-&gt;Play();\nSource-&gt;Stop();\n\nbool Loaded = Source-&gt;IsLoaded();\nbool Playing = Source-&gt;IsPlaying();\n\nSource-&gt;LoadSound(\"assets/audio/one_shot.wav\", false);\nSource-&gt;UnloadSound();\n</code></pre> <p><code>AudioSourceComponent</code> keeps emitter state synced with current settings and owner transform.</p>"},{"location":"tutorials/audio/#5-networked-playback-flow","title":"5. Networked Playback Flow","text":"<p><code>AudioSourceComponent</code> exposes gameplay methods (<code>Play</code>, <code>Stop</code>) and internally routes through <code>IComponent::CallRPC(...)</code> when networking is attached.</p> <pre><code>void AudioSourceComponent::Play()\n{\n    if (CallRPC(\"PlayServer\"))\n    {\n        return;\n    }\n    PlayClient();\n}\n</code></pre> <p><code>Play()</code> flow:</p> <ol> <li>Client call: <code>CallRPC(\"PlayServer\")</code> forwards to server.</li> <li>Server <code>PlayServer</code>: <code>CallRPC(\"PlayClient\")</code> multicasts.</li> <li><code>PlayClient</code>: executes playback on listening peers.</li> </ol> <p><code>Stop()</code> follows the same pattern (<code>Stop -&gt; StopServer -&gt; StopClient</code>).</p> <p>Dedicated server guard:</p> <ul> <li><code>PlayClient</code>/<code>StopClient</code> do not emit audio on non-listen dedicated server instances.</li> <li>Listen server will execute local playback plus multicast to clients.</li> </ul>"},{"location":"tutorials/audio/#6-what-actually-replicates","title":"6. What Actually Replicates","text":"<p>By default in built-in reflection registration:</p> <ul> <li><code>AudioSourceComponent::Settings</code> is replication-visible as a container field.</li> <li>Inside <code>Settings</code>, only <code>SoundPath</code> is flagged for replication.</li> <li>Other settings (<code>Volume</code>, <code>Looping</code>, distances, etc.) are local unless you add replication flags for them.</li> </ul> <p>Important consequence:</p> <ul> <li>current default network payload for settings carries the path string (<code>SoundPath</code>), not the full settings struct.</li> <li>audio bytes are not replicated; clients must resolve/load the referenced asset locally.</li> </ul>"},{"location":"tutorials/audio/#7-field-flags-vs-value-codec-nested-structs","title":"7. Field Flags vs Value Codec (Nested Structs)","text":"<p>Replication for a reflected field behaves as follows:</p> <ul> <li>if the field type has a registered value codec, that codec serializes the full field value.</li> <li>if no codec exists, replication walks nested reflected fields and serializes only nested fields marked with replication flags.</li> </ul> <p>For <code>AudioSourceComponent::Settings</code>, default behavior is nested-field traversal, so only flagged members replicate.</p>"},{"location":"tutorials/audio/#8-important-runtime-notes","title":"8. Important Runtime Notes","text":"<ul> <li>Source/listener components rely on owner node transform if <code>TransformComponent</code> exists.</li> <li>Audio system initialization is lazy (<code>Initialize()</code> called as needed).</li> <li>Audio components are ordinary reflected components, so they serialize like other components.</li> </ul>"},{"location":"tutorials/audio/#9-minimal-frame-pump","title":"9. Minimal Frame Pump","text":"<pre><code>while (Running)\n{\n    const float Dt = 1.0f / 60.0f;\n    WorldInstance.Tick(Dt);\n    WorldInstance.LateTick(Dt);\n    WorldInstance.EndFrame();\n}\n</code></pre> <p>Listener/source updates happen through normal component ticking. Audio backend update is world-owned, not component-owned.</p>"},{"location":"tutorials/audio/#10-troubleshooting","title":"10. Troubleshooting","text":"<ul> <li> <p>No audio output:</p> <ul> <li>verify audio asset path in <code>Settings.SoundPath</code></li> <li>ensure listener exists and is active</li> <li>ensure source was loaded/played</li> </ul> </li> <li> <p>Replicated play event arrives but no sound:</p> <ul> <li>ensure the client machine can resolve the same <code>SoundPath</code></li> <li>confirm the source node/component has <code>Replicated(true)</code> enabled</li> </ul> </li> <li> <p>Spatial audio sounds wrong:</p> <ul> <li>check transform values and distance parameters (<code>MinDistance</code>, <code>MaxDistance</code>, <code>Rolloff</code>)</li> </ul> </li> </ul> <p>Next: Testing and Validation</p>"},{"location":"tutorials/networking/","title":"Networking Replication and RPC","text":"<p>This page explains how SnAPI.GameFramework networking works with SnAPI.Networking.</p>"},{"location":"tutorials/networking/#1-big-picture","title":"1. Big Picture","text":"<ul> <li><code>World</code> owns <code>NetworkSystem</code> (session + transport + replication bridge + RPC bridge wiring).</li> <li><code>NetworkSystem</code> is owner-only for network runtime resources (no external session attach path).</li> <li><code>NetReplicationBridge</code> maps graph objects to replication entities and applies spawn/update/despawn payloads.</li> <li><code>NetRpcBridge</code> maps reflected methods to network RPC calls.</li> <li><code>INode::CallRPC(...)</code> and <code>IComponent::CallRPC(...)</code> are gameplay-facing helpers that route by reflected method flags + network role.</li> <li><code>World::Tick</code> / <code>World::EndFrame</code> pump networking; <code>GameRuntime::Update</code> orchestrates world lifecycle phases.</li> <li>Reflection metadata (<code>FieldFlags</code>, <code>MethodFlags</code>) controls what is eligible.</li> </ul>"},{"location":"tutorials/networking/#2-replication-requires-two-things","title":"2. Replication Requires Two Things","text":"<p>A field replicates only when both are true:</p> <ol> <li>the field is marked with <code>EFieldFlagBits::Replication</code></li> <li>the owning runtime object has replication enabled:<ul> <li><code>Node-&gt;Replicated(true)</code></li> <li><code>Component-&gt;Replicated(true)</code></li> </ul> </li> </ol>"},{"location":"tutorials/networking/#3-define-a-replicated-component","title":"3. Define a Replicated Component","text":"<pre><code>struct ReplicatedTransformComponent final : public IComponent\n{\n    static constexpr const char* kTypeName = \"MyGame::ReplicatedTransformComponent\";\n\n    Vec3 Position{};\n    Vec3 Rotation{};\n    Vec3 Scale{1.0f, 1.0f, 1.0f};\n};\n\nSNAPI_REFLECT_TYPE(ReplicatedTransformComponent, (TTypeBuilder&lt;ReplicatedTransformComponent&gt;(ReplicatedTransformComponent::kTypeName)\n    .Field(\"Position\", &amp;ReplicatedTransformComponent::Position, EFieldFlagBits::Replication)\n    .Field(\"Rotation\", &amp;ReplicatedTransformComponent::Rotation, EFieldFlagBits::Replication)\n    .Field(\"Scale\", &amp;ReplicatedTransformComponent::Scale, EFieldFlagBits::Replication)\n    .Constructor&lt;&gt;()\n    .Register()));\n</code></pre>"},{"location":"tutorials/networking/#4-server-setup-recommended-gameruntime-path","title":"4. Server Setup (Recommended <code>GameRuntime</code> Path)","text":"<pre><code>GameRuntime Runtime;\nGameRuntimeSettings Settings{};\nSettings.WorldName = \"ServerWorld\";\nSettings.Tick.EnableFixedTick = false;\n\nGameRuntimeNetworkingSettings Net{};\nNet.Role = ESessionRole::Server;\nNet.Net = Config;\nNet.BindAddress = \"0.0.0.0\";\nNet.BindPort = 7777;\nNet.AutoConnect = false;\nSettings.Networking = Net;\n\nauto InitResult = Runtime.Init(Settings);\nif (!InitResult)\n{\n    // handle error\n}\n\nauto&amp; ServerWorld = Runtime.World();\nauto NodeResult = ServerWorld.CreateNode(\"Cube_0\");\nauto* Node = NodeResult-&gt;Borrowed();\nNode-&gt;Replicated(true);\n\nauto TransformResult = Node-&gt;Add&lt;ReplicatedTransformComponent&gt;();\nauto* Transform = &amp;*TransformResult;\nTransform-&gt;Replicated(true);\n</code></pre> <p>During runtime, update server-side fields and call <code>Runtime.Update(DeltaSeconds)</code>. Clients receive spawn/update automatically.</p> <p>There is no separate <code>AttachSession(...)</code> step in GameFramework anymore. The world networking subsystem owns and configures session/transport from <code>Settings.Networking</code>.</p>"},{"location":"tutorials/networking/#5-client-setup","title":"5. Client Setup","text":"<pre><code>GameRuntime Runtime;\nGameRuntimeSettings Settings{};\nSettings.WorldName = \"ClientWorld\";\nSettings.Tick.EnableFixedTick = false;\n\nGameRuntimeNetworkingSettings Net{};\nNet.Role = ESessionRole::Client;\nNet.Net = Config;\nNet.BindAddress = \"0.0.0.0\";\nNet.BindPort = 0; // ephemeral local port\nNet.ConnectAddress = \"127.0.0.1\";\nNet.ConnectPort = 7777;\nNet.AutoConnect = true;\nSettings.Networking = Net;\n\nauto InitResult = Runtime.Init(Settings);\nif (!InitResult)\n{\n    // handle error\n}\n\nauto&amp; ClientWorld = Runtime.World();\n</code></pre> <p>As packets arrive, client world objects are created/updated by the bridge.</p>"},{"location":"tutorials/networking/#6-why-nodes-appear-on-client-without-spawn-rpc","title":"6. Why Nodes Appear on Client Without Spawn RPC","text":"<p>Node/component creation is part of replication spawn payload handling (<code>OnSpawn</code>), not a separate explicit gameplay RPC call.</p> <p>That is why you can see client objects appear even when you only configured replication.</p> <p>Identity is preserved with object UUIDs and replication entity IDs carried in payload headers.</p>"},{"location":"tutorials/networking/#7-process-model-two-executables","title":"7. Process Model (Two Executables)","text":"<p><code>examples/MultiplayerExample</code> is designed for separate processes:</p> <pre><code>./MultiplayerExample --server\n./MultiplayerExample --client --host &lt;server-ip&gt;\n</code></pre> <p>This is the intended model for real deployment.</p>"},{"location":"tutorials/networking/#8-connection-diagnostics-recommended","title":"8. Connection Diagnostics (Recommended)","text":"<p>Use <code>INetSessionListener</code> and periodic <code>DumpConnections(...)</code> logging. This helps catch pacing/reliability backpressure and disconnect reasons quickly.</p> <p>The multiplayer example includes this pattern (<code>SessionListener</code>, <code>PrintConnectionDump</code>).</p> <p>Important counters in dumps:</p> <ul> <li><code>pending_rel</code>: reliable messages queued/in-flight.</li> <li><code>pending_unrel</code>: queued/in-flight unreliable messages.</li> <li><code>pkt_sent</code>, <code>pkt_acked</code>, <code>pkt_lost</code>: transport packet stats, not direct gameplay event counts.</li> </ul>"},{"location":"tutorials/networking/#interpreting-packet-loss-correctly","title":"Interpreting packet loss correctly","text":"<p>Seeing non-zero <code>pkt_lost</code> (especially right after connect) is normal on UDP-style transport. It does not automatically mean gameplay replication is broken.</p> <p>Use this rule of thumb:</p> <ul> <li><code>pending_rel</code> keeps climbing and never drains: reliable path is unhealthy.</li> <li><code>pending_rel</code> drains to <code>0</code> and gameplay looks correct: occasional packet loss is being recovered as designed.</li> </ul>"},{"location":"tutorials/networking/#9-reliable-vs-unreliable-channels","title":"9. Reliable vs Unreliable Channels","text":"<p>Reliable and unreliable traffic are separate channel paths with separate queueing/ordering behavior.</p> <ul> <li>Reliable channels retry until acked.</li> <li>Unreliable sequenced traffic favors new state and may drop old state under loss/backpressure.</li> </ul> <p>This is why high-rate transform updates are usually unreliable-sequenced while gameplay-critical actions (spawn/ownership/authoritative state changes) stay reliable.</p>"},{"location":"tutorials/networking/#10-reliable-window-backpressure","title":"10. Reliable Window Backpressure","text":"<p>SnAPI.Networking uses ACK-mask-based reliable tracking. To keep a reliable message ackable, sender-side in-flight reliable depth is window-limited.</p> <p>Behavior when pressure is high:</p> <ul> <li>new reliable payloads are queued/deferred,</li> <li>they are sent once earlier reliable payloads are acked,</li> <li>they are not silently dropped.</li> </ul> <p>Result: under sustained overload you get higher latency before delivery, not silent data loss.</p>"},{"location":"tutorials/networking/#11-reflection-rpc-optional-but-powerful","title":"11. Reflection RPC (Optional but Powerful)","text":"<p>Mark methods for RPC in reflection metadata:</p> <pre><code>class WeaponComponent final : public IComponent\n{\npublic:\n    static constexpr const char* kTypeName = \"MyGame::WeaponComponent\";\n\n    void ServerSetFiring(bool Value) { m_firing = Value; }\n\nprivate:\n    bool m_firing = false;\n};\n\nSNAPI_REFLECT_COMPONENT(WeaponComponent, (TTypeBuilder&lt;WeaponComponent&gt;(WeaponComponent::kTypeName)\n    .Method(\"ServerSetFiring\",\n            &amp;WeaponComponent::ServerSetFiring,\n            EMethodFlagBits::RpcReliable | EMethodFlagBits::RpcNetServer)\n    .Constructor&lt;&gt;()\n    .Register()));\n</code></pre> <p>Use world-owned RPC bridge + service:</p> <pre><code>auto* Session = WorldInstance.Networking().Session();\nauto* RpcBridge = WorldInstance.Networking().RpcBridge();\nauto Rpc = WorldInstance.Networking().Rpc();\n\nif (!Session || !RpcBridge || !Rpc)\n{\n    return;\n}\n</code></pre> <p>Call by reflected method name:</p> <pre><code>std::array&lt;Variant, 1&gt; Args{Variant::FromValue(true)};\nRpcBridge-&gt;Call(ConnectionHandle,\n                *WeaponComponentPtr,\n                \"ServerSetFiring\",\n                Args);\n</code></pre> <p><code>NetRpcBridge</code> resolves method metadata, serializes arguments via <code>ValueCodecRegistry</code>, and routes through SnAPI.Networking RPC.</p>"},{"location":"tutorials/networking/#12-gameplay-rpc-dispatch-pattern-callrpc","title":"12. Gameplay RPC Dispatch Pattern (<code>CallRPC</code>)","text":"<p>Most gameplay code should avoid touching <code>NetRpcBridge</code> directly. Use <code>INode::CallRPC(...)</code> / <code>IComponent::CallRPC(...)</code> from your gameplay methods:</p> <pre><code>void AudioSourceComponent::Play()\n{\n    if (CallRPC(\"PlayServer\"))\n    {\n        return;\n    }\n    PlayClient();\n}\n\nvoid AudioSourceComponent::PlayServer()\n{\n    m_playRequested = true;\n    if (CallRPC(\"PlayClient\"))\n    {\n        return;\n    }\n    PlayClient();\n}\n</code></pre> <p><code>CallRPC(...)</code> behavior:</p> <ul> <li>resolves reflected methods by name + argument type list (including base types)</li> <li>routes using method flags:<ul> <li><code>RpcNetServer</code>: server invokes locally, client forwards to server</li> <li><code>RpcNetClient</code>: client invokes locally, server forwards to client</li> <li><code>RpcNetMulticast</code>: server multicasts, clients invoke locally</li> </ul> </li> <li>returns <code>true</code> when the call was handled (local invoke or queued network call)</li> <li>returns <code>false</code> when method/route cannot be resolved so caller can apply local fallback behavior</li> </ul> <p>For components, <code>TypeKey</code> is assigned automatically during <code>Add&lt;T&gt;()</code> / <code>AddWithId&lt;T&gt;()</code>, so component call sites do not need to pass type ids manually.</p>"},{"location":"tutorials/networking/#13-common-replication-and-rpc-problems","title":"13. Common Replication and RPC Problems","text":"<ul> <li> <p>Objects never replicate:</p> <ul> <li>forgot <code>Replicated(true)</code> on node/component</li> <li>forgot <code>EFieldFlagBits::Replication</code> on fields</li> </ul> </li> <li> <p><code>CallRPC(...)</code> returns false unexpectedly:</p> <ul> <li>method name/signature does not match reflected metadata</li> <li>method exists but is missing RPC flags</li> <li>client path has no active primary connection/session</li> </ul> </li> <li> <p>Initial spawn works, then updates stop:</p> <ul> <li>inspect connection dumps for pending reliable growth/disconnect reasons</li> <li>check pacing/MTU settings in <code>NetConfig</code></li> </ul> </li> <li> <p>Type not found on remote:</p> <ul> <li>ensure reflected type macro is linked and <code>RegisterBuiltinTypes()</code> ran</li> </ul> </li> </ul> <p>Next: Audio Components</p>"},{"location":"tutorials/nodes_components/","title":"Nodes and Components","text":"<p>This page shows how to design gameplay types and attach reusable behavior.</p>"},{"location":"tutorials/nodes_components/#1-node-vs-component","title":"1. Node vs Component","text":"<p>Use a node when the thing needs identity in the hierarchy (name, children, transform owner, etc.).</p> <p>Use a component for modular data/behavior you can attach to many node types.</p>"},{"location":"tutorials/nodes_components/#2-define-a-custom-node-and-component","title":"2. Define a Custom Node and Component","text":"<p>Header (<code>MyGameplayTypes.h</code>):</p> <pre><code>#pragma once\n\n#include \"GameFramework.hpp\"\n\nusing namespace SnAPI::GameFramework;\n\nclass PlayerNode final : public BaseNode\n{\npublic:\n    static constexpr const char* kTypeName = \"MyGame::PlayerNode\";\n\n    int&amp; EditHealth() { return m_health; }\n    const int&amp; GetHealth() const { return m_health; }\n\n    void Tick(float DeltaSeconds) override\n    {\n        (void)DeltaSeconds;\n        // Player-specific logic\n    }\n\nprivate:\n    int m_health = 100;\n};\n\nclass MovementComponent final : public IComponent\n{\npublic:\n    static constexpr const char* kTypeName = \"MyGame::MovementComponent\";\n\n    float&amp; EditMaxSpeed() { return m_maxSpeed; }\n    const float&amp; GetMaxSpeed() const { return m_maxSpeed; }\n\n    void Tick(float DeltaSeconds) override\n    {\n        (void)DeltaSeconds;\n        // Movement logic using Owner().Borrowed()\n    }\n\nprivate:\n    float m_maxSpeed = 5.0f;\n};\n</code></pre>"},{"location":"tutorials/nodes_components/#3-register-reflection-once-in-a-cpp","title":"3. Register Reflection Once in a <code>.cpp</code>","text":"<p>Source (<code>MyGameplayTypes.cpp</code>):</p> <pre><code>#include \"MyGameplayTypes.h\"\n\nSNAPI_REFLECT_TYPE(PlayerNode, (TTypeBuilder&lt;PlayerNode&gt;(PlayerNode::kTypeName)\n    .Base&lt;BaseNode&gt;()\n    .Field(\"Health\", &amp;PlayerNode::EditHealth, &amp;PlayerNode::GetHealth)\n    .Constructor&lt;&gt;()\n    .Register()));\n\nSNAPI_REFLECT_COMPONENT(MovementComponent, (TTypeBuilder&lt;MovementComponent&gt;(MovementComponent::kTypeName)\n    .Field(\"MaxSpeed\", &amp;MovementComponent::EditMaxSpeed, &amp;MovementComponent::GetMaxSpeed)\n    .Constructor&lt;&gt;()\n    .Register()));\n</code></pre> <p>Notes:</p> <ul> <li><code>SNAPI_REFLECT_COMPONENT</code> is an alias of <code>SNAPI_REFLECT_TYPE</code>.</li> <li>For components, <code>TTypeBuilder&lt;&gt;::Register()</code> auto-registers component serialization support.</li> </ul>"},{"location":"tutorials/nodes_components/#4-spawn-nodes-and-add-components","title":"4. Spawn Nodes and Add Components","text":"<pre><code>World WorldInstance(\"GameWorld\");\nauto LevelHandle = WorldInstance.CreateLevel(\"MainLevel\");\nauto LevelRef = WorldInstance.LevelRef(LevelHandle.value());\n\nauto PlayerHandle = LevelRef-&gt;CreateNode&lt;PlayerNode&gt;(\"Player\");\nauto* Player = static_cast&lt;PlayerNode*&gt;(PlayerHandle-&gt;Borrowed());\nif (!Player)\n{\n    return;\n}\n\nPlayer-&gt;EditHealth() = 150;\n\nauto MoveResult = Player-&gt;Add&lt;MovementComponent&gt;();\nif (MoveResult)\n{\n    MoveResult-&gt;EditMaxSpeed() = 8.0f;\n}\n</code></pre>"},{"location":"tutorials/nodes_components/#5-query-and-remove-components","title":"5. Query and Remove Components","text":"<pre><code>if (Player-&gt;Has&lt;MovementComponent&gt;())\n{\n    auto Move = Player-&gt;Component&lt;MovementComponent&gt;();\n    if (Move)\n    {\n        float CurrentSpeed = Move-&gt;GetMaxSpeed();\n        (void)CurrentSpeed;\n    }\n\n    Player-&gt;Remove&lt;MovementComponent&gt;();\n}\n\n// Actual destruction happens at end-of-frame.\nWorldInstance.EndFrame();\n</code></pre>"},{"location":"tutorials/nodes_components/#6-tick-order-for-node-components","title":"6. Tick Order for Node + Components","text":"<p>For a node in an active tree:</p> <ol> <li><code>Node::Tick(...)</code></li> <li>all attached component <code>Tick(...)</code></li> <li>child nodes recursively</li> </ol> <p>Same pattern exists for <code>FixedTick</code> and <code>LateTick</code>.</p>"},{"location":"tutorials/nodes_components/#7-replication-gate-important","title":"7. Replication Gate (Important)","text":"<p>Component/field replication is not automatic just because a field has replication flags.</p> <p>You also need:</p> <ul> <li><code>Node-&gt;Replicated(true)</code></li> <li><code>Component-&gt;Replicated(true)</code></li> </ul> <p>Without those runtime flags, replication payloads for that object are skipped.</p>"},{"location":"tutorials/nodes_components/#8-role-helpers-and-callrpc","title":"8. Role Helpers and <code>CallRPC(...)</code>","text":"<p>Both <code>INode</code> and <code>IComponent</code> expose:</p> <ul> <li><code>IsServer()</code></li> <li><code>IsClient()</code></li> <li><code>IsListenServer()</code></li> <li><code>CallRPC(\"ReflectedMethodName\", args...)</code></li> </ul> <p>Example pattern for a server-authoritative action:</p> <pre><code>void WeaponComponent::StartFire()\n{\n    if (CallRPC(\"StartFireServer\"))\n    {\n        return;\n    }\n    StartFireClient();\n}\n\nvoid WeaponComponent::StartFireServer()\n{\n    if (CallRPC(\"StartFireClient\"))\n    {\n        return;\n    }\n    StartFireClient();\n}\n</code></pre> <p>This keeps gameplay call sites small while preserving server/client/multicast routing via reflection method flags.</p>"},{"location":"tutorials/nodes_components/#9-built-in-physics-components","title":"9. Built-In Physics Components","text":"<p>GameFramework includes physics-ready components:</p> <ul> <li><code>ColliderComponent</code><ul> <li>Shape and material/filter data (box/sphere/capsule, friction, restitution, layer, mask, trigger).</li> </ul> </li> <li><code>RigidBodyComponent</code><ul> <li>Creates backend body from node transform + collider settings and syncs transform each fixed tick.</li> </ul> </li> <li><code>CharacterMovementController</code><ul> <li>Movement/jump helper that drives a sibling <code>RigidBodyComponent</code> and performs grounded ray probes.</li> </ul> </li> </ul> <p>Minimal setup:</p> <pre><code>auto ActorResult = Graph.CreateNode(\"PhysicsActor\");\nauto* Actor = ActorResult-&gt;Borrowed();\nif (!Actor)\n{\n    return;\n}\n\nauto Transform = Actor-&gt;Add&lt;TransformComponent&gt;();\nTransform-&gt;Position = Vec3{0.0f, 2.0f, 0.0f};\n\nauto Collider = Actor-&gt;Add&lt;ColliderComponent&gt;();\nCollider-&gt;EditSettings().Shape = 1; // box\nCollider-&gt;EditSettings().HalfExtent = Vec3{0.5f, 0.5f, 0.5f};\n\nauto Body = Actor-&gt;Add&lt;RigidBodyComponent&gt;();\nBody-&gt;EditSettings().BodyType = 2; // dynamic\nBody-&gt;RecreateBody();              // apply edited settings immediately\n</code></pre> <p>For full physics flow (world bootstrap, stepping policy, character movement, queries/events), continue to the physics tutorials.</p>"},{"location":"tutorials/nodes_components/#10-built-in-renderer-components","title":"10. Built-In Renderer Components","text":"<p>When renderer integration is compiled in (<code>SNAPI_GF_ENABLE_RENDERER</code>), GameFramework also provides renderer bridge components:</p> <ul> <li><code>CameraComponent</code><ul> <li>Owns a renderer camera and can become world active camera.</li> <li>Can pull pose from sibling <code>TransformComponent</code> each tick.</li> </ul> </li> <li><code>StaticMeshComponent</code><ul> <li>Loads mesh asset data and creates per-instance render-object state.</li> <li>Supports visibility/shadow toggles and shared material instance overrides.</li> </ul> </li> <li><code>SkeletalMeshComponent</code><ul> <li>Same asset/render-object pattern with rigid animation playback helpers.</li> </ul> </li> </ul> <p>Minimal setup:</p> <pre><code>auto VisualResult = Graph.CreateNode(\"VisualActor\");\nauto* Visual = VisualResult-&gt;Borrowed();\nif (!Visual)\n{\n    return;\n}\n\nauto T = Visual-&gt;Add&lt;TransformComponent&gt;();\nT-&gt;Position = Vec3{0.0f, 0.0f, 0.0f};\n\nauto Mesh = Visual-&gt;Add&lt;StaticMeshComponent&gt;();\nMesh-&gt;EditSettings().MeshPath = \"assets/cube.obj\";\nMesh-&gt;EditSettings().Visible = true;\nMesh-&gt;EditSettings().CastShadows = true;\n</code></pre> <p>For renderer bootstrap, camera ownership, and the post-refactor <code>Mesh</code> vs <code>MeshRenderObject</code> model, read the renderer tutorial next.</p> <p>Next: Renderer Integration and Mesh Components</p>"},{"location":"tutorials/physics/","title":"Physics System and Components","text":"<p>This page is the beginner-to-practical guide for GameFramework physics integration. By the end, you should understand:</p> <ol> <li>how physics is owned and stepped in <code>World</code> / <code>GameRuntime</code></li> <li>how built-in physics components map onto runtime behavior</li> <li>when to use forces, impulses, or direct velocity control</li> <li>how to avoid the most common setup mistakes</li> </ol>"},{"location":"tutorials/physics/#1-physics-architecture-in-gameframework","title":"1. Physics Architecture in GameFramework","text":"<p>At runtime, physics is world-owned:</p> <ul> <li><code>World</code> owns one <code>PhysicsSystem</code>.</li> <li><code>PhysicsSystem</code> owns one active <code>SnAPI::Physics::IPhysicsScene</code>.</li> <li>Nodes/components access physics through <code>Owner()-&gt;World()-&gt;Physics()</code>.</li> </ul> <p>This follows the same subsystem pattern as networking and audio:</p> <ul> <li>no globals</li> <li>explicit lifetime</li> <li>one clear ownership path</li> </ul>"},{"location":"tutorials/physics/#2-bootstrap-physics-through-gameruntimesettings","title":"2. Bootstrap Physics Through <code>GameRuntimeSettings</code>","text":"<p>If you use <code>GameRuntime</code> (recommended for apps/examples), physics is configured in <code>GameRuntimeSettings::Physics</code>.</p> <pre><code>#include \"GameFramework.hpp\"\n\nusing namespace SnAPI::GameFramework;\n\nGameRuntime Runtime;\nGameRuntimeSettings Settings{};\nSettings.WorldName = \"PhysicsSandbox\";\nSettings.RegisterBuiltins = true;\n\nSettings.Tick.EnableFixedTick = true;\nSettings.Tick.FixedDeltaSeconds = 1.0f / 60.0f;\nSettings.Tick.MaxFixedStepsPerUpdate = 4;\n\nGameRuntimePhysicsSettings Physics{};\nPhysics.TickInFixedTick = true;\nPhysics.TickInVariableTick = false;\n\nPhysics.Scene.Gravity = SnAPI::Physics::Vec3{0.0f, -9.81f, 0.0f};\nPhysics.Scene.MaxBodies = 20000;\nPhysics.Scene.CollisionSteps = 1;\n\n// Current default backend is Jolt for all domains.\nPhysics.Routing.RigidBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\nPhysics.Routing.QueryBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\nPhysics.Routing.CharacterBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\n\nSettings.Physics = Physics;\n\nauto InitResult = Runtime.Init(Settings);\nif (!InitResult)\n{\n    // handle init error\n}\n</code></pre> <p>Key points:</p> <ul> <li>if <code>Settings.Physics</code> is <code>std::nullopt</code>, no world physics scene is created.</li> <li>if enabled, <code>GameRuntime::Init(...)</code> initializes world physics before networking.</li> <li><code>GameRuntime::Shutdown()</code> shuts physics down cleanly.</li> </ul>"},{"location":"tutorials/physics/#3-tick-policy-fixed-variable-or-manual","title":"3. Tick Policy: Fixed, Variable, or Manual","text":"<p><code>PhysicsBootstrapSettings</code> gives two tick switches:</p> <ul> <li><code>TickInFixedTick</code></li> <li><code>TickInVariableTick</code></li> </ul> <p>Recommended defaults:</p> <ul> <li>gameplay simulation: <code>TickInFixedTick = true</code>, <code>TickInVariableTick = false</code></li> <li>quick sandbox/prototyping: variable stepping can be acceptable</li> </ul> <p>Manual mode is also possible:</p> <ol> <li>set both flags to <code>false</code></li> <li>call <code>World::Physics().Step(DeltaSeconds)</code> yourself</li> </ol> <p>That is useful when you need custom simulation phases.</p>"},{"location":"tutorials/physics/#4-first-scene-ground-falling-box","title":"4. First Scene: Ground + Falling Box","text":"<p>This is the minimum complete setup.</p> <pre><code>auto&amp; WorldRef = Runtime.World();\n\n// Ground node\nauto GroundNodeResult = WorldRef.CreateNode&lt;BaseNode&gt;(\"Ground\");\nauto* Ground = GroundNodeResult ? GroundNodeResult-&gt;Borrowed() : nullptr;\nif (!Ground)\n{\n    return;\n}\n\nauto GroundTransform = Ground-&gt;Add&lt;TransformComponent&gt;();\nGroundTransform-&gt;Position = Vec3{0.0f, -1.0f, 0.0f};\n\nauto GroundCollider = Ground-&gt;Add&lt;ColliderComponent&gt;();\nGroundCollider-&gt;EditSettings().Shape = 1; // box\nGroundCollider-&gt;EditSettings().HalfExtent = Vec3{30.0f, 1.0f, 30.0f};\nGroundCollider-&gt;EditSettings().Layer = 1u;\n\nauto GroundBody = Ground-&gt;Add&lt;RigidBodyComponent&gt;();\nGroundBody-&gt;EditSettings().BodyType = 0; // static\nGroundBody-&gt;RecreateBody();\n\n// Falling box node\nauto BoxNodeResult = WorldRef.CreateNode&lt;BaseNode&gt;(\"FallingBox\");\nauto* Box = BoxNodeResult ? BoxNodeResult-&gt;Borrowed() : nullptr;\nif (!Box)\n{\n    return;\n}\n\nauto BoxTransform = Box-&gt;Add&lt;TransformComponent&gt;();\nBoxTransform-&gt;Position = Vec3{0.0f, 6.0f, 0.0f};\n\nauto BoxCollider = Box-&gt;Add&lt;ColliderComponent&gt;();\nBoxCollider-&gt;EditSettings().Shape = 1; // box\nBoxCollider-&gt;EditSettings().HalfExtent = Vec3{0.5f, 0.5f, 0.5f};\n\nauto BoxBody = Box-&gt;Add&lt;RigidBodyComponent&gt;();\nBoxBody-&gt;EditSettings().BodyType = 2; // dynamic\nBoxBody-&gt;RecreateBody();\n</code></pre> <p>Why call <code>RecreateBody()</code>?</p> <ul> <li><code>OnCreate()</code> creates a body immediately with current settings.</li> <li>if you change settings after <code>Add&lt;RigidBodyComponent&gt;()</code>, call <code>RecreateBody()</code> to apply them now.</li> </ul>"},{"location":"tutorials/physics/#5-collidercomponentsettings-explained","title":"5. <code>ColliderComponent::Settings</code> Explained","text":"<p><code>ColliderComponent</code> is pure data that <code>RigidBodyComponent</code> consumes.</p> <p>Core fields:</p> <ul> <li><code>Shape</code>: <code>0=sphere</code>, <code>1=box</code>, <code>2=capsule</code></li> <li><code>HalfExtent</code>, <code>Radius</code>, <code>HalfHeight</code>: shape dimensions</li> <li><code>LocalPosition</code>, <code>LocalRotation</code>: collider offset relative to node transform</li> <li><code>Density</code>, <code>Friction</code>, <code>Restitution</code>: contact/material behavior</li> <li><code>Layer</code>, <code>Mask</code>: broad filtering</li> <li><code>IsTrigger</code>: overlap-only sensor behavior</li> </ul> <p>Practical defaults:</p> <ul> <li>start with box colliders while gameplay logic is still changing</li> <li>keep layers/masks simple early, then tighten filtering later</li> <li>only enable trigger mode where needed (interaction volumes, checkpoints, etc.)</li> </ul>"},{"location":"tutorials/physics/#6-rigidbodycomponent-semantics","title":"6. <code>RigidBodyComponent</code> Semantics","text":"<p><code>RigidBodyComponent</code> maps node state to backend body state.</p> <p>Body type mapping:</p> <ul> <li><code>BodyType = 0</code>: static</li> <li><code>BodyType = 1</code>: kinematic</li> <li><code>BodyType = 2</code>: dynamic</li> </ul> <p>Sync behavior in fixed tick:</p> <ul> <li>dynamic (<code>2</code>): component pulls transform from physics (<code>SyncFromPhysics</code>)</li> <li>static/kinematic (<code>0/1</code>): component pushes node transform into physics (<code>SyncToPhysics</code>)</li> </ul> <p>Important implications:</p> <ul> <li>for dynamic actors, gameplay should usually read/write transform through physics-aware paths</li> <li>for kinematic actors, gameplay can author transform and let the component push it</li> </ul>"},{"location":"tutorials/physics/#7-motion-apis-force-vs-impulse-vs-velocity","title":"7. Motion APIs: Force vs Impulse vs Velocity","text":"<p><code>RigidBodyComponent</code> gives three common control paths:</p> <pre><code>// Continuous force (accumulates through simulation integration)\nBody-&gt;ApplyForce(Vec3{0.0f, 0.0f, 10.0f}, false);\n\n// Instant impulse\nBody-&gt;ApplyForce(Vec3{0.0f, 4.5f, 0.0f}, true);\n\n// Explicit mode\nBody-&gt;ApplyForce(Vec3{1.0f, 0.0f, 0.0f}, SnAPI::Physics::EForceMode::VelocityChange);\n\n// Direct velocity set\nBody-&gt;SetVelocity(Vec3{3.0f, 0.0f, 0.0f});\n</code></pre> <p>When to use what:</p> <ul> <li>force:<ul> <li>physically-plausible acceleration over time</li> <li>good for thrusters, wind-like effects</li> </ul> </li> <li>impulse:<ul> <li>one-shot kicks (jump, explosion, hit reactions)</li> </ul> </li> <li>velocity set:<ul> <li>deterministic controller behavior (character steering, authoritative corrections)</li> </ul> </li> </ul>"},{"location":"tutorials/physics/#8-character-movement-controller","title":"8. Character Movement Controller","text":"<p><code>CharacterMovementController</code> is a gameplay convenience component that expects:</p> <ul> <li>sibling <code>RigidBodyComponent</code></li> <li>usually sibling <code>ColliderComponent</code></li> <li>usually sibling <code>TransformComponent</code></li> </ul> <p>Setup:</p> <pre><code>auto Player = WorldRef.CreateNode&lt;BaseNode&gt;(\"Player\");\nauto* PlayerNode = Player ? Player-&gt;Borrowed() : nullptr;\nif (!PlayerNode)\n{\n    return;\n}\n\nauto T = PlayerNode-&gt;Add&lt;TransformComponent&gt;();\nT-&gt;Position = Vec3{0.0f, 1.0f, 0.0f};\n\nauto C = PlayerNode-&gt;Add&lt;ColliderComponent&gt;();\nC-&gt;EditSettings().Shape = 1;\nC-&gt;EditSettings().HalfExtent = Vec3{0.4f, 0.9f, 0.4f};\nC-&gt;EditSettings().Layer = 2u;\n\nauto B = PlayerNode-&gt;Add&lt;RigidBodyComponent&gt;();\nB-&gt;EditSettings().BodyType = 2;\nB-&gt;EditSettings().Mass = 70.0f;\nB-&gt;RecreateBody();\n\nauto M = PlayerNode-&gt;Add&lt;CharacterMovementController&gt;();\nM-&gt;EditSettings().MoveForce = 60.0f;\nM-&gt;SetMoveInput(Vec3{1.0f, 0.0f, 0.0f});\n</code></pre> <p>Runtime control:</p> <pre><code>M-&gt;SetMoveInput(Vec3{InputX, 0.0f, InputZ});\nif (WantsJump)\n{\n    M-&gt;Jump();\n}\n</code></pre> <p>Controller behavior:</p> <ul> <li>applies horizontal movement through rigid body velocity control</li> <li>estimates vertical velocity from transform deltas so steering does not kill falling/rising behavior</li> <li>performs a downward ray probe (<code>GroundProbeDistance</code>) to evaluate grounded state</li> </ul>"},{"location":"tutorials/physics/#9-replication-notes-for-physics-components","title":"9. Replication Notes for Physics Components","text":"<p>Physics components are reflected, so they can participate in replication. But keep this detail in mind:</p> <ul> <li><code>ColliderComponent</code> and <code>RigidBodyComponent</code> expose <code>Settings</code> as replication-visible fields.</li> <li>nested setting members are currently not individually marked with <code>EFieldFlagBits::Replication</code>.</li> </ul> <p>That means:</p> <ul> <li>if no <code>TValueCodec&lt;Settings&gt;</code> is provided, nested-field replication depends on nested flags.</li> <li>if you want full-struct replication, add a <code>TValueCodec&lt;YourSettingsType&gt;</code> or flag nested members explicitly.</li> </ul> <p>Also remember global replication gates still apply:</p> <ul> <li><code>Node-&gt;Replicated(true)</code></li> <li><code>Component-&gt;Replicated(true)</code></li> </ul>"},{"location":"tutorials/physics/#10-common-setup-mistakes","title":"10. Common Setup Mistakes","text":"<ul> <li>Physics scene never starts:<ul> <li>forgot to set <code>Settings.Physics</code> before <code>Runtime.Init(...)</code></li> </ul> </li> <li>Bodies do not use updated settings:<ul> <li>edited settings after add, but forgot <code>RecreateBody()</code></li> </ul> </li> <li>Object never falls:<ul> <li>body type is static/kinematic instead of dynamic</li> <li>no physics stepping configured</li> </ul> </li> <li>Character cannot jump:<ul> <li>grounded probe mask/layer excludes valid ground</li> <li>no collider/rigid body present on player</li> </ul> </li> <li>Transform flicker:<ul> <li>two systems fighting transform writes</li> <li>clarify whether object is physics-driven or script-driven</li> </ul> </li> </ul>"},{"location":"tutorials/physics/#11-what-to-read-next","title":"11. What to Read Next","text":"<ul> <li>Physics Queries and Events</li> <li>Reflection and Serialization</li> </ul>"},{"location":"tutorials/physics_queries_events/","title":"Physics Queries and Events","text":"<p>This page covers the direct-physics API path for advanced gameplay:</p> <ol> <li>raycasts, sweeps, overlaps</li> <li>contact/trigger event draining</li> <li>backend routing and domain couplings</li> <li>performance and threading patterns</li> </ol> <p>Use this page after Physics System and Components.</p>"},{"location":"tutorials/physics_queries_events/#1-accessing-the-scene-safely","title":"1. Accessing the Scene Safely","text":"<p><code>World::Physics()</code> gives access to the adapter and scene pointer:</p> <pre><code>auto* Scene = WorldRef.Physics().Scene();\nif (!Scene)\n{\n    return; // physics not initialized\n}\n</code></pre> <p>From there, use domain interfaces:</p> <ul> <li><code>Scene-&gt;Rigid()</code></li> <li><code>Scene-&gt;Query()</code></li> <li><code>Scene-&gt;Character()</code></li> <li><code>Scene-&gt;Vehicle()</code></li> <li><code>Scene-&gt;SoftBody()</code></li> <li><code>Scene-&gt;Cloth()</code></li> </ul> <p>Most gameplay code in GameFramework currently interacts with:</p> <ul> <li><code>Rigid()</code> through <code>RigidBodyComponent</code></li> <li><code>Query()</code> directly or through helpers like <code>CharacterMovementController</code></li> </ul>"},{"location":"tutorials/physics_queries_events/#2-raycast-example","title":"2. Raycast Example","text":"<pre><code>#include &lt;array&gt;\n\nstd::array&lt;SnAPI::Physics::RaycastHit, 1&gt; Hits{};\n\nSnAPI::Physics::RaycastRequest Request{};\nRequest.Origin = SnAPI::Physics::Vec3{0.0f, 3.0f, 0.0f};\nRequest.Direction = SnAPI::Physics::Vec3{0.0f, -1.0f, 0.0f};\nRequest.Distance = 50.0f;\nRequest.Mask = 0xFFFFFFFFu;\nRequest.Mode = SnAPI::Physics::EQueryMode::ClosestHit;\n\nconst std::uint32_t Count = Scene-&gt;Query().Raycast(Request, std::span&lt;SnAPI::Physics::RaycastHit&gt;(Hits.data(), Hits.size()));\nif (Count &gt; 0)\n{\n    const auto&amp; Hit = Hits[0];\n    // Hit.Body, Hit.Position, Hit.Normal, Hit.Distance\n}\n</code></pre> <p>Practical notes:</p> <ul> <li>keep <code>Direction</code> normalized to avoid ambiguous distance interpretation</li> <li>use narrow masks to reduce query work in large scenes</li> <li><code>ClosestHit</code> is cheaper and usually what gameplay needs</li> </ul>"},{"location":"tutorials/physics_queries_events/#3-sweep-and-overlap-patterns","title":"3. Sweep and Overlap Patterns","text":"<p>Sweep checks motion of a shape along a direction. Overlap checks which shapes currently intersect a pose.</p> <pre><code>SnAPI::Physics::SweepRequest Sweep{};\nSweep.Shape.Type = SnAPI::Physics::EShapeType::Capsule;\nSweep.Shape.Capsule.Radius = 0.4f;\nSweep.Shape.Capsule.HalfHeight = 0.9f;\nSweep.Start.Position = SnAPI::Physics::Vec3{0.0f, 1.0f, 0.0f};\nSweep.Direction = SnAPI::Physics::Vec3{1.0f, 0.0f, 0.0f};\nSweep.Distance = 2.0f;\nSweep.Mode = SnAPI::Physics::EQueryMode::ClosestHit;\n\nSnAPI::Physics::SweepHit SweepHit{};\nconst std::uint32_t SweepCount = Scene-&gt;Query().Sweep(Sweep, std::span&lt;SnAPI::Physics::SweepHit&gt;(&amp;SweepHit, 1));\n</code></pre> <pre><code>SnAPI::Physics::OverlapRequest Overlap{};\nOverlap.Shape.Type = SnAPI::Physics::EShapeType::Sphere;\nOverlap.Shape.Sphere.Radius = 3.0f;\nOverlap.Pose.Position = SnAPI::Physics::Vec3{0.0f, 0.0f, 0.0f};\nOverlap.Mask = 0xFFFFFFFFu;\n\nstd::array&lt;SnAPI::Physics::OverlapHit, 64&gt; Overlaps{};\nconst std::uint32_t OverlapCount = Scene-&gt;Query().Overlap(\n    Overlap,\n    std::span&lt;SnAPI::Physics::OverlapHit&gt;(Overlaps.data(), Overlaps.size()));\n</code></pre> <p>When to use each:</p> <ul> <li>raycast:<ul> <li>line-of-sight checks</li> <li>ground probes</li> <li>interaction traces</li> </ul> </li> <li>sweep:<ul> <li>predictive collision checks for moving volumes</li> <li>custom controller motion validation</li> </ul> </li> <li>overlap:<ul> <li>area triggers</li> <li>nearby object scans</li> </ul> </li> </ul>"},{"location":"tutorials/physics_queries_events/#4-draining-collision-and-trigger-events","title":"4. Draining Collision and Trigger Events","text":"<p><code>PhysicsSystem</code> exposes an event queue drain API.</p> <pre><code>#include &lt;array&gt;\n\nstd::array&lt;SnAPI::Physics::PhysicsEvent, 256&gt; Events{};\nconst std::uint32_t EventCount = WorldRef.Physics().DrainEvents(\n    std::span&lt;SnAPI::Physics::PhysicsEvent&gt;(Events.data(), Events.size()));\n\nfor (std::uint32_t i = 0; i &lt; EventCount; ++i)\n{\n    const auto&amp; E = Events[i];\n    switch (E.Type)\n    {\n    case SnAPI::Physics::EPhysicsEventType::ContactBegin:\n    case SnAPI::Physics::EPhysicsEventType::ContactPersist:\n    case SnAPI::Physics::EPhysicsEventType::ContactEnd:\n        // E.BodyA / E.BodyB / E.Contact\n        break;\n    case SnAPI::Physics::EPhysicsEventType::TriggerBegin:\n    case SnAPI::Physics::EPhysicsEventType::TriggerEnd:\n        // trigger pair started/stopped overlapping\n        break;\n    }\n}\n</code></pre> <p>Recommended pattern:</p> <ul> <li>drain once per frame after stepping (or after <code>Runtime.Update(...)</code>)</li> <li>translate body handles to gameplay object handles if needed</li> <li>process with idempotent logic, especially for <code>ContactPersist</code></li> </ul>"},{"location":"tutorials/physics_queries_events/#5-backend-routing-and-couplings","title":"5. Backend Routing and Couplings","text":"<p><code>PhysicsBootstrapSettings</code> includes:</p> <ul> <li><code>Routing</code>: choose backend per domain (<code>Rigid</code>, <code>Query</code>, <code>Character</code>, etc.)</li> <li><code>Couplings</code>: describe cross-domain interactions</li> </ul> <p>Even if all domains currently use Jolt, keep explicit routing in your settings for clarity and future migration.</p> <pre><code>GameRuntimePhysicsSettings Physics{};\nPhysics.Routing.RigidBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\nPhysics.Routing.QueryBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\nPhysics.Routing.CharacterBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\nPhysics.Routing.VehicleBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\nPhysics.Routing.SoftBodyBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\nPhysics.Routing.ClothBackend = SnAPI::Physics::EPhysicsBackend::Jolt;\n\nSnAPI::Physics::CouplingDesc ClothToRigid{};\nClothToRigid.A = SnAPI::Physics::EPhysicsDomain::Cloth;\nClothToRigid.B = SnAPI::Physics::EPhysicsDomain::Rigid;\nClothToRigid.Mode = SnAPI::Physics::ECouplingMode::OneWay;\nClothToRigid.MaxPairsPerStep = 8192;\n\nPhysics.Couplings.push_back(ClothToRigid);\n</code></pre> <p>Design guidance:</p> <ul> <li>keep couplings explicit and bounded</li> <li>start with minimal coupling set, then expand by measured need</li> <li>avoid hidden coupling assumptions in gameplay systems</li> </ul>"},{"location":"tutorials/physics_queries_events/#6-manual-step-mode-for-custom-pipelines","title":"6. Manual Step Mode for Custom Pipelines","text":"<p>If you need strict control over simulation phase order:</p> <ol> <li>configure <code>TickInFixedTick = false</code> and <code>TickInVariableTick = false</code></li> <li>call <code>WorldRef.Physics().Step(FixedDeltaSeconds)</code> manually</li> <li>run event drain and gameplay reactions in your own sequence</li> </ol> <p>Example:</p> <pre><code>const float FixedDt = 1.0f / 60.0f;\n\nWorldRef.Tick(FrameDt);          // gameplay tick, no physics step here\nWorldRef.Physics().Step(FixedDt);\nWorldRef.LateTick(FrameDt);\nWorldRef.EndFrame();\n</code></pre> <p>This pattern is useful when integrating deterministic simulation pipelines.</p>"},{"location":"tutorials/physics_queries_events/#7-threading-and-performance-guidance","title":"7. Threading and Performance Guidance","text":"<p>Current behavior:</p> <ul> <li><code>PhysicsSystem</code> guards lifecycle/state transitions with a mutex.</li> <li>scene/domain objects are backend implementations (Jolt-backed currently).</li> </ul> <p>Practical guidance for gameplay code:</p> <ul> <li>treat the world thread as the authoritative gameplay mutation thread</li> <li>avoid long-lived cached raw scene pointers across ownership/lifecycle transitions</li> <li>batch query/event processing where possible instead of many tiny scattered calls</li> </ul> <p>Performance tips:</p> <ul> <li>keep query masks narrow</li> <li>prefer <code>ClosestHit</code> unless you truly need all hits</li> <li>avoid frequent body destroy/recreate churn in frame loops</li> <li>use <code>SetVelocity</code> for deterministic controller steering, not repeated recreate/setup</li> </ul>"},{"location":"tutorials/physics_queries_events/#8-common-pitfalls","title":"8. Common Pitfalls","text":"<ul> <li>Draining no events:<ul> <li>scene not initialized</li> <li>no contacts/triggers generated for current setup</li> </ul> </li> <li>Raycasts always miss:<ul> <li>wrong mask/layer assumptions</li> <li>direction/distance values not what you expect</li> </ul> </li> <li>Unexpected jitter:<ul> <li>gameplay transform writes fighting physics sync path</li> <li>mixed stepping configuration or inconsistent fixed delta</li> </ul> </li> <li>Domain API call returns errors:<ul> <li>invalid handles (destroyed or never created)</li> <li>backend/domain not available in current routing</li> </ul> </li> </ul>"},{"location":"tutorials/physics_queries_events/#9-validation-checklist","title":"9. Validation Checklist","text":"<p>Before merging physics-heavy changes:</p> <ol> <li>run <code>PhysicsIntegrationTests</code></li> <li>run full <code>GameFrameworkTests</code></li> <li>sanity-check your runtime tick policy</li> <li>confirm query/event paths under expected load</li> </ol> <p>You can start with:</p> <pre><code>ctest --test-dir build/debug --output-on-failure -R \"Physics|CharacterMovementController\"\n</code></pre> <p>Next: Reflection and Serialization</p>"},{"location":"tutorials/reflection_serialization/","title":"Reflection and Serialization","text":"<p>This page explains the type system that powers serialization, replication, and reflection-based RPC.</p>"},{"location":"tutorials/reflection_serialization/#1-startup-register-builtins","title":"1. Startup: Register Builtins","text":"<p>Call this once during startup:</p> <pre><code>RegisterBuiltinTypes();\n</code></pre> <p>It registers built-in value types and default serialization codecs.</p>"},{"location":"tutorials/reflection_serialization/#2-register-on-first-use-model","title":"2. Register-on-First-Use Model","text":"<p>SnAPI.GameFramework uses lazy reflection registration:</p> <ul> <li><code>SNAPI_REFLECT_TYPE(...)</code> stores an ensure callback in <code>TypeAutoRegistry</code>.</li> <li><code>TypeRegistry::Find(...)</code> can trigger that callback on first miss.</li> <li>The heavy registration runs once (<code>std::call_once</code>).</li> </ul> <p>Why this model helps:</p> <ul> <li>No giant central type list.</li> <li>No cross-translation-unit init ordering dependency for full metadata.</li> <li>Pay-for-what-you-use behavior.</li> </ul>"},{"location":"tutorials/reflection_serialization/#linkerstripping-note","title":"Linker/stripping note","text":"<p><code>SNAPI_REFLECT_TYPE</code> installs static registration glue in its translation unit. To guarantee that translation unit is linked in static library/plugin builds, ensure something in that unit is referenced by the final binary (or explicitly force-link the object/library according to your build system).</p>"},{"location":"tutorials/reflection_serialization/#3-defining-reflected-types","title":"3. Defining Reflected Types","text":"<pre><code>class EnemyNode final : public BaseNode\n{\npublic:\n    static constexpr const char* kTypeName = \"MyGame::EnemyNode\";\n\n    int Health = 100;\n\n    void ServerSetHealth(int InValue)\n    {\n        Health = InValue;\n    }\n};\n\nclass InventoryComponent final : public IComponent\n{\npublic:\n    static constexpr const char* kTypeName = \"MyGame::InventoryComponent\";\n\n    int Gold = 0;\n};\n\nSNAPI_REFLECT_TYPE(EnemyNode, (TTypeBuilder&lt;EnemyNode&gt;(EnemyNode::kTypeName)\n    .Base&lt;BaseNode&gt;()\n    .Field(\"Health\", &amp;EnemyNode::Health, EFieldFlagBits::Replication)\n    .Method(\"ServerSetHealth\",\n            &amp;EnemyNode::ServerSetHealth,\n            EMethodFlagBits::RpcReliable | EMethodFlagBits::RpcNetServer)\n    .Constructor&lt;&gt;()\n    .Register()));\n\nSNAPI_REFLECT_COMPONENT(InventoryComponent, (TTypeBuilder&lt;InventoryComponent&gt;(InventoryComponent::kTypeName)\n    .Field(\"Gold\", &amp;InventoryComponent::Gold, EFieldFlagBits::Replication)\n    .Constructor&lt;&gt;()\n    .Register()));\n</code></pre> <p>Important points:</p> <ul> <li>Always register base classes with <code>.Base&lt;...&gt;()</code> to preserve inheritance queries.</li> <li>Register a default constructor if the type must be created from type metadata (serialization/network spawn paths).</li> </ul>"},{"location":"tutorials/reflection_serialization/#4-statictypeidt-and-statictypet","title":"4. <code>StaticTypeId&lt;T&gt;()</code> and <code>StaticType&lt;T&gt;()</code>","text":"<p>Use cached type identity in hot paths:</p> <pre><code>const TypeId&amp; CachedId = StaticTypeId&lt;EnemyNode&gt;();\nauto EnsureResult = StaticType&lt;EnemyNode&gt;(); // returns TExpected&lt;TypeId*&gt;\n</code></pre> <ul> <li><code>StaticTypeId&lt;T&gt;()</code> is deterministic and cached via function-local static.</li> <li><code>StaticType&lt;T&gt;()</code> ensures reflection registration exists before use.</li> </ul> <p>Hot path guidance:</p> <ul> <li>prefer <code>StaticTypeId&lt;T&gt;()</code> over repeated <code>TypeIdFromName(...)</code>.</li> <li>use <code>StaticType&lt;T&gt;()</code> when you need to force ensure-on-first-use behavior.</li> </ul>"},{"location":"tutorials/reflection_serialization/#5-value-serialization-tvaluecodect","title":"5. Value Serialization (<code>TValueCodec&lt;T&gt;</code>)","text":"<p>Most primitive/trivial types already work. For custom packed formats, specialize <code>TValueCodec&lt;T&gt;</code>.</p> <pre><code>struct PackedVec2\n{\n    static constexpr const char* kTypeName = \"MyGame::PackedVec2\";\n    int32_t X = 0;\n    int32_t Y = 0;\n};\n\ntemplate&lt;&gt;\nstruct TValueCodec&lt;PackedVec2&gt;\n{\n    static TExpected&lt;void&gt; Encode(const PackedVec2&amp; Value,\n                                  cereal::BinaryOutputArchive&amp; Archive,\n                                  const TSerializationContext&amp;)\n    {\n        int32_t Packed = (Value.X &lt;&lt; 16) | (Value.Y &amp; 0xFFFF);\n        Archive(Packed);\n        return Ok();\n    }\n\n    static TExpected&lt;PackedVec2&gt; Decode(cereal::BinaryInputArchive&amp; Archive,\n                                        const TSerializationContext&amp;)\n    {\n        int32_t Packed = 0;\n        Archive(Packed);\n        return PackedVec2{(Packed &gt;&gt; 16), (Packed &amp; 0xFFFF)};\n    }\n\n    static TExpected&lt;void&gt; DecodeInto(PackedVec2&amp; Value,\n                                      cereal::BinaryInputArchive&amp; Archive,\n                                      const TSerializationContext&amp;)\n    {\n        int32_t Packed = 0;\n        Archive(Packed);\n        Value.X = (Packed &gt;&gt; 16);\n        Value.Y = (Packed &amp; 0xFFFF);\n        return Ok();\n    }\n};\n</code></pre>"},{"location":"tutorials/reflection_serialization/#6-replication-nested-types-value-codecs","title":"6. Replication + Nested Types + Value Codecs","text":"<p>For a reflected field marked with <code>EFieldFlagBits::Replication</code>:</p> <ul> <li>if a <code>TValueCodec&lt;FieldType&gt;</code> is registered, replication uses that codec for the field value.</li> <li>if no codec is registered, replication recursively visits nested reflected fields and serializes only nested fields that also have replication flags.</li> </ul> <p>That means field flags are still important for nested structs. Example: if <code>Settings</code> is replicated but only <code>Settings.SoundPath</code> is flagged, only <code>SoundPath</code> replicates unless you provide a codec that serializes the whole <code>Settings</code> value.</p>"},{"location":"tutorials/reflection_serialization/#7-graphlevelworld-serialization","title":"7. Graph/Level/World Serialization","text":""},{"location":"tutorials/reflection_serialization/#graph-to-payload-bytes","title":"Graph to payload bytes","text":"<pre><code>NodeGraph Graph(\"Gameplay\");\nauto PayloadResult = NodeGraphSerializer::Serialize(Graph);\nif (!PayloadResult)\n{\n    return;\n}\n\nstd::vector&lt;uint8_t&gt; Bytes;\nauto BytesResult = SerializeNodeGraphPayload(PayloadResult.value(), Bytes);\nif (!BytesResult)\n{\n    return;\n}\n</code></pre>"},{"location":"tutorials/reflection_serialization/#payload-bytes-back-to-graph","title":"Payload bytes back to graph","text":"<pre><code>auto PayloadRoundTrip = DeserializeNodeGraphPayload(Bytes.data(), Bytes.size());\nif (!PayloadRoundTrip)\n{\n    return;\n}\n\nNodeGraph Loaded;\nauto LoadResult = NodeGraphSerializer::Deserialize(PayloadRoundTrip.value(), Loaded);\nif (!LoadResult)\n{\n    return;\n}\n</code></pre> <p>The same pattern exists for <code>LevelSerializer</code> + <code>WorldSerializer</code> and their payload byte helpers.</p>"},{"location":"tutorials/reflection_serialization/#8-component-serialization-registration","title":"8. Component Serialization Registration","text":"<p>Why components are special:</p> <ul> <li>Components are created dynamically by type id during graph/world deserialization.</li> <li><code>ComponentSerializationRegistry</code> provides the creation + field-serialization callbacks.</li> </ul> <p>You normally do not need to register this manually for normal reflected components. <code>TTypeBuilder&lt;ComponentT&gt;::Register()</code> does it automatically when <code>ComponentT</code> derives from <code>IComponent</code>.</p> <p>Next: AssetPipeline Integration</p>"},{"location":"tutorials/renderer/","title":"Renderer Integration and Mesh Components","text":"<p>This guide explains how SnAPI.GameFramework integrates with SnAPI.Renderer in the current post-refactor architecture.</p> <p>By the end, you should understand:</p> <ol> <li>when renderer integration is compiled in</li> <li>how to bootstrap renderer through <code>GameRuntimeSettings</code></li> <li>how <code>World</code> frame lifecycle drives renderer submit/present</li> <li>how camera/static/skeletal components work together</li> <li>why mesh assets are now separated from per-instance render state (<code>MeshRenderObject</code>)</li> </ol>"},{"location":"tutorials/renderer/#1-build-time-integration-rules","title":"1. Build-Time Integration Rules","text":"<p>Renderer support is compile-time gated by <code>SNAPI_GF_ENABLE_RENDERER</code>.</p> <p>In this repository, that define is added when CMake can locate a SnAPI.Renderer source tree and create <code>SnAPI.Renderer</code> target.</p> <p>CMake resolution order:</p> <ol> <li><code>-DSNAPI_GF_RENDERER_SOURCE_DIR=/path/to/SnAPI.Renderer</code></li> <li>fallback local path <code>/mnt/Apps/Dev/Repositories/SnAPI.Renderer</code></li> <li>if neither is present, renderer integration is skipped and related components are not compiled</li> </ol> <p>Typical dev configure command:</p> <pre><code>cmake -S . -B build/debug \\\n  -DSNAPI_GF_BUILD_EXAMPLES=ON \\\n  -DSNAPI_GF_BUILD_TESTS=ON \\\n  -DSNAPI_GF_RENDERER_SOURCE_DIR=/mnt/Apps/Dev/Repositories/SnAPI.Renderer\n</code></pre>"},{"location":"tutorials/renderer/#2-bootstrap-renderer-from-gameruntimesettings","title":"2. Bootstrap Renderer from <code>GameRuntimeSettings</code>","text":"<p><code>GameRuntime</code> is the simplest way to start renderer-backed worlds.</p> <pre><code>#include \"GameFramework.hpp\"\n\nusing namespace SnAPI::GameFramework;\n\nGameRuntime Runtime;\nGameRuntimeSettings Settings{};\nSettings.WorldName = \"RendererWorld\";\nSettings.RegisterBuiltins = true;\n\nSettings.Tick.EnableFixedTick = true;\nSettings.Tick.FixedDeltaSeconds = 1.0f / 60.0f;\n\nGameRuntimeRendererSettings Renderer{};\nRenderer.WindowTitle = \"SnAPI.GameFramework Renderer\";\nRenderer.WindowWidth = 1600.0f;\nRenderer.WindowHeight = 900.0f;\nRenderer.CreateWindow = true;\nRenderer.CreateDefaultLighting = true;\nRenderer.RegisterDefaultPassGraph = true;\nRenderer.CreateDefaultMaterials = true;\nRenderer.EnableSsao = true;\nRenderer.EnableSsr = true;\nRenderer.EnableBloom = true;\nRenderer.EnableAtmosphere = true;\n\nSettings.Renderer = Renderer;\n\nconst auto InitResult = Runtime.Init(Settings);\nif (!InitResult)\n{\n    // handle init error\n}\n</code></pre> <p>Important behavior:</p> <ul> <li>if <code>Settings.Renderer</code> is <code>std::nullopt</code>, the world runs without renderer backend</li> <li>if set, <code>GameRuntime::Init(...)</code> initializes world renderer subsystem</li> <li><code>GameRuntime::Shutdown()</code> cleanly shuts renderer down</li> </ul>"},{"location":"tutorials/renderer/#3-runtime-lifecycle-who-calls-present","title":"3. Runtime Lifecycle: Who Calls Present?","text":"<p><code>World::EndFrame()</code> triggers renderer work when renderer is enabled:</p> <ul> <li><code>NodeGraph::EndFrame()</code> runs first</li> <li>then <code>RendererSystem::EndFrame()</code> runs</li> </ul> <p><code>RendererSystem::EndFrame()</code> is responsible for:</p> <ul> <li>optional swapchain resize handling</li> <li><code>BeginFrame(...)</code> / pass execution / <code>EndFrame(...)</code> on graphics API</li> <li>camera previous-frame save (<code>SaveFrameState()</code>)</li> <li>render-object previous-frame save (<code>SaveFrameState()</code>)</li> </ul> <p>This is why temporal effects and motion vectors stay frame-consistent without manual per-object bookkeeping in gameplay code.</p>"},{"location":"tutorials/renderer/#4-camera-setup-with-cameracomponent","title":"4. Camera Setup with <code>CameraComponent</code>","text":"<p><code>CameraComponent</code> owns a renderer <code>CameraBase</code> and can auto-sync from <code>TransformComponent</code>.</p> <pre><code>auto CameraNodeResult = Runtime.World().CreateNode&lt;BaseNode&gt;(\"MainCamera\");\nauto* CameraNode = CameraNodeResult ? CameraNodeResult-&gt;Borrowed() : nullptr;\nif (!CameraNode)\n{\n    return;\n}\n\nauto CameraTransform = CameraNode-&gt;Add&lt;TransformComponent&gt;();\nCameraTransform-&gt;Position = Vec3{0.0f, 2.0f, 8.0f};\n\nauto Camera = CameraNode-&gt;Add&lt;CameraComponent&gt;();\nCamera-&gt;EditSettings().FovDegrees = 60.0f;\nCamera-&gt;EditSettings().NearClip = 0.05f;\nCamera-&gt;EditSettings().FarClip = 5000.0f;\nCamera-&gt;EditSettings().Aspect = 16.0f / 9.0f;\nCamera-&gt;EditSettings().SyncFromTransform = true;\nCamera-&gt;SetActive(true);\n</code></pre> <p><code>CameraComponent</code> resolves world renderer through <code>Owner()-&gt;World()-&gt;Renderer()</code> and updates active camera ownership automatically.</p>"},{"location":"tutorials/renderer/#5-static-mesh-rendering-staticmeshcomponent","title":"5. Static Mesh Rendering (<code>StaticMeshComponent</code>)","text":"<pre><code>auto CubeNodeResult = Runtime.World().CreateNode&lt;BaseNode&gt;(\"Cube\");\nauto* CubeNode = CubeNodeResult ? CubeNodeResult-&gt;Borrowed() : nullptr;\nif (!CubeNode)\n{\n    return;\n}\n\nauto CubeTransform = CubeNode-&gt;Add&lt;TransformComponent&gt;();\nCubeTransform-&gt;Position = Vec3{0.0f, 0.5f, 0.0f};\nCubeTransform-&gt;Scale = Vec3{1.0f, 1.0f, 1.0f};\n\nauto CubeMesh = CubeNode-&gt;Add&lt;StaticMeshComponent&gt;();\nauto&amp; MeshSettings = CubeMesh-&gt;EditSettings();\nMeshSettings.MeshPath = \"assets/cube.obj\";\nMeshSettings.Visible = true;\nMeshSettings.CastShadows = true;\nMeshSettings.SyncFromTransform = true;\nMeshSettings.RegisterWithRenderer = true;\n\n// Optional if you edited path at runtime and want immediate reload:\nCubeMesh-&gt;ReloadMesh();\n</code></pre> <p>What happens internally:</p> <ul> <li>mesh data is loaded once through <code>MeshManager</code> cache</li> <li>component creates one per-instance <code>MeshRenderObject</code></li> <li>default GBuffer/Shadow material instances are populated through <code>RendererSystem</code></li> <li>pass visibility (<code>Visible</code>) and shadow participation (<code>CastShadows</code>) are applied per render object</li> <li>registration is done through <code>RendererSystem::RegisterRenderObject(...)</code></li> </ul>"},{"location":"tutorials/renderer/#6-skeletalrigid-animation-rendering-skeletalmeshcomponent","title":"6. Skeletal/Rigid Animation Rendering (<code>SkeletalMeshComponent</code>)","text":"<pre><code>auto ActorNodeResult = Runtime.World().CreateNode&lt;BaseNode&gt;(\"AnimatedActor\");\nauto* ActorNode = ActorNodeResult ? ActorNodeResult-&gt;Borrowed() : nullptr;\nif (!ActorNode)\n{\n    return;\n}\n\nauto ActorTransform = ActorNode-&gt;Add&lt;TransformComponent&gt;();\nActorTransform-&gt;Position = Vec3{2.0f, 0.0f, 0.0f};\n\nauto Skeletal = ActorNode-&gt;Add&lt;SkeletalMeshComponent&gt;();\nauto&amp; SkeletalSettings = Skeletal-&gt;EditSettings();\nSkeletalSettings.MeshPath = \"assets/robot.glb\";\nSkeletalSettings.Visible = true;\nSkeletalSettings.CastShadows = true;\nSkeletalSettings.AutoPlayAnimations = true;\nSkeletalSettings.LoopAnimations = true;\nSkeletalSettings.AnimationName = \"Idle\"; // empty string = play all\n\n// Runtime control:\nSkeletal-&gt;PlayAnimation(\"Run\", true, 0.0f);\n// Skeletal-&gt;StopAnimations();\n</code></pre> <p><code>SkeletalMeshComponent</code> advances rigid animation state on its <code>MeshRenderObject</code> each tick, then renderer consumes updated transforms in pass execution.</p>"},{"location":"tutorials/renderer/#7-post-refactor-model-mesh-asset-vs-render-object","title":"7. Post-Refactor Model: Mesh Asset vs Render Object","text":"<p>This is the key architecture update:</p> <ul> <li><code>Mesh</code> is now asset data holder (vertices, indices, submeshes, materials, rigid parts, animation tracks)</li> <li>runtime instance state lives on <code>IRenderObject</code> implementations (currently <code>MeshRenderObject</code>)</li> </ul> <p>Per-instance state now includes:</p> <ul> <li>world transform / previous-frame world transform</li> <li>per-submesh material instances and shadow material instances</li> <li>per-pass visibility flags</li> <li>shadow-cast and triangle-culling toggles</li> <li>animation playback state</li> </ul> <p>Why this matters:</p> <ul> <li>many game objects can share one mesh asset + one vertex stream set</li> <li>you avoid accidental per-instance mesh duplication</li> <li>material/pass toggles become true instance-level controls</li> </ul>"},{"location":"tutorials/renderer/#8-material-sharing-for-high-instance-counts","title":"8. Material Sharing for High Instance Counts","text":"<p>For large crowds/prop fields, <code>StaticMeshComponent</code> supports overriding all submesh materials with shared instances:</p> <pre><code>auto* Renderer = Runtime.World().Renderer().Graphics();\n(void)Renderer; // acquire/create your own material instances as needed\n\n// After you created shared material instances:\nCubeMesh-&gt;SetSharedMaterialInstances(SharedGBufferMaterialInstance,\n                                     SharedShadowMaterialInstance);\n</code></pre> <p>This is useful when you want many objects to intentionally share descriptor state and reduce VRAM churn.</p>"},{"location":"tutorials/renderer/#9-manual-renderer-access-from-gameplay-code","title":"9. Manual Renderer Access from Gameplay Code","text":"<p>You can interact with renderer subsystem directly:</p> <pre><code>auto&amp; RendererSystem = Runtime.World().Renderer();\n\nif (RendererSystem.IsInitialized())\n{\n    RendererSystem.QueueText(\"Hello Renderer\", 20.0f, 20.0f);\n\n    if (!RendererSystem.HasOpenWindow())\n    {\n        // headless or window closed\n    }\n}\n</code></pre> <p>Useful APIs:</p> <ul> <li><code>SetActiveCamera(...)</code></li> <li><code>QueueText(...)</code></li> <li><code>LoadDefaultFont(...)</code></li> <li><code>RecreateSwapChain()</code></li> <li><code>DefaultGBufferMaterial()</code> / <code>DefaultShadowMaterial()</code></li> </ul>"},{"location":"tutorials/renderer/#10-multiplayer-example-rendering-profiling-mode","title":"10. Multiplayer Example Rendering + Profiling Mode","text":"<p><code>examples/MultiplayerExample</code> requires renderer integration and uses renderer-backed scene setup.</p> <p>Profiler mode defaults to raw replay capture in this example. To switch to live stream mode:</p> <pre><code>SNAPI_MULTIPLAYER_PROFILER_MODE=stream ./build/debug/examples/MultiplayerExample/MultiplayerExample --local\n</code></pre>"},{"location":"tutorials/renderer/#11-common-mistakes","title":"11. Common Mistakes","text":"<ul> <li>Renderer features not available at compile-time:</li> <li>forgot to provide <code>SNAPI_GF_RENDERER_SOURCE_DIR</code> and local fallback path is absent</li> <li>Mesh never appears:</li> <li><code>MeshPath</code> invalid</li> <li><code>RegisterWithRenderer=false</code></li> <li>no active camera</li> <li>Object visible but no shadows:</li> <li><code>CastShadows=false</code></li> <li>shadow pass disabled in renderer bootstrap</li> <li>Flickering temporal motion vectors:</li> <li>custom frame loop skips <code>World::EndFrame()</code></li> </ul>"},{"location":"tutorials/renderer/#12-what-to-read-next","title":"12. What to Read Next","text":"<ul> <li>Physics System and Components</li> <li>Networking Replication and RPC</li> <li>Architecture</li> </ul>"},{"location":"tutorials/testing/","title":"Testing and Validation","text":"<p>This page gives a practical test workflow for GameFramework features.</p>"},{"location":"tutorials/testing/#1-build-and-run-unit-tests","title":"1. Build and Run Unit Tests","text":"<pre><code>cmake -S . -B build/debug -DSNAPI_GF_BUILD_TESTS=ON\ncmake --build build/debug\nctest --test-dir build/debug --output-on-failure\n</code></pre> <p>The main test binary is <code>GameFrameworkTests</code> (Catch2).</p>"},{"location":"tutorials/testing/#2-what-is-already-covered","title":"2. What Is Already Covered","text":"<p>Current tests include:</p> <ul> <li><code>tests/HandleTests.cpp</code><ul> <li>handle validity and end-of-frame deletion behavior</li> </ul> </li> <li><code>tests/NodeGraphTests.cpp</code><ul> <li>node + component ticking through graph hierarchy</li> </ul> </li> <li><code>tests/ReflectionTests.cpp</code><ul> <li>type registration, inheritance, field/method flags, audio RPC endpoint metadata, and audio settings replication flags</li> </ul> </li> <li><code>tests/SerializationTests.cpp</code><ul> <li>graph serialization round-trip, cross-graph handle resolution, custom <code>TValueCodec</code></li> </ul> </li> <li><code>tests/LevelWorldSerializationTests.cpp</code><ul> <li>level/world serialization round-trips</li> </ul> </li> <li><code>tests/RelevanceTests.cpp</code><ul> <li>relevance policy gating tick</li> </ul> </li> <li><code>tests/NetReplicationTests.cpp</code><ul> <li>replication spawn/update ordering and session integration</li> </ul> </li> <li><code>tests/WorldNetworkingTests.cpp</code><ul> <li>world-owned networking system wiring, replication/rpc bridge integration</li> <li><code>INode::CallRPC</code> / <code>IComponent::CallRPC</code> role-based routing behavior</li> <li>component <code>TypeKey</code> assignment for reflection RPC dispatch</li> </ul> </li> <li><code>tests/PhysicsIntegrationTests.cpp</code><ul> <li>runtime physics bootstrap through <code>GameRuntimeSettings::Physics</code></li> <li>rigid body simulation updates transform over fixed ticks</li> <li><code>CharacterMovementController</code> movement/jump integration with rigid body</li> </ul> </li> </ul>"},{"location":"tutorials/testing/#3-run-integration-examples","title":"3. Run Integration Examples","text":"<p>Unit tests are necessary but not sufficient for gameplay systems. Also run these binaries:</p> <pre><code>./build/debug/examples/FeatureShowcase/FeatureShowcase\n./build/debug/examples/WorldPerfBenchmark/WorldPerfBenchmark\n./build/debug/examples/MultiplayerExample/MultiplayerExample --server\n./build/debug/examples/MultiplayerExample/MultiplayerExample --client\n</code></pre> <p>This validates end-to-end behavior (asset packs, runtime factories, replication bridges, rendering loop).</p>"},{"location":"tutorials/testing/#4-suggested-test-matrix-for-changes","title":"4. Suggested Test Matrix For Changes","text":"<p>If you change reflection code:</p> <ul> <li>run <code>ReflectionTests</code> and <code>SerializationTests</code></li> <li>verify lazy auto-registration still resolves types on first use</li> </ul> <p>If you change serialization code:</p> <ul> <li>run <code>SerializationTests</code>, <code>LevelWorldSerializationTests</code></li> <li>run <code>FeatureShowcase</code> to confirm real payload load path</li> </ul> <p>If you change networking/replication code:</p> <ul> <li>run <code>NetReplicationTests</code></li> <li>run <code>WorldNetworkingTests</code></li> <li>validate <code>CallRPC(...)</code> routes correctly for server/client/listen-server roles</li> <li>run multiplayer example across two processes/devices</li> <li>watch connection dumps:<ul> <li><code>pending_rel</code> should not grow forever</li> <li>non-zero <code>pkt_lost</code> alone is not a failure if reliable backlog drains and gameplay state remains correct</li> </ul> </li> </ul> <p>If you change physics code:</p> <ul> <li>run <code>PhysicsIntegrationTests</code></li> <li>verify world physics bootstrap still succeeds in runtime init</li> <li>verify stepping policy (<code>TickInFixedTick</code> / <code>TickInVariableTick</code>) matches expected update path</li> <li>verify rigid body transform sync behavior:<ul> <li>dynamic bodies pull from physics</li> <li>static/kinematic bodies push to physics</li> </ul> </li> <li>verify grounded probe and jump behavior if character movement logic changed</li> </ul> <p>Fast physics-only test command:</p> <pre><code>ctest --test-dir build/debug --output-on-failure -R \"Physics|CharacterMovementController\"\n</code></pre> <p>If you change renderer integration code:</p> <ul> <li>build with renderer source configured (<code>SNAPI_GF_RENDERER_SOURCE_DIR=...</code>)</li> <li>run <code>MultiplayerExample --local</code> and verify:<ul> <li>window/bootstrap succeeds</li> <li>camera is active and scene is visible</li> <li>static/skeletal mesh components render with expected pass/shadow behavior</li> </ul> </li> <li>verify no visual regression in frame lifecycle:<ul> <li><code>World::EndFrame()</code> still drives renderer submit/present</li> <li>temporal effects remain stable (no previous-frame state regressions)</li> </ul> </li> </ul> <p>If you change component lifecycle code:</p> <ul> <li>run <code>NodeGraphTests</code> and <code>HandleTests</code></li> <li>verify deferred destruction semantics still hold</li> </ul>"},{"location":"tutorials/testing/#5-add-a-new-test-template","title":"5. Add a New Test (Template)","text":"<pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include \"GameFramework.hpp\"\n\nusing namespace SnAPI::GameFramework;\n\nTEST_CASE(\"My feature round-trips\")\n{\n    RegisterBuiltinTypes();\n\n    NodeGraph Graph;\n    auto NodeResult = Graph.CreateNode(\"Actor\");\n    REQUIRE(NodeResult);\n\n    auto* Node = NodeResult-&gt;Borrowed();\n    REQUIRE(Node != nullptr);\n\n    // setup\n\n    auto Payload = NodeGraphSerializer::Serialize(Graph);\n    REQUIRE(Payload);\n\n    NodeGraph Loaded;\n    REQUIRE(NodeGraphSerializer::Deserialize(Payload.value(), Loaded));\n\n    // assert\n}\n</code></pre>"},{"location":"tutorials/testing/#6-ci-friendly-command-set","title":"6. CI-Friendly Command Set","text":"<pre><code>cmake -S . -B build/ci -DSNAPI_GF_BUILD_TESTS=ON -DSNAPI_GF_BUILD_EXAMPLES=ON\ncmake --build build/ci --config Release\nctest --test-dir build/ci --output-on-failure\n</code></pre> <p>Use this baseline before merging engine-level changes.</p>"},{"location":"tutorials/worlds_graphs/","title":"Worlds and Graphs","text":"<p>This page explains the runtime object model. If this is clear, everything else (physics, serialization, replication, audio) becomes much easier.</p>"},{"location":"tutorials/worlds_graphs/#1-runtime-hierarchy","title":"1. Runtime Hierarchy","text":"<p>SnAPI.GameFramework is centered around node graphs:</p> <ul> <li><code>World</code> is the runtime root.</li> <li><code>Level</code> is a node type that also behaves like a graph.</li> <li><code>NodeGraph</code> is a node that owns other nodes.</li> <li><code>BaseNode</code> is a regular node.</li> <li><code>IComponent</code> attaches behavior/state to a node.</li> </ul> <p>Because <code>Level</code> and <code>NodeGraph</code> are nodes, graphs can be nested.</p>"},{"location":"tutorials/worlds_graphs/#2-handles-vs-borrowed-pointers","title":"2. Handles vs Borrowed Pointers","text":"<p>You will use two access patterns constantly:</p> <ul> <li><code>NodeHandle</code> / <code>ComponentHandle</code>: stable identity (UUID-based)</li> <li><code>Borrowed()</code> pointer: quick lookup for immediate use</li> </ul> <p>Important rule:</p> <ul> <li>Do not cache borrowed pointers long-term. Resolve from the handle when needed.</li> </ul>"},{"location":"tutorials/worlds_graphs/#3-create-a-world-level-graph-and-nodes","title":"3. Create a World, Level, Graph, and Nodes","text":"<pre><code>#include \"GameFramework.hpp\"\n\nusing namespace SnAPI::GameFramework;\n\nvoid BuildScene()\n{\n    RegisterBuiltinTypes();\n\n    World WorldInstance(\"GameWorld\");\n\n    auto LevelHandleResult = WorldInstance.CreateLevel(\"MainLevel\");\n    if (!LevelHandleResult)\n    {\n        return;\n    }\n\n    auto LevelResult = WorldInstance.LevelRef(LevelHandleResult.value());\n    if (!LevelResult)\n    {\n        return;\n    }\n\n    Level&amp; MainLevel = *LevelResult;\n\n    auto GraphHandleResult = MainLevel.CreateGraph(\"Gameplay\");\n    if (!GraphHandleResult)\n    {\n        return;\n    }\n\n    auto GraphResult = MainLevel.Graph(GraphHandleResult.value());\n    if (!GraphResult)\n    {\n        return;\n    }\n\n    NodeGraph&amp; Gameplay = *GraphResult;\n\n    auto PlayerResult = Gameplay.CreateNode(\"Player\");\n    auto CameraResult = Gameplay.CreateNode(\"Camera\");\n    if (!PlayerResult || !CameraResult)\n    {\n        return;\n    }\n\n    // Parent-child relation: Camera becomes child of Player.\n    (void)Gameplay.AttachChild(PlayerResult.value(), CameraResult.value());\n}\n</code></pre>"},{"location":"tutorials/worlds_graphs/#4-frame-lifecycle","title":"4. Frame Lifecycle","text":"<p>Tick order is tree-driven from graph roots. <code>World</code> also runs subsystem work during frame lifecycle:</p> <ul> <li>networking session pumping in <code>Tick</code> + <code>EndFrame</code></li> <li>optional physics stepping in <code>Tick</code> and/or <code>FixedTick</code> (based on physics settings)</li> <li>audio system update in <code>Tick</code></li> <li>renderer submit/present in <code>EndFrame</code> (when renderer integration is enabled)</li> </ul> <p>Typical frame loop:</p> <pre><code>void RunFrame(World&amp; WorldInstance, float DeltaSeconds)\n{\n    WorldInstance.Tick(DeltaSeconds);\n    WorldInstance.FixedTick(DeltaSeconds); // optional if you use fixed-step logic\n    WorldInstance.LateTick(DeltaSeconds);\n    WorldInstance.EndFrame(); // processes deferred destruction\n}\n</code></pre> <p>Why <code>EndFrame()</code> matters:</p> <ul> <li><code>DestroyNode()</code> and component <code>Remove&lt;T&gt;()</code> are deferred.</li> <li>Handles remain valid until <code>EndFrame()</code>.</li> <li>This prevents mid-frame invalidation bugs.</li> <li>Renderer frame submission also happens from world <code>EndFrame()</code>, so skipping it can stall visual updates.</li> </ul> <p>If you prefer less boilerplate in apps/examples, use <code>GameRuntime</code> and call <code>Runtime.Update(DeltaSeconds)</code>. <code>GameRuntime</code> orchestrates world lifecycle phases while <code>World</code> owns subsystem ticking/pumping.</p>"},{"location":"tutorials/worlds_graphs/#5-standalone-graphs-prefab-style","title":"5. Standalone Graphs (Prefab-Style)","text":"<p>Standalone graphs are valid data containers:</p> <pre><code>NodeGraph PrefabGraph(\"EnemyPrefab\");\nauto EnemyRoot = PrefabGraph.CreateNode(\"EnemyRoot\");\n</code></pre> <p>They can be serialized and reused, but they are not automatically pumped by a world loop unless you call tick methods yourself.</p>"},{"location":"tutorials/worlds_graphs/#6-world-ownership-pointer-inodeworld","title":"6. World Ownership Pointer (<code>INode::World()</code>)","text":"<p>Every node has <code>World()</code> access:</p> <ul> <li>In a world-owned tree, <code>World()</code> points to that <code>World</code>.</li> <li>In standalone/prefab graphs, <code>World()</code> may be <code>nullptr</code>.</li> </ul> <p>This is how systems are accessed from gameplay code:</p> <pre><code>auto* OwnerNode = SomeComponent.Owner().Borrowed();\nif (OwnerNode &amp;&amp; OwnerNode-&gt;World())\n{\n    // OwnerNode-&gt;World()-&gt;Audio(), OwnerNode-&gt;World()-&gt;Physics(), OwnerNode-&gt;World()-&gt;Renderer(), etc.\n}\n</code></pre>"},{"location":"tutorials/worlds_graphs/#7-common-mistakes","title":"7. Common Mistakes","text":"<ul> <li>Creating logic that assumes <code>World()</code> is always non-null.</li> <li>Forgetting <code>EndFrame()</code> and then wondering why removed objects still appear valid.</li> <li>Caching borrowed pointers across frame boundaries.</li> </ul> <p>Next: Nodes and Components</p>"}]}